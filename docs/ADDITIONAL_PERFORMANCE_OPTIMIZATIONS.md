# 追加パフォーマンス最適化計画

## 1. 概要

`PERFORMANCE_OPTIMIZATION_PLAN.md` にて分析された `05-1_Backend_Read.js` および `05-2_Backend_Write.js` 以外のファイルについて、パフォーマンス上の問題点と改善案をまとめる。

調査は主に以下の観点で行った。

1. **過剰なシート読み書き**: ループ内での `getValue(s)` / `setValue(s)` や、高コストなAPI呼び出し（`SpreadsheetApp.openById` など）。
2. **キャッシュ未使用**: `CacheManager` によってキャッシュされているデータを、シートから直接読み込んでいる箇所。
3. **根本的な改善案**: データ構造や処理フローの変更による、より大きな改善提案。

---

## 2. 調査結果と改善提案

### 2.1. `02-1_BusinessLogic_Batch.js`

#### 2.1.1. 問題点

- `logSalesFromArchivedData` 関数内で、アーカイブ処理のたびに `SpreadsheetApp.openById(SALES_SPREADSHEET_ID)` が呼び出されている。外部スプレッドシートへのアクセスは非常に高コストな処理です。
- `salesSheet.getRange(...).setValues(rowsToTransfer)` による書き込みも、データ量によっては実行時間制限に影響を与える可能性があります。

#### 2.1.2. 改善案

1. **書き込み処理のキューイング（推奨度：高）**:
    - 売上ログを即時書き込みするのではなく、`PropertiesService` や `CacheService` を使って一時的なキュー（待ち行列）にデータを保存します。
    - 時間ベースのトリガー（例：10分ごと）を設定し、キューに溜まったデータを一括で売上ログシートに書き込むバッチ処理を定期実行します。
    - **効果**: ユーザー操作へのレスポンスが向上し、API呼び出し回数も大幅に削減できます。

2. **スプレッドシートオブジェクトのキャッシュ（推奨度：中）**:
    - 即時書き込みが必須な場合、`00_SpreadsheetManager.js` を拡張し、外部スプレッドシートのオブジェクトもキャッシュできるようにします。
    - 一度 `openById` で開いたオブジェクトをメモリ上に保持することで、2回目以降の呼び出しコストを削減します。

### 2.2. `04_Backend_User.js`

#### 2.2.1. 問題点

- `getUsersWithoutPhoneNumber` 関数と `updateUserProfile` 関数が、生徒名簿シートを `getSheetByName` や `getDataRange().getValues()` を使って直接読み込んでいる。このデータは `CACHE_KEYS.ALL_STUDENTS_BASIC` としてキャッシュされています。
- `updateUserProfile` では、ユーザープロファイル更新のために、シートの全データを読み込み（`getValues`）、メモリ上で一部を更新後、全データを書き戻す（`clear` + `setValues`）という非常に高コストな処理を行っています。

#### 2.2.2. 改善案

1. **キャッシュの全面的な利用（推奨度：高）**:
    - `getUsersWithoutPhoneNumber` は、シートを読まずに `getCachedData(CACHE_KEYS.ALL_STUDENTS_BASIC)` を使って全生徒情報を取得し、その中から電話番号が未登録のユーザーを絞り込むように修正します。
    - **効果**: シートI/Oが不要になり、処理が高速化します。

2. **行単位での効率的な更新（推奨度：高）**:
    - `updateUserProfile` は、全データ書き換えを止め、まず対象ユーザーの「行番号」を特定します。
    - その後、`sheet.getRange(rowIndex, ...).setValues(...)` を使って、変更が必要な行だけを更新します。
    - **効果**: 書き込み処理の負荷が劇的に軽減され、他のユーザーの操作との競合リスクも低減します。

### 2.3. `06_ExternalServices.js`

#### 2.3.1. 問題点

- `addCalendarEventsToSheetWithSpecifics` 関数内で、教室設定のループ処理中に `ss.getSheetByName(sheetName)` が繰り返し呼ばれています。
- さらに、ループ内で `sheet.getRange(...).getValues()` を使い、シートに既存の日付をすべて読み込んでおり、非効率です。

#### 2.3.2. 改善案

1. **シートオブジェクトの一括取得（推奨度：中）**:
    - ループ処理を開始する前に、対象となるすべてのシートオブジェクトを `SpreadsheetManager` を使って一度に取得し、変数に格納しておきます。ループ内ではその変数を再利用します。
    - **効果**: `getSheetByName` の繰り返し呼び出しによるオーバーヘッドを削減します。

2. **データ読み込みの効率化（推奨度：低）**:
    - この関数は手動実行されるバッチ処理であるため、リアルタイム性が求められる他の処理に比べて改善の優先度は低いです。しかし、将来的に対象シートが増える可能性を考慮すると、各シートのデータをより効率的に一括で読み込む設計を検討する価値はあります。

### 2.4. `02-4_BusinessLogic_ScheduleMaster.js`

#### 2.4.1. 問題点

- `extractUniqueDateClassroomCombinations` 関数が `ss.getSheets()` を使ってスプレッドシート内の全シートを取得し、ループ内でシート内容を読み込んでいます。これはシート数が多くなるとパフォーマンスが著しく低下します。

#### 2.4.2. 改善案

1. **処理対象の限定（推奨度：高）**:
    - この関数は、古い教室別シートから日程マスタを生成するための「移行用ユーティリティ」です。
    - プロジェクトの現状として、すでにデータが「統合予約シート」に集約されている場合、`isReservationSheet` のような曖昧な判定で全シートを走査するのではなく、処理対象を「統合予約シート」のみに限定すべきです。
    - **効果**: 不要なシートの読み込みがなくなり、処理が大幅に高速化・安定化します。

2. **キャッシュデータの活用（推奨度：高）**:
    - もしこのロジックが移行以外でも利用される場合、シートを直接読む代わりに `getCachedData(CACHE_KEYS.ALL_RESERVATIONS)` を呼び出します。
    - キャッシュされた全予約データから、ユニークな日付と教室の組み合わせを抽出するように処理を変更します。
    - **効果**: シートI/Oが完全に不要になります。

---
**作成日**: 2025-08-29
