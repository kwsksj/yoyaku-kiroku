<!--
=================================================================
【ファイル名】: 10_WebApp.html
【バージョン】: 26.0 (モジュール化対応版)
【更新日時】: 2025-08-04
【説明】:
- 設定とモック機能を外部ファイルに分離
- より保守性の高い構造に改善
- テスト環境とプロダクション環境の分離
=================================================================
-->
<!doctype html>
<html lang="ja" class="h-full">
  <head>
    <meta charset="UTF-8" />
    <base target="_top" />
    <title>きぼりの よやく・きろく 川崎誠二木彫り教室</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+New:wght@400;500;700&family=JetBrains+Mono:wght@400;500&display=swap"
      rel="stylesheet"
      media="print"
      onload="this.media='all'"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+New:wght@400;500;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet"
      />
    </noscript>
  </head>

  <body class="bg-brand-bg h-full">
    <!-- デバッグ情報表示エリア（本番環境では非表示） -->

    <!-- アプリケーションのメインコンテナ -->
    <div id="app" class="container mx-auto px-4 max-w-lg">
      <!-- ローディング画面 -->
      <div
        id="loading"
        class="loading-fade fixed inset-0 flex flex-col items-center justify-center z-50"
      >
        <div class="spinner mb-4"></div>
        <p id="loading-message" class="text-brand-text">
          アプリケーションを読み込み中...
        </p>
      </div>

      <!-- メインコンテンツ -->
      <main id="main-content" class="py-6 embedded-no-padding">
        <div id="view-container"></div>
      </main>

      <!-- モーダルオーバーレイ -->
      <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content" class="modal-content">
          <div id="modal-body"></div>
        </div>
      </div>

      <!-- カスタムモーダル -->
      <div
        id="custom-modal"
        class="fixed inset-0 bg-gray-800 bg-opacity-50 flex items-center justify-center z-50"
      >
        <div class="bg-white rounded-lg p-6 max-w-sm mx-4">
          <h3 id="modal-title" class="text-lg font-bold mb-4"></h3>
          <div id="modal-message" class="mb-6"></div>
          <div id="modal-buttons" class="flex gap-3 justify-end"></div>
        </div>
      </div>
      <footer class="text-center text-sm text-brand-muted mt-4">
        きぼりの よやく・きろく
      </footer>
    </div>

    <!-- 統合JavaScriptはビルド時にここに挿入されます -->
    <!-- 統合JavaScript (自動生成) -->
<script>

  // =================================================================
  // 00_Constants.js (自動注入 from backend)
  // =================================================================

/// <reference path="../../types/gas-environment.d.ts" />
/// <reference path="../../types/constants.d.ts" />

/**
 * =================================================================
 * 【ファイル名】: 00_Constants.js
 * 【バージョン】: 1.2
 * 【役割】: プロジェクト全体で使用する統一定数定義システム
 * 【v1.2での変更点】:
 * - JSDocを修正し、グローバル型定義との競合を解消
 * =================================================================
 */

/**
 * プロジェクト全体で使用する統一定数オブジェクト
 * 型定義は types/constants.d.ts で定義されています
 */
const CONSTANTS = {
  // タイムゾーン設定
  TIMEZONE: 'Asia/Tokyo',

  // 環境設定
  ENVIRONMENT: {
    DEBUG_MODE: typeof DEBUG !== 'undefined' ? DEBUG : false,
    PRODUCTION_MODE:
      typeof ScriptApp !== 'undefined' &&
      ScriptApp.getScriptId() ===
        '1BYOLy7kHfVEf96eJgPd9B-5ZQ5bNNOMwBiHtMt-6HZYrN2w9YhzG_Whi', // 本番ID
  },

  /**
   * 教室名定数
   */
  CLASSROOMS: {
    TOKYO: '東京教室',
    NUMAZU: '沼津教室',
    TSUKUBA: 'つくば教室',
  },

  /**
   * ステータス定数（4種類統合）
   */
  STATUS: {
    CANCELED: '取消', // キャンセル済み
    WAITLISTED: '待機', // キャンセル待ち
    CONFIRMED: '確定', // 予約確定（会計前）
    COMPLETED: '完了', // 完了（会計済み）
  },

  /**
   * 単位定数
   */
  UNITS: {
    THIRTY_MIN: '30分',
    PIECE: '個',
    SET: 'セット',
    CM3: 'cm³',
  },

  /**
   * 支払い方法定数
   */
  PAYMENT_METHODS: {
    CASH: 'cash',
    CARD: 'card',
    TRANSFER: 'transfer',
  },

  /**
   * UI関連定数
   */
  UI: {
    HISTORY_INITIAL_RECORDS: 10,
    HISTORY_LOAD_MORE_RECORDS: 10,
    LOADING_MESSAGE_INTERVAL: 3000,
    MODAL_FADE_DURATION: 300,
  },

  // 容量・制限
  LIMITS: {
    TSUKUBA_MORNING_SESSION_END_HOUR: 13,
    LOCK_WAIT_TIME_MS: 30000,
    MAX_RETRY_COUNT: 3,
  },

  // シート名
  SHEET_NAMES: {
    ROSTER: '生徒名簿',
    ACCOUNTING: '会計マスタ',
    LOG: 'アクティビティログ',
    RESERVATIONS: '統合予約シート',
    SCHEDULE: '日程マスタ',
  },

  // セッション関連
  SESSIONS: {
    MORNING: '午前',
    AFTERNOON: '午後',
    ALL_DAY: '全日',
  },

  // 支払い方法（表示用）
  PAYMENT_DISPLAY: {
    CASH: '現金',
    COTRA: 'ことら送金',
    BANK_TRANSFER: 'オンライン振込',
  },

  // 銀行情報
  BANK_INFO: {
    COTRA_PHONE: '09013755977',
    NAME: 'ゆうちょ銀行',
    BRANCH: '818',
    ACCOUNT: '2661797',
  },

  // フロントエンド固有のUI設定
  FRONTEND_UI: {
    DISCOUNT_OPTIONS: {
      NONE: 0,
      THIRTY_MIN: 30,
      SIXTY_MIN: 60,
    },
    TIME_SETTINGS: {
      STEP_MINUTES: 30,
      END_BUFFER_HOURS: 3,
    },
  },

  // メッセージ定数
  MESSAGES: {
    PROCESSING_INTERRUPTED: '処理を中断しました。',
    SHEET_INITIALIZATION: '日程マスタシートの初期化',
    EXISTING_SHEET_WARNING: `「日程マスタ」シートは既に存在します。
初期化しますか？（既存データは削除されます）`,
    SUCCESS: '成功',
    ERROR: 'エラー',
    CANCEL: 'キャンセル',
    SAVE: '保存する',
    EDIT: '編集',
  },

  // ログアクション定数
  LOG_ACTIONS: {
    ROSTER_EDIT: '名簿編集',
    RESERVATION_EDIT: '予約編集',
    ROW_INSERT: '行挿入',
    RESERVATION_CANCEL: '予約キャンセル',
  },

  // 教室タイプ定数
  CLASSROOM_TYPES: {
    SESSION_BASED: 'セッション制',
    TIME_DUAL: '時間制・2部制',
    TIME_FULL: '時間制・全日',
  },

  // スケジュールステータス定数
  SCHEDULE_STATUS: {
    SCHEDULED: '開催予定',
    CANCELLED: '休講',
    COMPLETED: '開催済み',
  },

  // シート別ヘッダー定数
  HEADERS: {
    // 統合予約シート（短縮名: RESERVATIONS）
    RESERVATIONS: {
      RESERVATION_ID: '予約ID',
      STUDENT_ID: '生徒ID',
      DATE: '日付',
      CLASSROOM: '教室',
      VENUE: '会場',
      START_TIME: '開始時刻',
      END_TIME: '終了時刻',
      STATUS: 'ステータス',
      CHISEL_RENTAL: '彫刻刀レンタル',
      FIRST_LECTURE: '初回',
      TRANSPORTATION: '来場手段',
      PICKUP: '送迎',
      WORK_IN_PROGRESS: '制作メモ',
      ORDER: 'order',
      MESSAGE_TO_TEACHER: 'メッセージ',
      ACCOUNTING_DETAILS: '会計詳細',
    },

    // 生徒名簿
    ROSTER: {
      STUDENT_ID: '生徒ID',
      REAL_NAME: '本名',
      NICKNAME: 'ニックネーム',
      PHONE: '電話番号',
      CAR: '車',
      CHISEL_RENTAL: '彫刻刀レンタル',
      LINE: 'LINE',
      NOTES: 'notes',
      FROM: 'from',
      REGISTRATION_DATE: '登録日時',
      EMAIL: 'メールアドレス',
      EMAIL_PREFERENCE: 'メール連絡希望',
      AGE_GROUP: '年代',
      AGE: '年齢',
      GENDER: '性別',
      DOMINANT_HAND: '利き手',
      ADDRESS: '住所',
      FUTURE_CREATIONS: '将来制作したいもの',
      WOODCARVING_EXPERIENCE: '木彫り経験',
      PAST_CREATIONS: '過去の制作物',
      FUTURE_PARTICIPATION: '今後のご参加について',
      TRIGGER: 'きっかけ',
      FIRST_MESSAGE: '初回メッセージ',
      COMPANION: '同行者',
      TRANSPORTATION: '来場手段',
      PICKUP: '送迎',
      TOTAL_PARTICIPATION: '参加回数',
      TOKYO_PARTICIPATION: '参加回数（東京）',
      NUMAZU_PARTICIPATION: '参加回数（沼津）',
      TSUKUBA_PARTICIPATION: '参加回数（つくば）',
      MITSUKOSHI_PARTICIPATION: '参加回数（三越）',
    },

    // 会計マスタ（短縮名: ACCOUNTING）
    ACCOUNTING: {
      TYPE: '種別',
      ITEM_NAME: '項目名',
      UNIT_PRICE: '単価',
      UNIT: '単位',
      TARGET_CLASSROOM: '対象教室',
      NOTES: '備考',
    },

    // 日程マスタ（短縮名: SCHEDULE）
    SCHEDULE: {
      DATE: '日付',
      CLASSROOM: '教室',
      VENUE: '会場',
      TYPE: '教室形式',
      FIRST_START: '1部開始',
      FIRST_END: '1部終了',
      SECOND_START: '2部開始',
      SECOND_END: '2部終了',
      BEGINNER_START: '初回者開始',
      TOTAL_CAPACITY: '全体定員',
      BEGINNER_CAPACITY: '初回者定員',
      STATUS: '状態',
      NOTES: '備考',
    },
  },

  // 会計項目定数
  ITEMS: {
    MAIN_LECTURE: '基本授業料',
    FIRST_LECTURE: '初回参加費',
    CHISEL_RENTAL: '彫刻刀レンタル',
    DISCOUNT: '初回者同時割引',
  },

  // 会計項目種別定数
  ITEM_TYPES: {
    TUITION: '授業料',
    SALES: '物販',
    MATERIAL: '材料',
  },

  // 注意: HEADER_MAPPINGS は過度に複雑だったため削除
  // 必要な箇所では直接的なswitch文で対応

  // その他のシステム定数
  SYSTEM: {
    MATERIAL_INFO_PREFIX: '\n【希望材料】: ',
    ARCHIVE_PREFIX: 'アーカイブ_',
    DATA_START_ROW: 2,
  },
};

// =================================================================
// 環境設定・デバッグ制御
// =================================================================

/**
 * 環境判定とデバッグ制御の統一管理
 */
const ENVIRONMENT_CONFIG = {
  // デバッグ出力制御
  DEBUG_ENABLED: false, // 本番環境では false
};

  // @ts-check
  /// <reference path="../html-globals.d.ts" />

  // グローバル変数宣言（VSCode TypeScript言語サーバー用）
  /* global CONSTANTS:readonly, STATUS:readonly, CLASSROOMS:readonly, ITEMS:readonly, HEADERS:readonly */
  /* global ITEM_TYPES:readonly, UNITS:readonly, PAYMENT_METHODS:readonly, UI:readonly, SESSIONS:readonly */
  /* global PAYMENT:readonly, BANK_INFO:readonly, BANK:readonly, MESSAGES:readonly, LOG_ACTIONS:readonly */
  /* global CLASSROOM_TYPES:readonly, SCHEDULE_STATUS:readonly, SHEET_NAMES:readonly, LIMITS:readonly */
  /* global DISCOUNT_OPTIONS:readonly, TIME_SETTINGS:readonly, SYSTEM:readonly, HEADERS_RESERVATIONS:readonly */
  /* global HEADERS_ROSTER:readonly, HEADERS_ACCOUNTING:readonly, HEADERS_SCHEDULE:readonly */
  /* global DesignConfig:readonly, stateManager:readonly, Components:readonly, pageTransitionManager:readonly */
  /* global escapeHTML:readonly, formatDate:readonly, showLoading:readonly, hideLoading:readonly */
  /* global showInfo:readonly, showConfirm:readonly, debugLog:readonly, getTuitionItemRule:readonly */
  /* global getTimeBasedTuitionHtml:readonly, createReservationCard:readonly, findReservationByDateAndClassroom:readonly */
  /* global isTimeBasedClassroom:readonly, getClassroomTimesFromSchedule:readonly, buildSalesChecklist:readonly */
  /* global findReservationById:readonly, google:readonly, server:readonly, MockData:readonly */
  /* global isProduction:readonly, C:readonly */

  // ESLintワンライン無効化
  /* eslint-disable no-undef */

  /**
   * =================================================================
   * 統合フロントエンドJavaScript (自動生成)
   * Generated: 2025-09-27T15:26:06.201Z
   * =================================================================
   */

  // =================================================================
  // 11_WebApp_Config.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 11_WebApp_Config.html
   * 【バージョン】: 1.7
   * 【役割】: WebAppのフロントエンドで使用される設定とスタイル定義
   * 【構成】: 14ファイル構成のうちの11番目
   * 【v1.7での変更点】:
   * - 全体的な配色をよりエネルギッシュで温かみのあるテーマに更新
   * - ボタンのテキストの可読性を向上
   * - 会計ボタンに黄色系の配色を適用
   * - 記録カードに背景色を追加
   * =================================================================
   */

  // =================================================================
  // 1. APPLICATION CONSTANTS（統一定数システム）
  // =================================================================

  // 【重要】統一定数は 00_Constants.js から自動注入されます
  // ビルド時にバックエンドの定数ファイルがフロントエンドJavaScriptの先頭に自動挿入されるため、
  // CONSTANTSオブジェクトがグローバルに利用可能になります
  //
  // 注意: このファイルでは、バックエンド定数との重複を避けるため
  // フロントエンド専用の定数のみ定義します

  // --- フロントエンド専用定数（バックエンドとの重複なし） ---

  // Googleサイト埋め込み環境の検出と調整
  window.EmbedConfig = {
    // Googleサイトのヘッダー高さ検出
    detectGoogleSiteOffset: () => {
      try {
        // 1. Googleサイト環境かどうかを検出
        const isInFrame = window.parent !== window;
        let isInGoogleSites = false;

        try {
          isInGoogleSites =
            isInFrame &&
            (window.parent.location.hostname.includes('sites.google.com') ||
              document.referrer.includes('sites.google.com') ||
              window.location.ancestorOrigins?.[0]?.includes('sites.google.com'));
        } catch (e) {
          // Cross-origin制限でアクセスできない場合は他の方法で判定
          isInGoogleSites =
            isInFrame &&
            (document.referrer.includes('sites.google.com') ||
              window.location.search.includes('embedded=true'));
        }

        if (!isInGoogleSites) {
          return 0; // 直接アクセスの場合はオフセットなし
        }

        // 2. URLパラメータでの手動指定をチェック
        const urlParams = new URLSearchParams(window.location.search);
        const manualOffset = urlParams.get('headerOffset');
        if (manualOffset && !isNaN(parseInt(manualOffset))) {
          const offset = parseInt(manualOffset);
          console.log(`手動指定のヘッダーオフセット: ${offset}px`);
          return offset;
        }

        // 3. ローカルストレージでの記憶設定をチェック
        const savedOffset = localStorage.getItem('googleSitesHeaderOffset');
        if (savedOffset && !isNaN(parseInt(savedOffset))) {
          const offset = parseInt(savedOffset);
          console.log(`記憶されたヘッダーオフセット: ${offset}px`);
          return offset;
        }

        // 4. 動的にヘッダーサイズを検出
        const viewportHeight = window.innerHeight;
        const bodyRect = document.body.getBoundingClientRect();
        const documentHeight = document.documentElement.clientHeight;

        // ビューポートと実際のコンテンツ領域の差からヘッダー高さを推定
        const estimatedHeaderHeight = Math.max(
          0,
          Math.abs(bodyRect.top), // body要素のオフセット
          documentHeight - viewportHeight, // 文書とビューポートの差
        );

        // 5. デバイス・ブラウザ別のデフォルト値
        const isMobile = window.innerWidth <= 768;
        let defaultOffset = 60; // デスクトップデフォルト

        if (isMobile) {
          defaultOffset = 50; // モバイルデフォルト
        }

        // 6. 推定値に基づく調整
        if (estimatedHeaderHeight > 100) {
          return 120; // 大きなヘッダー（新しいGoogleサイト）
        } else if (estimatedHeaderHeight > 50) {
          return 80; // 中程度のヘッダー
        } else if (estimatedHeaderHeight > 0) {
          return Math.max(defaultOffset, estimatedHeaderHeight + 10); // 余裕を持たせる
        }

        return defaultOffset;
      } catch (error) {
        console.log('ヘッダーオフセット検出エラー:', error);
        return 60; // フォールバックオフセット
      }
    },

    // オフセット値をローカルストレージに保存
    saveOffset: offset => {
      try {
        localStorage.setItem('googleSitesHeaderOffset', offset.toString());
        console.log(`ヘッダーオフセット保存: ${offset}px`);
      } catch (error) {
        console.log('オフセット保存エラー:', error);
      }
    },

    // 動的スタイル調整の適用
    applyEmbedStyles: () => {
      const offset = window.EmbedConfig.detectGoogleSiteOffset();

      if (offset > 0) {
        // オフセット値をローカルストレージに保存
        window.EmbedConfig.saveOffset(offset);

        // ページ全体のトップマージンを調整
        const style = document.createElement('style');
        style.id = 'google-sites-embed-styles';
        style.textContent = `
          body {
            margin-top: 0px !important;
            min-height: 100% !important;
          }

          /* フィックス要素の位置調整 */
          .fixed {
            top: 0px !important;
          }

          /* Googleサイト埋め込み用のスムーズスクロール */
          html {
            scroll-behavior: smooth;
            scroll-padding-top: 20px;
          }

          /* オフセット設定ボタン（デバッグ用） */
          .embed-offset-control {
            position: fixed;
            top: ${offset + 10}px;
            right: 10px;
            z-index: 9999;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            display: none;
          }

          /* デバッグモードでのみ表示 */
          body.debug-mode .embed-offset-control {
            display: block;
          }
        `;
        document.head.appendChild(style);

        // デバッグ用のオフセット調整ボタンを追加
        window.EmbedConfig.addOffsetControl(offset);

        console.log(
          `Googleサイト環境を検出: ヘッダーオフセット ${offset}px を適用`,
        );
      }
    },

    // デバッグ用オフセット調整コントロールの追加
    addOffsetControl: currentOffset => {
      // 既存のコントロールを削除
      const existingControl = document.getElementById('embed-offset-control');
      if (existingControl) {
        existingControl.remove();
      }

      // 新しいコントロールを追加
      const control = document.createElement('div');
      control.id = 'embed-offset-control';
      control.className = 'embed-offset-control';
      control.innerHTML = `オフセット: ${currentOffset}px`;
      control.onclick = () => {
        window.EmbedConfig.showOffsetAdjustment();
      };
      document.body.appendChild(control);

      // URLにdebug=trueがある場合はデバッグモードを有効化
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('debug') === 'true') {
        document.body.classList.add('debug-mode');
      }
    },

    // オフセット調整のモーダル表示
    showOffsetAdjustment: () => {
      const currentOffset = window.EmbedConfig.detectGoogleSiteOffset();
      const newOffset = prompt(
        `現在のヘッダーオフセット: ${currentOffset}px\n\n` +
          '新しいオフセット値を入力してください（0-200）:',
        currentOffset.toString(),
      );

      if (newOffset !== null && !isNaN(parseInt(newOffset))) {
        const offset = Math.max(0, Math.min(200, parseInt(newOffset)));
        window.EmbedConfig.saveOffset(offset);
        window.EmbedConfig.reapplyStyles(offset);
        alert(`ヘッダーオフセットを ${offset}px に設定しました。`);
      }
    },

    // スタイルの再適用
    reapplyStyles: offset => {
      // eslint-disable-line no-unused-vars
      // 既存のスタイルを削除
      const existingStyle = document.getElementById('google-sites-embed-styles');
      if (existingStyle) {
        existingStyle.remove();
      }

      // 新しいオフセットで再適用
      window.EmbedConfig.applyEmbedStyles();
    },
  };

  // =================================================================
  // 2. DESIGN CONFIGURATION
  // =================================================================
  window.DesignConfig = /** @type {DesignSystemConfig} */ (
    window.DesignConfig || {
      // テキストや背景の色設定（温かみと活気のある配色）
      colors: {
        text: 'text-brand-text', // メインテキスト
        textSubtle: 'text-brand-subtle', // サブテキスト
        textMuted: 'text-brand-muted', // 薄いテキスト
        primary:
          'bg-action-primary-bg text-action-primary-text active:bg-action-primary-hover', // プライマリ (テラコッタ)
        secondary:
          'bg-action-secondary-bg text-action-secondary-text active:bg-action-secondary-hover', // セカンダリ (明るいベージュ)
        attention:
          'bg-action-attention-bg text-action-attention-text active:bg-action-attention-hover', // 注意 (若葉色)
        accounting:
          'bg-orange-100 text-orange-800 active:bg-orange-200 border-2 border-orange-200', // 会計 (調和したオレンジ)
        danger:
          'bg-state-danger-bg text-state-danger-text active:bg-state-danger-hover', // 危険 (落ち着いた赤)
        success:
          'bg-state-success-bg text-state-success-text active:bg-state-success-hover', // 成功 (若葉色)
        paid: 'bg-action-paid-bg text-action-paid-text', // 支払い済み (薄い緑)
        info: 'bg-ui-surface text-brand-text border-2 border-ui-border',
        warning:
          'bg-ui-warning-bg text-ui-warning-text border-2 border-ui-warning-border',
        error:
          'bg-ui-error-bg text-ui-error-text border-2 border-ui-error-border',
      },

      // 教室別のボタン色設定
      classroomColors: {
        tokyo: {
          button: 'bg-red-50 border-red-200 text-red-800 hover:bg-red-100',
          colorClass: 'bg-red-50 border-red-200 text-red-800 hover:bg-red-100',
        },
        numazu: {
          button: 'bg-blue-50 border-blue-200 text-blue-800 hover:bg-blue-100',
          colorClass:
            'bg-blue-50 border-blue-200 text-blue-800 hover:bg-blue-100',
        },
        tsukuba: {
          button:
            'bg-green-50 border-green-200 text-green-800 hover:bg-green-100',
          colorClass:
            'bg-green-50 border-green-200 text-green-800 hover:bg-green-100',
        },
        default: {
          button:
            'bg-state-available-bg border-state-available-border text-brand-text hover:bg-gray-50',
          colorClass:
            'bg-state-available-bg border-state-available-border text-brand-text hover:bg-gray-50',
        },
      },

      // ボタンの基本スタイル
      buttons: {
        base: 'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly',
        full: 'w-[250px] mx-auto block',
        primary:
          'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly bg-action-primary-bg text-action-primary-text active:bg-action-primary-hover',
        secondary:
          'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly bg-action-secondary-bg text-action-secondary-text active:bg-action-secondary-hover',
        attention:
          'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly bg-action-attention-bg text-action-attention-text active:bg-action-attention-hover',
        accounting:
          'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly bg-orange-100 text-orange-800 active:bg-orange-200 border-2 border-orange-200',
        // カード内ボタン専用スタイル（カードと調和する色）
        bookingCard:
          'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly bg-green-100 text-green-800 active:bg-green-200 border-2 border-green-200',
        recordCard:
          'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly bg-amber-100 text-amber-800 active:bg-amber-200 border-2 border-amber-200',
      },

      // テキストスタイル設定
      text: {
        heading: 'text-xl font-bold text-brand-text',
        subheading: 'text-lg font-medium text-brand-text',
        body: 'text-base text-brand-text',
        bodySubtle: 'text-base text-brand-subtle',
        caption: 'text-sm text-brand-subtle',
        label: 'text-base font-bold text-brand-text',
        labelBlock: 'block text-brand-text text-base font-bold mb-2',
      },

      // レイアウトユーティリティ
      layout: {
        container: 'max-w-screen-sm mx-auto p-4',
        containerNoPadding: 'max-w-screen-sm mx-auto',
        section: 'mb-8',
        card: 'shadow-card rounded-lg border-2 border-solid border-card-border',
        centerContent: 'flex items-center justify-center',
        spaceBetween: 'flex items-center justify-between',
      },

      // ユーティリティクラス
      utils: {
        hidden: 'hidden',
        loading: 'opacity-50 pointer-events-none',
        mobileFriendly: 'mobile-button touch-friendly',
        flexCenter: 'flex items-center justify-center',
        flexBetween: 'flex items-center justify-between',
        fullWidth: 'w-full',
        autoMargin: 'mx-auto',
      },

      // カードスタイル
      cards: {
        base: 'w-full text-left p-3 rounded-lg mobile-card touch-friendly transition-all duration-150',
        container: 'max-w-md mx-auto space-y-3',
        background: 'bg-ui-surface border-2 border-ui-border',
        state: {
          available: {
            card: 'bg-state-available-bg border-2 border-state-available-border mobile-card active:bg-state-available-hover',
            text: 'text-state-available-text',
          },
          waitlist: {
            card: 'bg-state-waitlist-bg border-2 border-state-waitlist-border mobile-card',
            text: 'text-state-waitlist-text',
          },
          booked: {
            card: 'bg-state-booked-bg border-2 border-state-booked-border mobile-card',
            text: 'text-state-booked-text',
          },
          history: {
            card: 'bg-amber-50 border-2 border-amber-200 mobile-card',
          },
        },
      },

      // 入力フォームのスタイル
      inputs: {
        container: 'max-w-md mx-auto',
        base: 'text-base w-full p-3 border-2 border-ui-border rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-text mobile-input touch-friendly bg-ui-input focus:bg-ui-input-focus transition-all duration-150',
        textarea:
          'text-base w-full p-3 border-2 border-ui-border rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-text h-24 mobile-input bg-ui-input focus:bg-ui-input-focus transition-all duration-150',
        phone:
          'text-base w-48 max-w-full p-3 border-2 border-ui-border rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-text mobile-input touch-friendly bg-ui-input focus:bg-ui-input-focus transition-all duration-150 font-mono',
      },
    }
  );

  // =================================================================
  // 3. CSS STYLES SETUP
  // =================================================================
  const addCustomStyles = () => {
    const style = document.createElement('style');
    style.textContent = `
        /* ========== Viewport Height Fix for Mobile Keyboards ========== */
        body {
          /* min-h-screen の挙動を上書き */
          min-height: 100vh; /* フォールバック */
          min-height: calc(var(--vh, 1vh) * 100);
        }

        /* ========== Font Loading Optimization ========== */
        /* フォントはHTMLのheadセクションで読み込み済み */

        /* Prevent FOUT (Flash of Unstyled Text) */
        .font-loading {
          visibility: hidden;
        }

        .fonts-loaded .font-loading {
          visibility: visible;
        }

        /* ========== CSS Variables - kibori-class.net完全調和デザイン ========== */
        :root {
          /* Energetic and warm theme for a wood carving school */
          --brand-text: #4E342E;       /* Dark Brown for high readability */
          --brand-subtle: #785A4E;     /* Medium Brown for sub-text */
          --brand-muted: #A1887F;      /* Lighter, soft brown */
          --brand-bg: #FFFDF5;         /* Warm, very light cream background */
          --brand-surface: #FFFFFF;    /* White for card backgrounds for a clean look */
          --brand-light: #F5F1ED;      /* Light, warm beige for hover states */

          --action-primary: #C86F34;   /* Energetic terracotta for main actions */
          --action-secondary: #E4CDBA; /* Light, warm beige for secondary actions */
          --action-attention: #5A8C36; /* Lively, fresh green for attention */
          --action-accounting: #F59E0B;/* Bright amber for accounting actions */
          --action-danger: #B91C1C;    /* A clear, strong red for danger */

          --state-available: #1E40AF;  /* Clear blue for available slots */
          --state-waitlist: #F59E0B;   /* Bright amber for waitlist */
          --state-booked: #785A4E;     /* Medium brown for booked slots */

          /* UI要素 - より洗練された境界線と背景 */
          --ui-border: #D4C4B8;        /* 温かみのあるベージュ境界線 */
          --ui-border-light: #E8DDD6;  /* より薄い境界線 */
          --ui-input: #FAFAFA;         /* 入力フィールド背景 */
          --ui-input-focus: #FFFFFF;   /* フォーカス時背景 */
          --ui-surface: #FFFFFF;       /* サーフェス背景 */

          /* モーダルとオーバーレイ */
          --modal-overlay: rgba(73, 59, 49, 0.6); /* ブランドカラーベースのオーバーレイ */
          --spinner-border: #f3f4f6;

          /* 影とエフェクト */
          --shadow-sm: 0 1px 2px 0 rgba(73, 59, 49, 0.05);
          --shadow-md: 0 4px 6px -1px rgba(73, 59, 49, 0.1);
          --shadow-lg: 0 10px 15px -3px rgba(73, 59, 49, 0.1);
        }

        /* ========== Base Styles ========== */
        body {
          font-family: 'Zen Kaku Gothic New', sans-serif;
          color: var(--brand-text);
          background-color: var(--brand-bg);
          line-height: 1.6;
          /* モバイル環境でのGoogleサイト埋め込み対応 */
          padding-top: env(safe-area-inset-top, 0);
        }

        /* Googleサイト埋め込み時のモバイル対応 */
        @media screen and (max-width: 768px) {
          body.embedded-in-google-sites {
            padding-top: 0;
            min-height: 100%;
          }

          body.embedded-in-google-sites .fixed.top-4 {
            top: 1rem;
          }

          body.embedded-in-google-sites #app {
            min-height: 100%;
          }
        }

        /* より大きなメニューバーの場合 */
        @media screen and (max-width: 480px) {
          body.embedded-in-google-sites {
            padding-top: 0;
            min-height: 100%;
          }

          body.embedded-in-google-sites .fixed.top-4 {
            top: 1rem;
          }

          body.embedded-in-google-sites #app {
            min-height: 100%;
          }
        }

        /* ========== Mobile-Friendly Components ========== */
        .mobile-button, .mobile-input, .mobile-card {
          min-height: 48px;
        }
        .touch-friendly {
          touch-action: pan-y pinch-zoom;
        }

        .scroll-container {
          touch-action: pan-y;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }

        /* ========== Animations ========== */
        .fade-in { animation: fadeInUp 0.3s ease-out; }
        @keyframes fadeInUp {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .spinner {
          border: 4px solid var(--spinner-border);
          width: 32px;
          height: 32px;
          border-radius: 50%;
          border-left-color: var(--brand-text);
          animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* ========== Layout Components ========== */
        #loading { z-index: 100; }
        .modal-overlay {
          position: fixed; inset: 0; background-color: var(--modal-overlay);
          display: flex; align-items: center; justify-content: center;
          z-index: 50; opacity: 0; transition: opacity 0.3s ease;
          pointer-events: none; backdrop-filter: blur(3px);
        }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }
        #custom-modal {
          opacity: 0; transition: opacity 0.3s ease; pointer-events: none;
        }
        #custom-modal.active { opacity: 1; pointer-events: auto; }
        /* 汎用モーダルのフェードインアニメーション */
        .modal-fade {
          opacity: 0; transition: opacity 0.3s ease; pointer-events: none;
        }
        .modal-fade.active { opacity: 1; pointer-events: auto; }
        /* ローディング画面のフェードアニメーション */
        .loading-fade {
          opacity: 0; transition: opacity 0.3s ease; pointer-events: none;
        }
        .loading-fade.active { opacity: 1; pointer-events: auto; }
        /* ローディング画面の背景を少し透明にして滑らかな遷移を実現 */
        #loading { background-color: rgba(255, 255, 255, 0.95); backdrop-filter: blur(2px); }
        .modal-content {
          background: white; padding: 1.5rem; border-radius: 0.75rem;
          width: 90%; max-width: 400px; text-align: center;
          max-height: 85vh; overflow-y: auto;
        }
        .modal-content p { margin-bottom: 1.25rem; }
        .modal-content .modal-buttons { justify-content: center; }

        /* ========== Custom Components ========== */
        details > summary {
          list-style: none;
          cursor: pointer;
          /* スマホ向けタッチフィードバック */
          -webkit-tap-highlight-color: transparent;
          touch-action: manipulation;
          user-select: none;
        }
        details > summary::-webkit-details-marker { display: none; }

        /* スマホでのタップ時の視覚的フィードバック */
        details > summary:active {
          transform: scale(0.98);
          transition: transform 0.1s ease;
        }

        /* 矢印の回転アニメーション */
        details[open] > summary .transition-transform {
          transform: rotate(90deg);
        }

        .accounting-item, .reservation-card {
          background-color: var(--brand-surface);
          border: 2px solid var(--ui-border);
          transition: all 0.2s ease;
          position: relative;
        }
        .accounting-item:hover, .reservation-card:hover {
          transform: translateY(-2px);
          box-shadow: var(--shadow-md);
          border-color: var(--brand-accent);
        }

        /* よやくカード専用のほんのり緑系色 */
        .bg-state-booked-bg {
          background-color: #f0fdf4 !important; /* ほんのり緑系の薄い背景 */
        }
        .border-state-booked-border {
          border-color: #bbf7d0 !important; /* 優しい緑系の境界線 */
        }
        .text-state-booked-text {
          color: #15803d !important; /* 落ち着いた緑でコントラスト確保 */
        }

        /* きろくカード専用の茶色・ベージュ系色 */
        .bg-amber-50 {
          background-color: #fffbeb !important; /* 温かみのあるベージュ背景 */
        }
        .border-amber-200 {
          border-color: #fde68a !important; /* 茶色系の境界線 */
        }

        /* ========== レイアウト改善 - memo.md問題対応 ========== */

        /* もどるボタンの位置を右上に固定（問題#3対応） */
        .back-button-container {
          position: fixed;
          top: 1rem;
          right: 1rem;
          z-index: 40;
          transform: none !important; /* 位置ズレ防止（問題#36対応） */
        }

        /* Googleサイト埋め込み時のもどるボタン調整（問題#14対応） */
        body.embedded-in-google-sites .back-button-container {
          top: 1rem;
        }

        @media screen and (max-width: 480px) {
          body.embedded-in-google-sites .back-button-container {
            top: 1rem;
          }
        }

        /* ========== 数字専用等幅フォント ========== */
        .font-mono-numbers {
          font-family: 'JetBrains Mono', 'Inconsolata', 'Monaco', 'Consolas', 'Courier New', monospace;
          font-feature-settings: 'tnum' 1; /* Tabular numbers */
          font-variant-numeric: tabular-nums;
        }

        /* 価格表示専用クラス */
        .price-amount {
          font-family: 'JetBrains Mono', 'Inconsolata', 'Monaco', 'Consolas', 'Courier New', monospace;
          font-feature-settings: 'tnum' 1;
          font-variant-numeric: tabular-nums;
          font-weight: 500;
          display: inline-block;
          min-width: 4.5em;
          text-align: right;
        }

        /* 大きなサイズの価格表示用 */
        .price-amount.large {
          min-width: 5.5em; /* より大きな金額用 */
        }

        /* 小さなサイズの価格表示用 */
        .price-amount.small {
          min-width: 3.5em; /* より小さな金額用 */
        }

        /* 時間表示専用クラス */
        .time-display {
          font-family: 'JetBrains Mono', 'Inconsolata', 'Monaco', 'Consolas', 'Courier New', monospace;
          font-feature-settings: 'tnum' 1;
          font-variant-numeric: tabular-nums;
        }

        /* 電話番号・メールアドレス入力フィールド専用クラス */
        input[type="tel"], input[type="email"] {
          font-family: 'JetBrains Mono', 'Inconsolata', 'Monaco', 'Consolas', 'Courier New', monospace;
          font-feature-settings: 'tnum' 1;
          font-variant-numeric: tabular-nums;
          font-size: 1rem; /* プレースホルダと入力時のフォントサイズを統一 */
        }

        /* メールアドレス入力フィールドを広く */
        input[type="email"] {
          min-width: 280px;
          width: 100%;
        }

        /* プレースホルダのフォントサイズを明示的に設定 */
        input[type="tel"]::placeholder, input[type="email"]::placeholder {
          font-size: 1rem;
          opacity: 0.6;
        }

        /* ========== カスタムプルダウンスタイル ========== */
        .custom-select {
          -webkit-appearance: none;
          -moz-appearance: none;
          appearance: none;
          background-image: none;
          background-color: white;
        }

        /* 時間選択プルダウン（中央揃え・矢印なし） */
        .time-select {
          -webkit-appearance: none;
          -moz-appearance: none;
          appearance: none;
          background-image: none;
          background-color: white;
          text-align: center;
          padding-right: 0.75rem;
        }

        /* 材料・販売品プルダウン（左揃え・矢印なし） */
        .material-select, .product-select {
          -webkit-appearance: none;
          -moz-appearance: none;
          appearance: none;
          background-image: none;
          background-color: white;
          text-align: left;
          padding-right: 0.75rem;
        }

        /* Firefox specific */
        .custom-select::-moz-focus-inner,
        .time-select::-moz-focus-inner,
        .material-select::-moz-focus-inner,
        .product-select::-moz-focus-inner {
          border: 0;
        }

        /* IE specific */
        .custom-select::-ms-expand,
        .time-select::-ms-expand,
        .material-select::-ms-expand,
        .product-select::-ms-expand {
          display: none;
        }

        /* ========== 新カードレイアウト - よやく・きろくカード ========== */

        .booking-card, .record-card {
          padding: 1rem;
          display: flex;
          flex-direction: column;
          gap: 0.5rem;
          position: relative;
        }

        /* カード上部: 教室情報 + 編集ボタン */
        .card-header {
          display: flex;
          justify-content: space-between;
          align-items: flex-start;
          gap: 1rem;
        }

        .card-class-info {
          flex: 1;
          display: flex;
          flex-direction: column;
          gap: 0.25rem;
        }

        .card-class-info .class-datetime {
          font-weight: 500;
          color: var(--brand-text);
          font-size: 1rem;
        }

        .card-class-info .class-venue {
          color: var(--brand-subtle);
          font-size: 0.875rem;
        }

        .card-edit-button {
          flex-shrink: 0;
          align-self: flex-start;
        }

        .card-edit-button button {
          font-size: 0.75rem;
          padding: 0.375rem 0.75rem;
          white-space: nowrap;
        }

        /* カード中央: 制作メモエリア */
        .card-memo-section {
          background-color: var(--brand-light);
          border: 2px solid var(--ui-border-light);
          border-radius: 0.5rem;
          padding: 0.75rem;
          min-height: 4rem;
        }

        .card-memo-section .memo-label {
          font-size: 0.75rem;
          font-weight: 500;
          color: var(--brand-subtle);
          margin-bottom: 0.5rem;
          display: block;
        }

        .card-memo-section .memo-content {
          color: var(--brand-text);
          font-size: 0.875rem;
          line-height: 1.4;
          white-space: pre-wrap;
          word-break: break-word;
        }

        .card-memo-section .memo-empty {
          color: var(--brand-muted);
          font-style: italic;
        }

        /* カード下部: 予約日以降に表示される会計ボタン */
        .card-accounting-section {
          border-top: 2px solid var(--ui-border-light);
          padding-top: 0.75rem;
          display: flex;
          justify-content: center;
        }

        .card-accounting-section button {
          min-width: 150px;
        }

        /* 予約日未満の場合は会計セクションを非表示 */
        .card-accounting-section.hidden {
          display: none;
        }

        /* ボタン配置の統一（問題#27,33対応） */
        .button-group {
          display: flex;
          gap: 0.75rem;
          justify-content: center;
          flex-wrap: wrap;
          margin: 1rem 0;
        }

        /* 左寄せが適切なページでは左寄せを維持 */
        .button-group.left-aligned {
          justify-content: flex-start;
        }

        /* オレンジ色ボタンの配置修正（問題#27対応） */
        .button-group button.accounting {
          flex-shrink: 0;
        }

        /* モーダル長さ制限（問題#15対応） */
        .modal-content {
          max-height: 80vh;
          overflow-y: auto;
        }

        @media screen and (max-height: 600px) {
          .modal-content {
            max-height: 70vh;
          }
        }

        /* ========== ページ遷移とスクロール位置管理（問題#16対応） ========== */
        .page-container {
          min-height: 100vh;
          scroll-behavior: smooth;
        }

        /* ページ遷移時のスクロール位置リセット */
        .view-transition {
          animation: pageSlideIn 0.3s ease-out;
        }

        @keyframes pageSlideIn {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        /* ========== 埋め込み環境での表示調整 ========== */
        /* 埋め込み時はパディングを無効化してズレを防ぐ */
        .embedded-no-padding {
          padding-top: 0 !important;
          padding-bottom: 0 !important;
        }

        /* 埋め込み環境での固定ヘッダー調整 */
        body.embedded-in-google-sites .sticky {
          top: 0 !important;
          padding-top: 0.75rem;
          padding-bottom: 0.75rem;
        }

        /* 埋め込み環境でのページヘッダー最適化 */
        body.embedded-in-google-sites .sticky .back-button-container {
          position: relative;
          top: auto;
          right: auto;
        }

        /* ========== 文字のちらつき防止（問題#6対応） ========== */
        .content-container {
          opacity: 0;
          transition: opacity 0.2s ease-in;
        }

        .content-container.loaded {
          opacity: 1;
        }

        /* フォント読み込み完了まで非表示 */
        .font-loading .content-container {
          visibility: hidden;
        }

        /* ========== Skeleton Loading States ========== */
        .skeleton {
          background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
          background-size: 200% 100%;
          animation: loading 1.5s infinite;
        }
        @keyframes loading {
          0% { background-position: 200% 0; }
          100% { background-position: -200% 0; }
        }

        /* ========== 会計画面の境界線スタイル ========== */
        . {
          border-top: 2px solid var(--ui-border);
          border-bottom: 2px solid var(--ui-border);
        }

        /* ========== Enhanced Responsive Design ========== */

        /* タブレット用調整 */
        @media screen and (min-width: 641px) and (max-width: 1024px) {
          .container {
            max-width: 600px;
            padding: 2rem;
          }

          .button-group {
            gap: 1rem;
          }

          .reservation-card .card-actions button {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
          }
        }

        /* スマートフォン用調整 */
        @media (max-width: 640px) {
          .modal-content {
            width: 95%;
            padding: 1rem;
            margin: 1rem;
          }
          .mobile-button, .mobile-input { font-size: 16px; }

          /* ボタングループの小画面対応 */
          .button-group {
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
          }

          .button-group button {
            width: 100%;
            max-width: 280px;
          }

          /* もどるボタンのモバイル調整 */
          .back-button-container {
            top: 0.5rem;
            right: 0.5rem;
          }

          .back-button-container button {
            padding: 0.5rem;
            font-size: 0.875rem;
          }

          /* カードのモバイル最適化 */
          .booking-card, .record-card {
            padding: 0.5rem;
            gap: 0.5rem;
          }

          .card-header {
            flex-direction: column;
            gap: 0.75rem;
            align-items: stretch;
          }

          .card-edit-button {
            align-self: center;
          }

          .card-edit-button button {
            width: 100%;
            max-width: 120px;
          }

          .card-memo-section {
            padding: 0.5rem;
          }

          .card-accounting-section button {
            width: 100%;
            max-width: 200px;
          }
        }

        /* 極小画面（320px以下）対応 */
        @media (max-width: 320px) {
          .container {
            padding: 0.5rem;
          }

          .button-group button {
            font-size: 0.875rem;
            padding: 0.75rem;
          }

          .modal-content {
            margin: 0.5rem;
            padding: 0.75rem;
          }
        }
      `;
    document.head.appendChild(style);
  };

  // =================================================================
  // Font Loading Detection
  // =================================================================
  const setupFontLoadingDetection = () => {
    if ('fonts' in document) {
      document.fonts.ready.then(() => {
        document.documentElement.classList.add('fonts-loaded');
      });
    } else {
      // Fallback for older browsers
      setTimeout(() => {
        document.documentElement.classList.add('fonts-loaded');
      }, 1000);
    }
  };

  // =================================================================
  // Page Transition & Content Loading Management
  // =================================================================
  const setupPageTransitionManagement =
    /** @type {() => PageTransitionManager} */ (
      () => {
        let currentView = /** @type {ViewType | null} */ (null);
        let previousScrollPosition = 0;

        // ページ遷移時のスクロール位置リセット（問題#16対応）
        const resetScrollPosition = () => {
          window.scrollTo({ top: 0, left: 0, behavior: 'smooth' });
        };

        // スクロール位置を保存
        const saveScrollPosition = () => {
          previousScrollPosition = window.scrollY;
        };

        // スクロール位置を復元
        const restoreScrollPosition = () => {
          window.scrollTo({
            top: previousScrollPosition,
            left: 0,
            behavior: 'auto',
          });
        };

        // ページ遷移の判定とスクロール管理
        const handleViewChange = (
          /** @type {ViewType | string | null} */ newView,
          isModal = false,
        ) => {
          const hasViewChanged = currentView !== newView;

          if (isModal) {
            // モーダル開閉：スクロール位置を保持
            if (newView) {
              // モーダル開く時：現在位置を保存
              saveScrollPosition();
            } else {
              // モーダル閉じる時：位置を復元
              restoreScrollPosition();
            }
          } else if (hasViewChanged && newView) {
            // 実際のページ遷移：スクロール位置をリセット
            currentView = /** @type {ViewType | null} */ (newView);
            resetScrollPosition();
          }
        };

        // コンテンツ読み込み完了時の表示制御（問題#6対応）
        const initializeContentVisibility = () => {
          // フォント読み込み完了を待機
          document.fonts.ready.then(() => {
            const contentContainers =
              document.querySelectorAll('.content-container');
            contentContainers.forEach(container => {
              container.classList.add('loaded');
            });
          });

          // ページ遷移アニメーション
          const pageContainer = document.querySelector('.page-container');
          if (pageContainer) {
            pageContainer.classList.add('view-transition');
          }
        };

        // もどるボタンの位置調整（問題#36対応）
        const stabilizeBackButtonPosition = () => {
          const backButtonContainer = /** @type {HTMLElement | null} */ (
            document.querySelector('.back-button-container')
          );
          if (backButtonContainer) {
            // 位置の強制リセット
            backButtonContainer.style.transform = 'none';
            backButtonContainer.style.transition = 'none';

            // 少し待ってからtransitionを復活（スムーズな動作のため）
            setTimeout(() => {
              backButtonContainer.style.transition = 'all 0.2s ease';
            }, 100);
          }
        };

        return /** @type {PageTransitionManager} */ ({
          // PageTransitionManagerインターフェース準拠
          onPageTransition: (/** @type {ViewType} */ newView) => {
            handleViewChange(newView, false);
          },
          saveScrollPosition,
          restoreScrollPosition,
          getCurrentScrollPosition: () => previousScrollPosition,
          setScrollPosition: (/** @type {number} */ position) => {
            previousScrollPosition = position;
            window.scrollTo({ top: position, left: 0, behavior: 'auto' });
          },
          resetScrollPosition,

          // 追加機能（内部実装用）
          handleViewChange,
          initializeContentVisibility,
          stabilizeBackButtonPosition,

          // 統合初期化関数
          initializePage: () => {
            // 初回読み込み時は現在のビューを記録するのみ、スクロールリセットしない
            if (window.stateManager && window.stateManager.getState) {
              currentView = window.stateManager.getState().view;
            }
            initializeContentVisibility();
            stabilizeBackButtonPosition();
          },

          // モーダル操作時専用（showInfo, showConfirm等から呼び出し）
          onModalOpen: () => {
            handleViewChange('modal', true);
          },

          onModalClose: () => {
            handleViewChange(null, true);
          },
        });
      }
    );

  // グローバルに公開（StateManagerから使用可能）
  window.pageTransitionManager = setupPageTransitionManagement();

  // =================================================================
  // Mobile & Embedded Site Detection
  // =================================================================
  const setupMobileOptimizations = () => {
    // ビューポートの高さをCSSカスタムプロパティとして設定
    const setViewportHeight = () => {
      // window.innerHeight はキーボード表示時に変動する
      // この処理により、vh単位がキーボード表示に影響されなくなる
      const vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);

      // 埋め込み環境での基本調整のみ
      if (document.body.classList.contains('embedded-in-google-sites')) {
        console.log('Googleサイト埋め込み環境を検出しました');
      }
    };

    // 初期化時とウィンドウサイズ変更時に実行
    setViewportHeight();
    window.addEventListener('resize', setViewportHeight);

    // Googleサイト埋め込み検知
    const detectEmbeddedEnvironment = () => {
      try {
        // iframe内での実行かどうかを判定
        const isInIframe = window.self !== window.top;

        // Googleサイトのreferrerを検知
        const isFromGoogleSites = document.referrer.includes('sites.google.com');

        // URLのクエリパラメータでの判定（将来的な拡張用）
        const urlParams = new URLSearchParams(window.location.search);
        const embedParam = urlParams.get('embedded');

        return isInIframe || isFromGoogleSites || embedParam === 'true';
      } catch (e) {
        // Cross-origin制限でエラーが発生した場合、埋め込み環境と判定
        return true;
      }
    };

    // モバイル環境の検知
    const isMobile =
      /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent,
      ) || window.innerWidth <= 768;

    // viewport設定の最適化
    const optimizeViewport = () => {
      let viewport = /** @type {HTMLMetaElement | null} */ (
        document.querySelector('meta[name=viewport]')
      );
      if (!viewport) {
        viewport = /** @type {HTMLMetaElement} */ (
          document.createElement('meta')
        );
        viewport.name = 'viewport';
        document.head.appendChild(viewport);
      }

      if (isMobile) {
        viewport.content =
          'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
      } else {
        viewport.content = 'width=device-width, initial-scale=1.0';
      }
    };

    // 埋め込み環境での調整を適用
    if (detectEmbeddedEnvironment()) {
      document.body.classList.add('embedded-in-google-sites');

      // 必要に応じて追加の調整
      if (isMobile) {
        document.body.classList.add('mobile-embedded');
      }
    }

    optimizeViewport();

    // タッチ操作の最適化
    if (isMobile) {
      document.body.classList.add('touch-device');

      // iOS Safariでのバウンス効果を制御（より柔軟に）
      document.addEventListener(
        'touchmove',
        e => {
          // スクロール可能なエリア内では許可
          if (
            e.target.closest(
              '.scrollable, .scroll-container, main, body, [data-view]',
            )
          ) {
            return; // スクロール許可エリア
          }
          // 固定要素（ヘッダー、フッターなど）でのスクロールを防止
          if (e.target.closest('header, footer, .fixed, .sticky')) {
            e.preventDefault();
          }
        },
        { passive: false },
      );
    }
  };

  // =================================================================
  // 4. TAILWIND CSS SETUP
  // =================================================================
  // 注意: CDN版Tailwindは本番環境では推奨されませんが、Google Apps Script環境では
  // PostCSS pluginやTailwind CLIの利用が困難なため、CDN版を使用しています。
  const setupTailwindCSS = () => {
    const tailwindScript = document.createElement('script');
    tailwindScript.src = 'https://cdn.tailwindcss.com';

    tailwindScript.onload = function () {
      // @ts-ignore
      if (window.tailwind) {
        // @ts-ignore
        window.tailwind.config = {
          theme: {
            extend: {
              fontSize: { '2xs': '0.625rem' },
              fontFamily: { sans: ['Zen Kaku Gothic New', 'sans-serif'] },
              colors: {
                brand: {
                  bg: '#FFFDF5',
                  surface: '#FFFFFF',
                  text: '#4E342E',
                  subtle: '#785A4E',
                  light: '#F5F1ED',
                  dark: '#4E342E',
                  muted: '#A1887F',
                },
                action: {
                  'primary-bg': '#C86F34',
                  'primary-text': '#FFFFFF',
                  'primary-hover': '#A95B2A',
                  'secondary-bg': '#E4CDBA',
                  'secondary-text': '#4E342E', // Improved contrast
                  'secondary-hover': '#D7BCA9',
                  'attention-bg': '#5A8C36',
                  'attention-text': '#FFFFFF',
                  'attention-hover': '#4A732C',
                  'accounting-bg': '#F59E0B', // Amber
                  'accounting-text': '#4E342E', // Dark text for readability
                  'accounting-hover': '#D97706',
                  'danger-bg': '#B91C1C',
                  'danger-text': '#FFFFFF',
                  'danger-hover': '#991B1B',
                  'paid-bg': '#F0FDF4',
                  'paid-text': '#166534',
                },
                state: {
                  'available-text': '#1E40AF',
                  'available-bg': '#EFF6FF',
                  'available-border': '#93C5FD',
                  'available-hover': '#DBEAFE',
                  'waitlist-text': '#B45309',
                  'waitlist-bg': '#FFFBEB',
                  'waitlist-border': '#FDE68A',
                  'booked-text': '#15803D',
                  'booked-bg': '#F0FDF4',
                  'booked-border': '#BBF7D0',
                  'success-bg': '#F0FDF4',
                  'success-text': '#166534',
                  'success-border': '#A7F3D0',
                  'success-hover': '#D1FAE5',
                  'danger-bg': '#FEF2F2',
                  'danger-text': '#B91C1C',
                  'danger-border': '#FECACA',
                  'danger-hover': '#FEE2E2',
                },
                ui: {
                  border: '#E4CDBA',
                  'border-light': '#F5F1ED',
                  surface: '#FFFFFF',
                  input: '#FAFAFA',
                  'input-focus': '#FFFFFF',
                  'error-text': '#B91C1C',
                  'error-bg': '#FEF2F2',
                  'error-border': '#FECACA',
                  'warning-text': '#B45309',
                  'warning-bg': '#FFFBEB',
                  'warning-border': '#FDE68A',
                  'link-text': '#0369A1',
                  'weekend-sunday': '#B91C1C',
                  'weekend-saturday': '#0369A1',
                },
              },
            },
          },
        };
      }
    };

    tailwindScript.onerror = function () {
      console.warn('[CONFIG] Tailwind CSS読み込みに失敗しました');
    };

    document.head.appendChild(tailwindScript);
  };

  // =================================================================
  // 5. INITIALIZATION
  // =================================================================
  addCustomStyles();
  setupTailwindCSS();
  setupFontLoadingDetection();
  setupMobileOptimizations();

  // DOM読み込み完了後にページ遷移管理を初期化
  document.addEventListener('DOMContentLoaded', () => {
    const manager = /** @type {PageTransitionManager} */ (
      window.pageTransitionManager
    );
    if (manager && manager.initializePage) {
      manager.initializePage();
    }
  });


  // =================================================================
  // 12_WebApp_Core.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 12_WebApp_Core.js
   * 【バージョン】: 2.0
   * 【役割】: WebAppのフロントエンドにおける中核機能の統合ファイル。
   * 分割されたコア機能ファイルの参照と、残存する汎用ユーティリティを集約します。
   * 【構成】: 14ファイル構成のうちの12番目
   * 【v2.0での変更点】:
   * - ファイル分割によるメンテナンス性向上
   * - 機能別ファイルへの分離完了
   * - AI作業効率向上のための構造最適化
   * =================================================================
   */

  // =================================================================
  // --- Divided Core Files Reference ---
  // -----------------------------------------------------------------
  // 以下の機能は専用ファイルに分割されました：
  //
  // 📁 12_WebApp_Core_Search.js - 統一検索システム
  //   - findReservationById(reservationId, state)
  //   - findReservationByDateAndClassroom(date, classroom, state)
  //   - findReservationsByStatus(status, state)
  //
  // 📁 12_WebApp_Core_Data.js - データ処理・環境管理
  //   - processInitialData(data, phone, lessons, myReservations)
  //   - detectEnvironment()
  //   - getEnvironmentData(dataType, fallback)
  //   - ModalManager オブジェクト
  //   - StateManager 初期化処理
  //   - スケジュール関連ヘルパー関数
  //
  // 📁 12_WebApp_Core_Accounting.js - 会計計算ロジック
  //   - calculateAccountingDetails()
  //   - calculateAccountingDetailsFromForm()
  //   - calculateTimeBasedTuition(tuitionItemRule)
  //   - 各種計算ヘルパー関数
  //   - 会計キャッシュ機能
  //
  // 📁 12_WebApp_Core_ErrorHandler.js - エラーハンドリング
  //   - FrontendErrorHandler クラス
  //   - handleServerError(err) 互換関数
  //   - グローバル・Promise拒否エラー処理
  //   - 開発/本番環境対応ログ出力
  //
  // 📁 14_WebApp_Handlers_Utils.js - 統合済みユーティリティ
  //   - normalizePhoneNumberFrontend(phoneInput)
  //   - buildSalesChecklist(accountingMaster, checkedValues, title)
  //   - formatDate(dStr)
  //   - 各種DOM型安全ヘルパー関数
  // =================================================================

  // =================================================================
  // --- Loading Message System ---
  // -----------------------------------------------------------------
  // UI-11: ローディングメッセージの多様化機能
  // 状況に応じたメッセージとユーモラスなメッセージをランダムに表示し、
  // 数秒ごとに自動で切り替える機能を提供します。
  // =================================================================

  /** @type {number | null} */
  let loadingMessageTimer = null;

  const LoadingMessages = {
    // ログイン時のメッセージ
    login: [
      'めいぼ を さがしています...',
      'めいぼ じたい を さがしています...',
      'めいぼ の うらの めも を かくにん しています...',
      'きろく を かくにん しています...',
      'しょるい を ひもといて しています...',
      'なまえ を かくにん しています...',
      'なまえ の よみかた を かくにん しています...',
      'かお を おもいだしています...',
      'おみやげ を おもいだしています...',
      'さくひん を おもいだしています...',
      'とうろく が あるか しらべています...',
      'でんわばんごう を かくにん しています...',
      'ひと と なり を そうぞう しています...',
      'にがお え を かいています...',
    ],

    // 申し込み時のメッセージ
    booking: [
      'よやく を もうしこみ ちゅうです...',
      'しんせいしょ を ていしゅつ しています...',
      'はんこ を さがしています...',
      'ひづけ を かくにん しています...',
      'かれんだー に かきこんでいます...',
      'せき を ようい しています...',
      'きぼう を かなえようとしています...',
      'いろいろな ちょうせい を しています...',
      'そうごうてきに ちょうせい を しています...',
      'しょるい の けいしき を かくにんしています...',
      'じゅんばん に ならべています...',
    ],

    // 予約キャンセル時のメッセージ
    cancel: [
      'よやく を とりけしています...',
      'けしごむ を さがしています...',
      'とりけしせん を ひいています...',
      'おだいじに と おもっています...',
      'また こんど を たのしみにしています...',
      'べつの ひ を かんがえています...',
    ],

    // 予約編集時のメッセージ
    edit: [
      'へんこう を ほぞんしています...',
      'あたらしい ないよう に かきかえています...',
      'まちがい が ないか かくにんしています...',
      'かんがえなおして みています...',
      'こだわり を ちょうせい しています...',
    ],

    // 会計時のメッセージ
    accounting: [
      'でんぴょう を おくっています...',
      'ちょうぼ を つけています...',
      'おかね を かぞえています...',
      'おつり を じゅんびしています...',
      'そろばん を はじいています...',
      'けいさんき を たたいています...',
      'ぽけっと を さがしています...',
      'けいりのひと を よんでいます...',
    ],

    // データ取得時のメッセージ
    dataFetch: [
      'いろいろなもの を ひっくりかえしています...',
      'さがしもの を さがしています...',
      'たいせつなこと を おもいだしています...',
      'むこうのほう を のぞいています...',
      'じょうほう を つかまえています...',
      'しょるい を ひっくりかえしています...',
    ],

    // デフォルトのメッセージ
    default: [
      'せんせい を さがしています...',
      'しょるい を せいり しています...',
      'しょるい を ながめています...',
      'しょるい の けいしき を かくにん しています...',
      'しょるい を ぶんるい しています...',
      'きくず を かたずけています...',
      'ことば を えらんでいます...',
      'ていさい を ととのえています...',
      'みぎ の もの を ひだり に うごかしています...',
      'ひだり の もの を みぎ に うごかしています...',
      'こーひー を いれています...',
      'すこし きゅうけい しています...',
      'ねこ の て を かりようとしています...',
      'はむすたー の て を かりようとしています...',
      'ぞう の はな を かりようとしています...',
      'めだか を ながめています...',
      'めだか を かぞえています...',
      'はもの を ととのえています...',
      'てん と てん を むすんでいます...',
      'あたま を かくにん しています...',
      'せんせい は しゅうちゅう しています...',
      'せんせい は いま むかっています...',
      'あぷり を かいりょう しています...',
      'ぜんたい と ぶぶん を かんがえています...',
      'やらないといけないこと を ながめています...',
      'あたらしい こと を かんがえています...',
      'できあがり を おもいえがいています...',
      'つくえ の うえ で しごとらしきこと を しています...',
      'まるい もの を しかくく しようとしています...',
      'しかくい もの を まるく しようとしています...',
      'しかくい もの を よりしかくく しようとしています...',
      'おもしろい かたち を かんがえています...',
      'じかん が ゆっくり すぎています...',
      'じかん が あっというまに すぎています...',
      'いい かたち を さがしています...',
      'それらしい ことば を さがしています...',
      'なにをしようとしていたのか を おもいだしています...',
      'かたち を ながめています...',
    ],
  };

  const getRandomMessage = (category = 'default') => {
    const loadingMessages = /** @type {Record<string, string[]>} */ (
      LoadingMessages
    );
    const messages = [
      ...(loadingMessages[category] || []),
      ...LoadingMessages.default,
    ];
    return messages[Math.floor(Math.random() * messages.length)];
  };

  const updateLoadingMessage = (category = 'default') => {
    /** @type {HTMLElement | null} */
    const messageElement = document.getElementById('loading-message');
    if (messageElement) {
      messageElement.textContent = getRandomMessage(category);
    }
  };

  const startLoadingMessageRotation = (category = 'default') => {
    // 初期メッセージを設定
    updateLoadingMessage(category);

    // 3秒ごとにメッセージを更新
    loadingMessageTimer = setInterval(
      () => {
        updateLoadingMessage(category);
      },
      /** @type {number} */ (CONSTANTS.UI?.LOADING_MESSAGE_INTERVAL) || 3000,
    );
  };

  const stopLoadingMessageRotation = () => {
    if (loadingMessageTimer) {
      clearInterval(loadingMessageTimer);
      loadingMessageTimer = null;
    }
  };

  window.showLoading =
    window.showLoading ||
    function (/** @type {string} */ category = 'default') {
      /** @type {HTMLElement | null} */
      const loadingElement = document.getElementById('loading');
      if (!loadingElement) return;

      // hiddenクラスを削除し、activeクラスを即座に追加して表示する
      loadingElement.classList.remove('hidden');
      loadingElement.classList.add('active');

      startLoadingMessageRotation(category);
    };

  window.hideLoading =
    window.hideLoading ||
    function () {
      /** @type {HTMLElement | null} */
      const loadingElement = document.getElementById('loading');
      if (!loadingElement) return;

      loadingElement.classList.remove('active');

      // フェードアウト完了後に完全に非表示
      setTimeout(() => {
        loadingElement.classList.add('hidden');
        stopLoadingMessageRotation();
      }, 300); // CSS transitionと同じ時間
    };

  // =================================================================
  // --- Error Handling (moved to 12_WebApp_Core_ErrorHandler.js) ---
  // -----------------------------------------------------------------
  // エラーハンドリング機能は専用ファイルに分割されました：
  //
  // 📁 12_WebApp_Core_ErrorHandler.js - フロントエンド統一エラーハンドリング
  //   - FrontendErrorHandler クラス
  //   - handleServerError() 互換関数
  //   - グローバルエラーハンドラー設定
  //   - 開発/本番環境対応
  //
  // バックエンドエラーハンドリングは src/backend/08_ErrorHandler.js で管理
  // =================================================================

  // =================================================================
  // --- Modal System ---
  // -----------------------------------------------------------------
  // モーダル表示とインタラクション管理
  // =================================================================

  /**
   * モーダル表示
   * @param {ModalDialogConfig} c - モーダル設定
   */
  window.showModal =
    window.showModal ||
    /** @type {(c: ModalDialogConfig) => void} */ (
      c => {
        // モーダル表示時にスクロール位置を保存
        if (
          window.pageTransitionManager &&
          /** @type {any} */ (window.pageTransitionManager).onModalOpen
        ) {
          /** @type {any} */ (window.pageTransitionManager).onModalOpen();
        }

        /** @type {HTMLElement | null} */
        const m = document.getElementById('custom-modal');
        /** @type {HTMLElement | null} */
        const b = document.getElementById('modal-buttons');
        if (!m || !b) return;
        b.innerHTML = '';
        if (c.showCancel) {
          b.innerHTML += Components.button({
            text: c.cancelText || CONSTANTS.MESSAGES.CANCEL || 'キャンセル',
            action: 'modalCancel',
            style: 'secondary',
            size: 'normal',
          });
        }
        if (c.confirmText) {
          b.innerHTML += `<div class="w-3"></div>${Components.button({
            text: c.confirmText,
            action: 'modalConfirm',
            style: c.confirmColorClass?.includes('danger') ? 'danger' : 'primary',
            size: 'normal',
            disabled: /** @type {any} */ (c).disableConfirm,
          })}`;
        }
        ModalManager.setCallback(c.onConfirm);
        /** @type {HTMLElement | null} */
        const modalTitle = document.getElementById('modal-title');
        /** @type {HTMLElement | null} */
        const modalMessage = document.getElementById('modal-message');

        if (modalTitle) modalTitle.textContent = c.title;
        if (modalMessage) modalMessage.innerHTML = c.message;
        m.classList.add('active');
      }
    );

  const hideModal = () => {
    /** @type {HTMLElement | null} */
    const modal = document.getElementById('custom-modal');
    if (modal) modal.classList.remove('active');
    ModalManager.clearCallback();

    // モーダル非表示時にスクロール位置を復元
    if (
      window.pageTransitionManager &&
      /** @type {any} */ (window.pageTransitionManager).onModalClose
    ) {
      /** @type {any} */ (window.pageTransitionManager).onModalClose();
    }
  };

  /**
   * 情報モーダル表示
   * @param {string} msg - メッセージ
   * @param {string} t - タイトル
   * @param {VoidCallback|null} cb - コールバック
   */
  window.showInfo =
    window.showInfo ||
    /** @type {(msg: string, t?: string, cb?: VoidCallback | null) => void} */ (
      (msg, t = '情報', cb = null) =>
        window.showModal({
          title: t,
          message: msg,
          confirmText: 'OK',
          confirmColorClass: DesignConfig.colors['primary'],
          onConfirm: cb,
        })
    );

  /**
   * 確認モーダル表示
   * @param {ModalDialogConfig} c - モーダル設定
   */
  window.showConfirm =
    window.showConfirm ||
    /** @type {(c: ModalDialogConfig) => void} */ (
      c => window.showModal({ ...c, showCancel: true })
    );

  // =================================================================
  // --- Event Listener Management ---
  // -----------------------------------------------------------------
  // イベントリスナーの登録・解除を追跡管理するヘルパー関数群
  // メモリリーク防止のため、ビュー切り替え時に古いリスナーを確実に解除する
  // =================================================================

  /** @type {Array<{element: Element, type: string, listener: EventListener, options?: AddEventListenerOptions}>} */
  let activeListeners = [];

  /**
   * 登録されたイベントリスナーを全て解除する
   */
  function teardownAllListeners() {
    activeListeners.forEach(({ element, type, listener, options }) => {
      if (element) {
        element.removeEventListener(type, listener, options);
      }
    });
    activeListeners = [];
  }

  /**
   * イベントリスナーを登録し、解除できるように追跡するヘルパー関数
   * @param {Element} element - 対象要素
   * @param {string} type - イベントタイプ
   * @param {EventListener} listener - リスナー関数
   * @param {AddEventListenerOptions} [options] - addEventListenerのオプション
   */
  function addTrackedListener(element, type, listener, options) {
    if (!element) {
      console.warn(
        `Attempted to add listener to a null element for event: ${type}`,
      );
      return;
    }
    element.addEventListener(type, listener, options);
    activeListeners.push({ element, type, listener, options });
  }

  /**
   * StateManagerの初期化後に追加する関数
   * ビュー変更時のイベントリスナー管理を設定
   */
  function setupViewListener() {
    if (!window.stateManager) {
      console.error('StateManager not initialized. Cannot set up view listener.');
      return;
    }

    window.stateManager.subscribe(
      (/** @type {UIState} */ newState, /** @type {UIState} */ oldState) => {
        // ビューが変更された場合のみ処理
        if (newState.view !== oldState.view) {
          // 古いビューのリスナーを全て解除
          teardownAllListeners();

          // 新しいビューに応じたリスナーを登録
          // requestAnimationFrameでDOMの描画を待つ
          requestAnimationFrame(() => {
            if (newState.view === 'accounting') {
              // 会計画面が表示された際の初期化処理
              // イベントリスナーは14_WebApp_Handlers.htmlのイベント委譲で処理されます。
              // ここでは、DOM描画後に初回計算を実行します。
              if (typeof updateAccountingCalculation === 'function') {
                // 会計画面用のデータを取得
                const classifiedItems =
                  window.currentClassifiedItems ||
                  /** @type {ClassifiedAccountingItems} */ ({
                    tuition: { baseItems: [], additionalItems: [] },
                    sales: { materialItems: [], productItems: [] },
                  });
                const classroom = window.currentClassroom || '';
                updateAccountingCalculation(classifiedItems, classroom);
              }
            }
            // 他のビューでリスナーが必要な場合はここに追加
            // else if (newState.view === 'someOtherView') {
            //   setupSomeOtherViewListeners();
            // }
          });
        }
      },
    );
  }


  // =================================================================
  // 12_WebApp_Core_Accounting.js (自動統合)
  // =================================================================

  /**
   * 会計システム統合ファイル
   * 3ファイル（Core_Accounting, Views_Accounting, Handlers_Accounting）を1ファイルに統合
   *
   * アーキテクチャ：
   * - 計算ロジック層：会計計算の核心処理
   * - UI生成層：画面要素の生成
   * - イベント処理層：ユーザー操作の処理
   * - ユーティリティ層：共通処理
   */

  // @ts-nocheck

  /**
   * @typedef {Object} ClassifiedAccountingItems
   * @property {Object} tuition
   * @property {Array} tuition.baseItems
   * @property {Array} tuition.additionalItems
   * @property {Object} sales
   * @property {Array} sales.materialItems
   * @property {Array} sales.productItems
   */

  // ================================================================================
  // 【ユーティリティ層】
  // ================================================================================

  /**
   * 会計処理関連のローカルキャッシュをクリア
   */
  function clearAccountingCache() {
    // 一時的な支払いデータをクリア
    if (typeof window !== 'undefined' && window.tempPaymentData) {
      window.tempPaymentData = null;
    }

    // その他の会計関連の一時データがあればここでクリア
    console.log('会計キャッシュクリア完了');
  }

  // ================================================================================
  // 【計算ロジック層】
  // ================================================================================

  /**
   * 会計マスタデータを項目種別に分類
   * @param {Array} masterData - 会計マスタデータ
   * @param {string} classroom - 教室名
   * @returns {ClassifiedAccountingItems} 分類済み会計項目
   */
  function classifyAccountingItems(masterData, classroom) {
    const result = {
      tuition: { baseItems: [], additionalItems: [] },
      sales: { materialItems: [], productItems: [] },
    };

    masterData.forEach(item => {
      const type = item[CONSTANTS.HEADERS.ACCOUNTING.TYPE];
      const price = Number(item[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE]);
      const targetClassroom = item[CONSTANTS.HEADERS.ACCOUNTING.TARGET_CLASSROOM];

      // 教室対象チェック
      if (targetClassroom !== '共通' && !targetClassroom.includes(classroom))
        return;

      if (type === '授業料') {
        if (item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME].includes('授業料')) {
          result.tuition.baseItems.push(item);
        } else {
          result.tuition.additionalItems.push(item);
        }
      } else if (type === '割引') {
        // 割引項目はadditionalItemsに統合
        result.tuition.additionalItems.push(item);
      } else if (type === '材料') {
        result.sales.materialItems.push(item);
      } else if (type === '物販') {
        result.sales.productItems.push(item);
      }
    });

    return result;
  }

  /**
   * 時間単位の計算（30分刻み）
   * @param {string} startTime - 開始時刻 (HH:MM形式)
   * @param {string} endTime - 終了時刻 (HH:MM形式)
   * @param {number} breakTime - 休憩時間（分）
   * @returns {number} 30分単位の数
   */
  function calculateTimeUnits(startTime, endTime, breakTime = 0) {
    if (!startTime || !endTime) return 0;

    const [startHour, startMin] = startTime.split(':').map(Number);
    const [endHour, endMin] = endTime.split(':').map(Number);

    const startMinutes = startHour * 60 + startMin;
    const endMinutes = endHour * 60 + endMin;
    const totalMinutes = endMinutes - startMinutes - breakTime;

    return Math.max(0, totalMinutes / 30);
  }

  /**
   * 授業料小計計算
   * @param {AccountingFormData} formData - フォームデータ
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @param {string} classroom - 教室名
   * @returns {Object} 授業料計算結果
   */
  function calculateTuitionSubtotal(formData, classifiedItems, classroom) {
    let subtotal = 0;
    const items = [];

    // 基本授業料計算（時間制 vs 回数制）
    const baseItem = classifiedItems.tuition.baseItems.find(item => {
      const targetClassroom = item[CONSTANTS.HEADERS.ACCOUNTING.TARGET_CLASSROOM];
      return targetClassroom === classroom || targetClassroom.includes(classroom);
    });

    if (baseItem) {
      const unit = baseItem[CONSTANTS.HEADERS.ACCOUNTING.UNIT];
      const unitPrice = Number(baseItem[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE]);

      if (unit === '30分') {
        // 時間制計算 - 時刻が入力されている場合のみ
        if (formData.startTime && formData.endTime) {
          const timeUnits = calculateTimeUnits(
            formData.startTime,
            formData.endTime,
            formData.breakTime,
          );
          if (timeUnits > 0) {
            const price = timeUnits * unitPrice;
            items.push({
              name: `授業料 (${formData.startTime} - ${formData.endTime})`,
              price: price,
            });
            subtotal += price;
          }
        }
      } else if (unit === '回') {
        // 回数制計算 - 基本授業料がチェックされている場合のみ
        const baseItemName = baseItem[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME];
        if (
          formData.checkedItems?.[baseItemName] ||
          formData.checkedItems?.['基本授業料']
        ) {
          items.push({
            name: baseItemName,
            price: unitPrice,
          });
          subtotal += unitPrice;
        }
      }
    }

    // 追加項目（チェックボックス選択）- 正負の値段両方含む
    classifiedItems.tuition.additionalItems.forEach(item => {
      const itemName = item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME];
      if (formData.checkedItems?.[itemName]) {
        const price = Number(item[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE]);
        items.push({ name: itemName, price: price });
        subtotal += price;
      }
    });

    return { items, subtotal };
  }

  /**
   * 販売小計計算
   * @param {AccountingFormData} formData - フォームデータ
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @returns {Object} 販売計算結果
   */
  function calculateSalesSubtotal(formData, classifiedItems) {
    let subtotal = 0;
    const items = [];

    // 材料費計算
    if (formData.materials) {
      formData.materials.forEach(material => {
        const masterItem = classifiedItems.sales.materialItems.find(
          item => item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME] === material.type,
        );

        if (masterItem) {
          const unit = masterItem[CONSTANTS.HEADERS.ACCOUNTING.UNIT];
          const unitPrice = Number(
            masterItem[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE],
          );

          let price = 0;
          let itemName = material.type;

          if (unit === 'cm³') {
            // 体積計算（mm → cm変換）
            const volume =
              (material.l / 10) * (material.w / 10) * (material.h / 10);
            price = Math.round((volume * unitPrice) / 100) * 100; // ¥100単位
            price = Math.max(100, price); // 最低¥100
            itemName = `${material.type} (${material.l}×${material.w}×${material.h}mm)`;
          } else {
            // 固定価格
            price = unitPrice;
          }

          items.push({ name: itemName, price: price });
          subtotal += price;
        }
      });
    }

    // 物販（プルダウン選択式）
    if (formData.selectedProducts) {
      formData.selectedProducts.forEach(product => {
        items.push({ name: product.name, price: product.price });
        subtotal += product.price;
      });
    }

    // 自由入力物販
    if (formData.customSales) {
      formData.customSales.forEach(customItem => {
        if (customItem.name && customItem.price) {
          const price = Number(customItem.price);
          items.push({ name: customItem.name, price: price });
          subtotal += price;
        }
      });
    }

    return { items, subtotal };
  }

  /**
   * 統合計算
   * @param {AccountingFormData} formData - フォームデータ
   * @param {Array} masterData - 会計マスタデータ
   * @param {string} classroom - 教室名
   * @returns {Object} 統合計算結果
   */
  function calculateAccountingTotal(formData, masterData, classroom) {
    // デバッグ: 計算開始
    if (!window.isProduction) {
      console.log('🔍 calculateAccountingTotal開始:', {
        formData,
        masterDataLength: masterData.length,
        classroom,
      });
    }

    try {
      const classifiedItems = classifyAccountingItems(masterData, classroom);
      const tuition = calculateTuitionSubtotal(
        formData,
        classifiedItems,
        classroom,
      );
      const sales = calculateSalesSubtotal(formData, classifiedItems);

      const result = {
        tuition,
        sales,
        grandTotal: tuition.subtotal + sales.subtotal,
        paymentMethod: formData.paymentMethod || CONSTANTS.PAYMENT_DISPLAY.CASH,
      };

      // デバッグ: 計算結果
      if (!window.isProduction) {
        console.log('🔍 calculateAccountingTotal結果:', result);
        console.log('🔍 授業料小計:', tuition.subtotal);
        console.log('🔍 販売小計:', sales.subtotal);
        console.log('🔍 総合計:', result.grandTotal);
      }

      return result;
    } catch (error) {
      console.error('🔍 calculateAccountingTotal エラー:', error);
      // エラー時は空の結果を返す
      return {
        tuition: { items: [], subtotal: 0 },
        sales: { items: [], subtotal: 0 },
        grandTotal: 0,
        paymentMethod: formData.paymentMethod || CONSTANTS.PAYMENT_DISPLAY.CASH,
      };
    }
  }

  // ================================================================================
  // 【UI生成層】（Components.js活用）
  // ================================================================================

  /**
   * 時刻選択オプション生成
   * @param {string} selectedValue - 選択済みの値
   * @returns {string} HTML文字列
   */
  function generateTimeOptions(selectedValue = '') {
    return Components.timeOptions({
      startTime: '09:00',
      endTime: '19:00',
      interval: 30,
      selectedValue: selectedValue,
    });
  }

  /**
   * 授業料セクション生成（Components.js活用）
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @param {string} classroom - 教室名
   * @param {AccountingFormData} formData - フォームデータ
   * @returns {string} HTML文字列
   */
  function generateTuitionSection(classifiedItems, classroom, formData = {}) {
    // 基本授業料項目を取得
    const baseItem = classifiedItems.tuition.baseItems.find(item => {
      const targetClassroom = item[CONSTANTS.HEADERS.ACCOUNTING.TARGET_CLASSROOM];
      return targetClassroom === classroom || targetClassroom.includes(classroom);
    });

    if (!baseItem) {
      return `<section class="tuition-section">
        ${Components.sectionHeader({ title: '授業料' })}
        <p class="text-gray-500">この教室の授業料設定が見つかりません。</p>
      </section>`;
    }

    const unit = baseItem[CONSTANTS.HEADERS.ACCOUNTING.UNIT];
    const unitPrice = Number(baseItem[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE]);
    const isTimeBased = unit === '30分';

    // 基本授業料UI
    let baseTuitionHtml = '';
    if (isTimeBased) {
      // 時間制の場合
      baseTuitionHtml = `
        <div class="base-tuition mb-4">
          ${Components.checkbox({
            id: 'base-tuition',
            label: '授業料',
            checked: true,
          })}
          <div class="time-controls mt-3 ml-2">
            <div class="flex items-center space-x-2 mb-3">
              <select id="start-time" class="time-select time-display flex-1 p-2 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text">
                ${generateTimeOptions(formData.startTime)}
              </select>
              <span class="text-sm text-brand-text">-</span>
              <select id="end-time" class="time-select time-display flex-1 p-2 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text">
                ${generateTimeOptions(formData.endTime)}
              </select>
              <span class="text-sm text-brand-text ml-2">休憩</span>
              <select id="break-time" class="time-select time-display w-14 p-2 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text">
                <option value="0" ${formData.breakTime === 0 ? 'selected' : ''}>0分</option>
                <option value="30" ${formData.breakTime === 30 ? 'selected' : ''}>30分</option>
                <option value="60" ${formData.breakTime === 60 ? 'selected' : ''}>60分</option>
                <option value="90" ${formData.breakTime === 90 ? 'selected' : ''}>90分</option>
              </select>
            </div>
            <div class="calculated-amount text-sm text-gray-600">
              <span id="time-calculation" class="font-mono-numbers">0時間 ×${Components.priceDisplay({ amount: unitPrice * 2 })} = <span class="font-bold text-brand-text text-right">${Components.priceDisplay({ amount: 0 })}</span></span>
            </div>
          </div>
        </div>`;
    } else {
      // 回数制の場合
      baseTuitionHtml = `
        <div class="base-tuition  border-ui-border p-0 mb-2" data-checkbox-row>
          <div class="flex items-center space-x-3">
            <div class="flex-1">
              ${Components.checkbox({
                id: 'base-tuition',
                label: '授業料',
                checked: true,
                dynamicStyle: true,
              })}
            </div>
            <div class="price-display">
              <span class="text-right">
                <span class="price-amount font-bold text-brand-text">¥${unitPrice.toLocaleString()}</span>
              </span>
            </div>
          </div>
        </div>`;
    }

    // 追加項目UI生成（正負の値段両方含む）
    let additionalItemsHtml = '';
    if (classifiedItems.tuition.additionalItems.length > 0) {
      additionalItemsHtml = '<div class="additional-tuition mb-4 space-y-1">';
      classifiedItems.tuition.additionalItems.forEach(item => {
        const itemName = item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME];
        const price = Number(item[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE]);
        const isChecked = formData.checkedItems?.[itemName] || false;

        additionalItemsHtml += `
          <div class=" border-ui-border p-0" data-checkbox-row>
            <div class="flex items-center space-x-3">
              <div class="flex-1">
                ${Components.checkbox({
                  id: `additional-${itemName.replace(/\s+/g, '-')}`,
                  label: itemName,
                  checked: isChecked,
                  dynamicStyle: true,
                  dataAttributes: {
                    'item-name': itemName,
                  },
                })}
              </div>
              <div class="price-display">
                <span class="text-right">
                  <span class="price-amount ${isChecked ? 'font-bold text-brand-text' : 'text-brand-muted'} ${price < 0 ? 'text-red-600' : ''}">¥${price.toLocaleString()}</span>
                </span>
              </div>
            </div>
          </div>`;
      });
      additionalItemsHtml += '</div>';
    }

    return Components.cardContainer({
      variant: 'default',
      padding: 'spacious',

      content: `
        <section class="tuition-section">
          ${Components.sectionHeader({ title: '授業料' })}
          ${baseTuitionHtml}
          ${additionalItemsHtml}
          ${Components.subtotalSection({
            title: '授業料小計',
            amount: 0,
            id: 'tuition-subtotal-amount',
          })}
        </section>
      `,
    });
  }

  /**
   * 材料行生成（Components.js活用）
   * @param {Array} materialItems - 材料項目配列
   * @param {number} index - 行インデックス
   * @param {Object} materialData - 既存の材料データ
   * @returns {string} HTML文字列
   */
  function generateMaterialRow(materialItems, index = 0, materialData = {}) {
    // 材料選択肢を生成
    let materialOptions = '<option value="">おえらびください</option>';
    materialItems.forEach(item => {
      const itemName = item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME];
      const selected = materialData.type === itemName ? 'selected' : '';
      materialOptions += `<option value="${escapeHTML(itemName)}" ${selected}>${escapeHTML(itemName)}</option>`;
    });

    // 体積計算材料の場合のサイズ入力
    const showSizeInputs =
      materialData.type &&
      materialItems.find(
        item =>
          item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME] === materialData.type &&
          item[CONSTANTS.HEADERS.ACCOUNTING.UNIT] === 'cm³',
      );

    const sizeInputsHtml = showSizeInputs
      ? `
      <div class="size-inputs flex items-center space-x-0 mb-2 pl-7">
        <input
          type="number"
          id="material-length-${index}"
          value="${materialData.l || ''}"
          placeholder="x"
          class="w-12 p-0.5 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text text-right"
        >
        <span class="text-sm">×</span>
        <input
          type="number"
          id="material-width-${index}"
          value="${materialData.w || ''}"
          placeholder="y"
          class="w-12 p-0.5 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text text-right"
        >
        <span class="text-sm">×</span>
        <input
          type="number"
          id="material-height-${index}"
          value="${materialData.h || ''}"
          placeholder="z"
          class="w-12 p-0.5 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text text-right"
        >
        <span class="text-sm text-gray-600">mm</span>
      </div>`
      : '';

    return `
      <div class="material-row  border-ui-border p-0 ${index > 0 ? 'mt-2' : ''}" data-material-row="${index}">
        <div class="flex items-center space-x-3">
          <div class="flex-shrink-0 w-2 text-center">
            <span class="text-brand-text">•</span>
          </div>
          <div class="flex-1">
            <select id="material-type-${index}" class="material-select w-full p-0.5 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text">
              ${materialOptions}
            </select>
          </div>
          <div class="price-display">
            <span id="material-price-${index}" class="font-bold">${Components.priceDisplay({ amount: 0 })}</span>
          </div>
        </div>
        ${sizeInputsHtml}
      </div>`;
  }

  /**
   * 販売セクション生成（Components.js活用）
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @param {AccountingFormData} formData - フォームデータ
   * @returns {string} HTML文字列
   */
  function generateSalesSection(classifiedItems, formData = {}) {
    // 材料代セクション
    let materialsHtml = '';
    if (classifiedItems.sales.materialItems.length > 0) {
      materialsHtml = `
        <div class="materials mb-6">
          <h4 class="font-medium text-brand-text mb-3">材料</h4>
          <div id="materials-container">
            ${generateMaterialRow(classifiedItems.sales.materialItems, 0, formData.materials?.[0] || {})}
          </div>
        </div>`;
    }

    // 物販セクション（プルダウン選択式 + 自由入力）
    let productsHtml = '';
    if (classifiedItems.sales.productItems.length > 0) {
      // 自由入力物販の初期行を生成
      const customSalesRows = generateCustomSalesRows(
        formData.customSales || [{}],
      );

      productsHtml = `
        <div class="products mb-6">
          <h4 class="font-medium text-brand-text mb-3">物販</h4>
          <div id="products-container">
            ${generateProductRow(classifiedItems.sales.productItems, 0, formData.selectedProducts?.[0] || {})}
          </div>
          <div class="custom-sales-divider mb-2">
          </div>
          <div id="custom-sales-container">
            ${customSalesRows}
          </div>
        </div>`;
    }

    return Components.cardContainer({
      variant: 'default',
      padding: 'spacious',
      content: `
        <section class="sales-section">
          <details>
            ${Components.sectionHeader({ title: '販売', asSummary: true })}
            <div class="mt-3">
              ${materialsHtml}
              ${productsHtml}
            </div>
          </details>
          ${Components.subtotalSection({
            title: '販売小計',
            amount: 0,
            id: 'sales-subtotal-amount',
          })}
        </section>
      `,
    });
  }

  /**
   * 物販行生成（Components.js活用）
   * @param {Array} productItems - 物販項目配列
   * @param {number} index - 行インデックス
   * @param {Object} productData - 既存の物販データ
   * @returns {string} HTML文字列
   */
  function generateProductRow(productItems, index = 0, productData = {}) {
    // 物販選択肢を生成
    let productOptions = '<option value="">おえらびください</option>';
    productItems.forEach(item => {
      const itemName = item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME];
      const price = Number(item[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE]);
      const selected = productData.name === itemName ? 'selected' : '';
      productOptions += `<option value="${escapeHTML(itemName)}" data-price="${price}" ${selected}>${escapeHTML(itemName)} ${Components.priceDisplay({ amount: price })}</option>`;
    });

    return `
      <div class="product-row  border-ui-border p-0 ${index > 0 ? 'mt-2' : ''}" data-product-row="${index}">
        <div class="flex items-center space-x-3">
          <div class="flex-shrink-0 w-2 text-center">
            <span class="text-brand-text">•</span>
          </div>
          <div class="flex-1">
            <select id="product-type-${index}" class="product-select w-full p-0.5 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text">
              ${productOptions}
            </select>
          </div>
          <div class="price-display">
            <span id="product-price-${index}" class="font-bold">${Components.priceDisplay({ amount: productData.price || 0 })}</span>
          </div>
        </div>
      </div>`;
  }

  /**
   * 自由入力物販行群生成
   * @param {Array} customSalesData - 自由入力物販データ配列
   * @returns {string} HTML文字列
   */
  function generateCustomSalesRows(customSalesData = [{}]) {
    return customSalesData
      .map((itemData, index) => generateCustomSalesRow(index, itemData))
      .join('');
  }

  /**
   * 自由入力物販行生成（物販行と同じデザイン）
   * @param {number} index - 行インデックス
   * @param {Object} itemData - 既存のアイテムデータ
   * @returns {string} HTML文字列
   */
  function generateCustomSalesRow(index = 0, itemData = {}) {
    return `
      <div class="custom-sales-row  border-ui-border p-0 ${index > 0 ? 'mt-1' : ''}" data-custom-sales-row="${index}">
        <div class="flex items-center space-x-3">
          <div class="flex-shrink-0 w-2 text-center">
            <span class="text-brand-text">•</span>
          </div>
          <div class="flex-1">
            <input
              type="text"
              id="custom-sales-name-${index}"
              value="${itemData.name || ''}"
              placeholder="自由入力"
              class="w-full p-0.5 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text"
            >
          </div>
          <div class="w-20">
            <input
              type="number"
              id="custom-sales-price-${index}"
              value="${itemData.price || ''}"
              placeholder="金額"
              class="w-full p-0.5 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text text-right"
            >
          </div>
          <div class="price-display">
            <span id="custom-sales-display-${index}" class="font-bold">${Components.priceDisplay({ amount: itemData.price || 0 })}</span>
          </div>
        </div>
      </div>`;
  }

  /**
   * 会計画面用よやくカード生成（ボタン非表示、制作メモ編集モード）
   * @param {Object} reservationData - 予約データ
   * @returns {string} HTML文字列
   */
  function generateAccountingReservationCard(reservationData) {
    if (!reservationData) {
      return '';
    }

    // 予約カードを生成（ボタンなし、制作メモ編集モード、メモ保存ボタン非表示）
    return Components.listCard({
      item: {
        reservationId: reservationData.reservationId || '',
        date: reservationData.date || '',
        startTime: reservationData.startTime || '',
        endTime: reservationData.endTime || '',
        classroom: reservationData.classroom || '',
        venue: reservationData.venue || '',
        workInProgress: reservationData.workInProgress || '',
      },
      badges: [], // ステータスバッジは表示しない
      editButtons: [], // 編集ボタンは表示しない
      accountingButtons: [], // 会計ボタンは表示しない
      type: 'booking', // 予約カードタイプ
      isEditMode: true, // 制作メモを編集モードに設定
      showMemoSaveButton: false, // 制作メモ保存ボタンは非表示
    });
  }

  /**
   * メイン会計画面生成（Components.js活用）
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @param {string} classroom - 教室名
   * @param {AccountingFormData} formData - フォームデータ
   * @param {Object} reservationData - 予約データ（講座基本情報表示用）
   * @returns {string} HTML文字列
   */
  function generateAccountingView(
    classifiedItems,
    classroom,
    formData = {},
    reservationData = null,
  ) {
    return `
      ${Components.pageHeader({ title: '会計' })}
      <div class="accounting-container max-w-4xl mx-auto p-2 space-y-6">
        <!-- よやくカード（ボタン非表示、制作メモ編集モード） -->
        ${generateAccountingReservationCard(reservationData)}

        <!-- 授業料セクション -->
        ${generateTuitionSection(classifiedItems, classroom, formData)}

        <!-- 販売セクション（物販+自由入力物販統合） -->
        ${generateSalesSection(classifiedItems, formData)}

        <!-- 合計セクション -->
        ${Components.cardContainer({
          variant: 'default',
          padding: 'spacious',
          content: `
            <section class="total-section">
              <div class="grand-total text-center">
                <span class="text-2xl font-bold text-brand-text">総合計: </span>
                <span id="grand-total-amount" class="text-2xl font-bold text-brand-text">${Components.priceDisplay({ amount: 0, size: 'large' })}</span>
              </div>
            </section>
          `,
        })}

        <!-- 支払い方法セクション -->
        ${Components.cardContainer({
          variant: 'default',
          padding: 'spacious',
          content: `
            <section class="payment-section">
              ${Components.sectionHeader({ title: '支払方法' })}
              <div id="payment-options-container">
                <!-- getPaymentOptionsHtml()で生成される -->
              </div>
            </section>
          `,
        })}

        <!-- 確認ボタン -->
        ${Components.cardContainer({
          variant: 'default',
          padding: 'spacious',
          content: `
            <div class="space-y-3">
              ${Components.button({
                action: 'showPaymentModal',
                text: '先生が確認しました',
                style: 'primary',
                size: 'large',
                customClass:
                  'w-full transition-all duration-200 hover:shadow-md opacity-60 cursor-not-allowed',
                disabled: true,
                id: 'confirm-payment-button',
                disabledStyle: 'none', // カスタムスタイルで制御
              })}
              ${Components.button({
                action: 'smartGoBack',
                text: 'もどる',
                style: 'secondary',
                size: 'large',
                customClass: 'w-full',
              })}
            </div>
          `,
        })}
      </div>`;
  }

  /**
   * 支払い方法の選択肢（ラジオボタン）UIを生成します。
   * @param {string} selectedValue - 選択済みの支払い方法
   * @returns {string} HTML文字列
   */
  const getPaymentOptionsHtml = selectedValue => {
    const cotraDetails = `
          <details class="mt-0 ml-4">
              <summary class="inline-block px-0 py-0 bg-ui-warning-light text-ui-warning-text text-sm font-semibold rounded-md active:bg-ui-warning-bg">
              <span class="arrow">▶</span> ことら送金とは？
              </summary>
              <p class="mt-2 p-2 bg-ui-warning-bg rounded-md text-sm text-left text-brand-subtle">
                  電話番号だけで銀行口座間で送金できるサービスです。手数料無料。対応の銀行アプリから利用できます。<br>
                  (例：ゆうちょ通帳アプリ、三井住友銀行アプリ、住信SBIネット銀行アプリなど)
                  <a href="https://www.cotra.ne.jp/member/" target="_blank" class="text-ui-link-text">対応アプリ一覧</a>
              </p>
          </details>`;
    const options = [
      {
        value: CONSTANTS.PAYMENT_DISPLAY.CASH,
        text: CONSTANTS.PAYMENT_DISPLAY.CASH,
        details: '',
      },
      {
        value: CONSTANTS.PAYMENT_DISPLAY.BANK_TRANSFER,
        text: CONSTANTS.PAYMENT_DISPLAY.BANK_TRANSFER,
        details: '',
      },
      {
        value: CONSTANTS.PAYMENT_DISPLAY.COTRA,
        text: CONSTANTS.PAYMENT_DISPLAY.COTRA,
        details: cotraDetails,
      },
    ];
    return options
      .map(
        opt => `
          <div class="mb-2">
              <label class="flex items-center space-x-2 ${selectedValue === opt.value ? 'font-bold text-brand-text' : 'text-brand-muted'} cursor-pointer transition-all duration-150">
                  <input type="radio" name="payment-method" value="${opt.value}" class="accent-action-primary-bg" ${selectedValue === opt.value ? 'checked' : ''}>
                  <span>${opt.text}</span>
              </label>
              ${opt.details}
          </div>`,
      )
      .join('');
  };

  /**
   * 選択された支払方法に応じた支払い情報を動的に表示するUIを生成します。
   * @param {string} selectedPaymentMethod - 選択された支払方法
   * @returns {string} HTML文字列
   */
  const getPaymentInfoHtml = (selectedPaymentMethod = '') => {
    let paymentInfoHtml = '';

    // ことら送金が選択された場合のみ電話番号を表示
    if (selectedPaymentMethod === CONSTANTS.PAYMENT_DISPLAY.COTRA) {
      paymentInfoHtml += `
          <div class="bg-ui-surface border-2 border-ui-border p-3 rounded-md">
              <div class="flex justify-between items-center">
                  <div class="${DesignConfig.text['body']}"><span class="font-bold">送金先 電話番号:</span><span class="ml-2 font-mono">${CONSTANTS.BANK_INFO.COTRA_PHONE}</span></div>
                  <button data-action="copyToClipboard" data-copy-text="${CONSTANTS.BANK_INFO.COTRA_PHONE}" class="flex-shrink-0 text-sm bg-action-secondary-bg active:bg-action-secondary-hover text-action-secondary-text font-bold px-2 py-1 rounded mobile-button">コピー</button>
              </div>
          </div>`;
    }

    // 振込が選択された場合のみ口座情報を表示
    if (selectedPaymentMethod === CONSTANTS.PAYMENT_DISPLAY.BANK_TRANSFER) {
      paymentInfoHtml += `
          <div class="bg-ui-surface border-2 border-ui-border p-3 rounded-md">
              <div class="text-brand-text"><span class="font-bold">振込先:</span><span class="ml-2">${CONSTANTS.BANK_INFO.NAME}</span></div>
              <div class="mt-1 flex justify-between items-center">
                  <div class="text-base text-brand-text">店番: ${CONSTANTS.BANK_INFO.BRANCH}</div>
                  <button data-action="copyToClipboard" data-copy-text="${CONSTANTS.BANK_INFO.BRANCH}" class="text-sm bg-action-secondary-bg active:bg-action-secondary-hover text-action-secondary-text font-bold px-2 py-1 rounded mobile-button">コピー</button>
              </div>
              <div class="mt-1 flex justify-between items-center">
                  <div class="text-base text-brand-text">普通: ${CONSTANTS.BANK_INFO.ACCOUNT}</div>
                  <button data-action="copyToClipboard" data-copy-text="${CONSTANTS.BANK_INFO.ACCOUNT}" class="text-sm bg-action-secondary-bg active:bg-action-secondary-hover text-action-secondary-text font-bold px-2 py-1 rounded mobile-button">コピー</button>
              </div>
          </div>`;
    }

    // 現金の場合は何も表示しない
    return paymentInfoHtml;
  };

  // ================================================================================
  // 【イベント処理層】
  // ================================================================================

  /**
   * 会計システムのイベントリスナー設定
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @param {string} classroom - 教室名
   */
  function setupAccountingEventListeners(classifiedItems, classroom) {
    // 入力変更イベント（チェックボックス、セレクト、インプット）
    document.addEventListener('change', function (event) {
      const target = event.target;

      // 会計関連の入力要素の変更を検知
      if (target.closest('.accounting-container')) {
        handleAccountingInputChange(event, classifiedItems, classroom);
      }

      // 支払い方法変更
      if (target.name === 'payment-method') {
        handlePaymentMethodChange(target.value);
      }
    });

    // ボタンクリックイベント
    document.addEventListener('click', function (event) {
      const target = event.target;
      const action = target.getAttribute('data-action');

      if (!action) return;

      switch (action) {
        case 'removeMaterialRow':
          removeMaterialRow(target.getAttribute('data-index'));
          break;
        case 'removeProductRow':
          removeProductRow(target.getAttribute('data-index'));
          break;
        case 'showPaymentModal':
          // デバッグ: ボタンクリックを記録
          if (!window.isProduction) {
            console.log('🔴 showPaymentModalボタンがクリックされました');
          }

          // イベントの伝播を停止
          event.preventDefault();
          event.stopPropagation();

          // ボタンが無効状態でないかチェック
          if (
            target.hasAttribute('disabled') ||
            target.style.pointerEvents === 'none'
          ) {
            if (!window.isProduction) {
              console.log('⚠️ ボタンが無効状態のためクリックを無視');
            }
            return;
          }

          showPaymentConfirmModal(classifiedItems, classroom);
          break;
        case 'smartGoBack':
          handleBackToDashboard();
          break;
        case 'cancelPaymentConfirm':
          closePaymentConfirmModal();
          break;
        case 'processPayment':
          handleProcessPayment();
          break;
        case 'saveMemo':
          handleSaveMemo(target);
          break;
      }
    });

    // 材料タイプ変更時の特別処理
    document.addEventListener('change', function (event) {
      if (event.target.id && event.target.id.startsWith('material-type-')) {
        handleMaterialTypeChange(event, classifiedItems.sales.materialItems);
      }
    });

    // 物販タイプ変更時の特別処理
    document.addEventListener('change', function (event) {
      if (event.target.id && event.target.id.startsWith('product-type-')) {
        handleProductTypeChange(event, classifiedItems.sales.productItems);
      }
    });

    // 自由入力物販の入力変更時の特別処理
    document.addEventListener('input', function (event) {
      if (event.target.id && event.target.id.startsWith('custom-sales-')) {
        handleCustomSalesInputChange(event);
      }
    });
  }

  /**
   * 会計入力変更時の処理
   * @param {Event} event - 変更イベント
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @param {string} classroom - 教室名
   */
  function handleAccountingInputChange(event, classifiedItems, classroom) {
    const target = event.target;

    // 動的スタイルのチェックボックスの更新
    if (target.type === 'checkbox' && target.hasAttribute('data-dynamic-style')) {
      updateCheckboxStyle(target);
    }

    // 短時間での連続計算を防ぐためのデバウンス
    clearTimeout(window.accountingCalculationTimeout);
    window.accountingCalculationTimeout = setTimeout(() => {
      updateAccountingCalculation(classifiedItems, classroom);
    }, 300);
  }

  /**
   * チェックボックスのスタイルを更新（項目名と金額の両方）
   * @param {HTMLInputElement} checkbox - チェックボックス要素
   */
  function updateCheckboxStyle(checkbox) {
    const label = checkbox.parentElement;
    if (!label) return;

    // ラベル（項目名）のスタイル更新
    if (checkbox.checked) {
      label.className = label.className.replace(
        'text-brand-muted',
        'font-bold text-brand-text',
      );
    } else {
      label.className = label.className.replace(
        'font-bold text-brand-text',
        'text-brand-muted',
      );
    }

    // 対応する金額表示のスタイル更新
    const checkboxRow = checkbox.closest('[data-checkbox-row]');
    if (checkboxRow) {
      const priceAmountElement = checkboxRow.querySelector('.price-amount');
      if (priceAmountElement) {
        // 赤字クラスは保持する
        const hasRedText = priceAmountElement.className.includes('text-red-600');
        const redClass = hasRedText ? ' text-red-600' : '';

        if (checkbox.checked) {
          // チェック済み: 濃い色、太字（赤字の場合は赤を優先）
          if (hasRedText) {
            priceAmountElement.className =
              priceAmountElement.className
                .replace(/text-brand-muted/g, '')
                .replace(/text-brand-text/g, '') + ' font-bold text-red-600';
          } else {
            priceAmountElement.className =
              priceAmountElement.className
                .replace(/text-brand-muted/g, '')
                .replace(/text-brand-text/g, '') + ' font-bold text-brand-text';
          }
        } else {
          // 未チェック: 薄い色（赤字の場合は薄い赤）
          if (hasRedText) {
            priceAmountElement.className =
              priceAmountElement.className
                .replace(/font-bold/g, '')
                .replace(/text-brand-text/g, '')
                .replace(/text-red-600/g, '') + ' text-red-400';
          } else {
            priceAmountElement.className =
              priceAmountElement.className
                .replace(/font-bold/g, '')
                .replace(/text-brand-text/g, '') + ' text-brand-muted';
          }
        }
      }
    }
  }

  /**
   * 材料タイプ変更時の処理
   * @param {Event} event - 変更イベント
   * @param {Array} materialItems - 材料項目配列
   */
  function handleMaterialTypeChange(event, materialItems) {
    const index = event.target.id.split('-')[2]; // material-type-0 -> 0
    const selectedType = event.target.value;
    const materialRow = document.querySelector(`[data-material-row="${index}"]`);

    if (!materialRow) return;

    // 選択された材料のマスタ情報を取得
    const selectedMaterial = materialItems.find(
      item => item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME] === selectedType,
    );

    // 既存のサイズ入力エリアを削除
    const existingSizeInputs = materialRow.querySelector('.size-inputs');
    if (existingSizeInputs) {
      existingSizeInputs.remove();
    }

    // 体積計算材料の場合、サイズ入力を追加
    if (
      selectedMaterial &&
      selectedMaterial[CONSTANTS.HEADERS.ACCOUNTING.UNIT] === 'cm³'
    ) {
      const sizeInputsHtml = `
        <div class="size-inputs flex items-center space-x-2 mt-2 pl-7">
          <input
            type="number"
            id="material-length-${index}"
            placeholder="x"
            class="w-10 p-0.5 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text text-right text-sm"
          >
          <span class="text-sm">×</span>
          <input
            type="number"
            id="material-width-${index}"
            placeholder="y"
            class="w-10 p-0.5 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text text-right text-sm"
          >
          <span class="text-sm">×</span>
          <input
            type="number"
            id="material-height-${index}"
            placeholder="z"
            class="w-10 p-0.5 border-2 border-ui-border rounded focus:outline-none focus:ring-2 focus:ring-brand-text text-right text-sm"
          >
          <span class="text-sm text-gray-600">mm</span>
        </div>`;

      materialRow.insertAdjacentHTML('beforeend', sizeInputsHtml);
    }

    // 価格をリセット
    const priceDisplay = materialRow.querySelector(`#material-price-${index}`);
    if (priceDisplay) {
      priceDisplay.innerHTML = Components.priceDisplay({ amount: 0 });
    }

    // 選択された場合、新しい行を自動追加
    if (selectedType) {
      const container = document.getElementById('materials-container');
      if (container) {
        const existingRows = container.querySelectorAll('.material-row');
        const lastRow = existingRows[existingRows.length - 1];
        const lastIndex = parseInt(lastRow.getAttribute('data-material-row'));

        // 最後の行が選択されている場合のみ新しい行を追加
        if (lastIndex === parseInt(index)) {
          const newIndex = existingRows.length;
          const newRowHtml = generateMaterialRow(materialItems, newIndex);
          container.insertAdjacentHTML('beforeend', newRowHtml);
        }
      }
    }

    // 計算を更新
    setTimeout(() => {
      const classifiedItems = window.currentClassifiedItems;
      const classroom = window.currentClassroom;
      if (classifiedItems && classroom) {
        updateAccountingCalculation(classifiedItems, classroom);
      }
    }, 100);
  }

  /**
   * 材料行追加
   * @param {Array} materialItems - 材料項目配列
   */
  function addMaterialRow(materialItems) {
    const container = document.getElementById('materials-container');
    if (!container) return;

    const existingRows = container.querySelectorAll('.material-row');
    const newIndex = existingRows.length;

    const newRowHtml = generateMaterialRow(materialItems, newIndex);
    container.insertAdjacentHTML('beforeend', newRowHtml);
  }

  /**
   * 材料行削除
   * @param {string} index - 削除する行のインデックス
   */
  function removeMaterialRow(index) {
    const row = document.querySelector(`[data-material-row="${index}"]`);
    if (row) {
      row.remove();
      // 計算を更新
      setTimeout(() => {
        const classifiedItems = window.currentClassifiedItems;
        const classroom = window.currentClassroom;
        if (classifiedItems && classroom) {
          updateAccountingCalculation(classifiedItems, classroom);
        }
      }, 100);
    }
  }

  /**
   * 物販タイプ変更時の処理
   * @param {Event} event - 変更イベント
   * @param {Array} productItems - 物販項目配列
   */
  function handleProductTypeChange(event, productItems) {
    const index = event.target.id.split('-')[2]; // product-type-0 -> 0
    const selectedType = event.target.value;
    const productRow = document.querySelector(`[data-product-row="${index}"]`);

    if (!productRow) return;

    // 選択された物販のマスタ情報を取得
    const selectedProduct = productItems.find(
      item => item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME] === selectedType,
    );

    // 価格を更新
    const priceDisplay = productRow.querySelector(`#product-price-${index}`);
    if (priceDisplay && selectedProduct) {
      const price = Number(
        selectedProduct[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE],
      );
      priceDisplay.innerHTML = Components.priceDisplay({ amount: price });

      // 選択後は商品名のみを表示（価格の2重表示を避ける）
      const selectElement = event.target;
      const selectedOption = selectElement.options[selectElement.selectedIndex];
      if (selectedOption && selectedOption.value) {
        selectedOption.textContent = selectedType; // 商品名のみ
      }
    } else if (priceDisplay) {
      priceDisplay.innerHTML = Components.priceDisplay({ amount: 0 });

      // 未選択の場合、プルダウンの表示をリセット
      const selectElement = event.target;
      const selectedOption = selectElement.options[selectElement.selectedIndex];
      if (selectedOption && selectedOption.value === '') {
        // 空の選択肢は元の表示のまま
        selectedOption.textContent = 'おえらびください';
      }
    }

    // 選択された場合、新しい行を自動追加
    if (selectedType) {
      const container = document.getElementById('products-container');
      if (container) {
        const existingRows = container.querySelectorAll('.product-row');
        const lastRow = existingRows[existingRows.length - 1];
        const lastIndex = parseInt(lastRow.getAttribute('data-product-row'));

        // 最後の行が選択されている場合のみ新しい行を追加
        if (lastIndex === parseInt(index)) {
          const newIndex = existingRows.length;
          const newRowHtml = generateProductRow(productItems, newIndex);
          container.insertAdjacentHTML('beforeend', newRowHtml);
        }
      }
    }

    // 計算を更新
    setTimeout(() => {
      const classifiedItems = window.currentClassifiedItems;
      const classroom = window.currentClassroom;
      if (classifiedItems && classroom) {
        updateAccountingCalculation(classifiedItems, classroom);
      }
    }, 100);
  }

  /**
   * 物販行削除
   * @param {string} index - 削除する行のインデックス
   */
  function removeProductRow(index) {
    const row = document.querySelector(`[data-product-row="${index}"]`);
    if (row) {
      row.remove();
      // 計算を更新
      setTimeout(() => {
        const classifiedItems = window.currentClassifiedItems;
        const classroom = window.currentClassroom;
        if (classifiedItems && classroom) {
          updateAccountingCalculation(classifiedItems, classroom);
        }
      }, 100);
    }
  }

  /**
   * 自由入力物販の入力変更処理
   * @param {Event} event - 入力変更イベント
   */
  function handleCustomSalesInputChange(event) {
    const target = event.target;
    const index = parseInt(target.id.split('-')[3]); // custom-sales-name-0 -> 0
    const container = document.getElementById('custom-sales-container');

    if (!container) return;

    // 価格フィールドの場合、価格表示を更新
    if (target.id.startsWith('custom-sales-price-')) {
      const priceDisplayElement = document.getElementById(
        `custom-sales-display-${index}`,
      );
      if (priceDisplayElement) {
        const price = Number(target.value) || 0;
        priceDisplayElement.innerHTML = Components.priceDisplay({
          amount: price,
        });
      }
    }

    // 最後の行で項目名または価格が入力されたら新しい行を追加
    const existingRows = container.querySelectorAll('.custom-sales-row');
    const isLastRow = index === existingRows.length - 1;

    if (isLastRow && target.value.trim()) {
      const nameInput = document.getElementById(`custom-sales-name-${index}`);
      const priceInput = document.getElementById(`custom-sales-price-${index}`);

      // 項目名または価格のどちらかが入力されている場合、新しい行を追加
      if (
        (nameInput && nameInput.value.trim()) ||
        (priceInput && priceInput.value.trim())
      ) {
        addCustomSalesRow();
      }
    }

    // 計算を更新
    setTimeout(() => {
      const classifiedItems = window.currentClassifiedItems;
      const classroom = window.currentClassroom;
      if (classifiedItems && classroom) {
        updateAccountingCalculation(classifiedItems, classroom);
      }
    }, 100);
  }

  /**
   * 自由入力物販行追加
   */
  function addCustomSalesRow() {
    const container = document.getElementById('custom-sales-container');
    if (!container) return;

    const existingRows = container.querySelectorAll('.custom-sales-row');
    const newIndex = existingRows.length;

    const newRowHtml = generateCustomSalesRow(newIndex);
    container.insertAdjacentHTML('beforeend', newRowHtml);
  }

  /**
   * 自由入力物販行削除
   * @param {string} index - 削除する行のインデックス
   */
  function removeCustomSalesRow(index) {
    const row = document.querySelector(`[data-custom-sales-row="${index}"]`);
    if (row) {
      row.remove();
      // 計算を更新
      setTimeout(() => {
        const classifiedItems = window.currentClassifiedItems;
        const classroom = window.currentClassroom;
        if (classifiedItems && classroom) {
          updateAccountingCalculation(classifiedItems, classroom);
        }
      }, 100);
    }
  }

  /**
   * 会計計算更新
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @param {string} classroom - 教室名
   */
  function updateAccountingCalculation(classifiedItems, classroom) {
    try {
      // フォームデータ収集
      const formData = collectAccountingFormData();

      // 計算実行
      const result = calculateAccountingTotal(
        formData,
        [
          ...classifiedItems.tuition.baseItems,
          ...classifiedItems.tuition.additionalItems,
          ...classifiedItems.sales.materialItems,
          ...classifiedItems.sales.productItems,
        ],
        classroom,
      );

      // UI更新
      updateAccountingUI(result, classroom);
    } catch (error) {
      console.error('会計計算エラー:', error);
      // エラー時は0で表示
      updateAccountingUI(
        {
          tuition: { subtotal: 0 },
          sales: { subtotal: 0 },
          grandTotal: 0,
        },
        classroom,
      );
    }
  }

  /**
   * 会計UI更新
   * @param {Object} result - 計算結果
   * @param {string} classroom - 教室名
   */
  function updateAccountingUI(result, classroom) {
    // 授業料小計更新
    const tuitionSubtotal = document.getElementById('tuition-subtotal-amount');
    if (tuitionSubtotal) {
      tuitionSubtotal.innerHTML = Components.priceDisplay({
        amount: result.tuition.subtotal,
        size: 'large',
      });
    }

    // 販売小計更新
    const salesSubtotal = document.getElementById('sales-subtotal-amount');
    if (salesSubtotal) {
      salesSubtotal.innerHTML = Components.priceDisplay({
        amount: result.sales.subtotal,
        size: 'large',
      });
    }

    // 総合計更新
    const grandTotal = document.getElementById('grand-total-amount');
    if (grandTotal) {
      grandTotal.innerHTML = Components.priceDisplay({
        amount: result.grandTotal,
        size: 'large',
      });
    }

    // 時間制の場合の時間計算表示更新
    updateTimeCalculationDisplay(result, classroom);

    // 個別価格表示更新
    updateMaterialPricesDisplay(result);
    updateProductPricesDisplay(result);
    updateCustomSalesPricesDisplay(result);
  }

  /**
   * 時間計算表示更新
   * @param {Object} result - 計算結果
   * @param {string} classroom - 教室名
   */
  function updateTimeCalculationDisplay(result, classroom) {
    const timeCalculation = document.getElementById('time-calculation');
    if (!timeCalculation) return;

    const formData = collectAccountingFormData();
    if (!formData.startTime || !formData.endTime) return;

    const timeUnits = calculateTimeUnits(
      formData.startTime,
      formData.endTime,
      formData.breakTime || 0,
    );
    const hours = timeUnits / 2; // 30分単位を時間に変換

    // 基本授業料の単価を取得
    const classifiedItems = window.currentClassifiedItems;
    const baseItem = classifiedItems?.tuition.baseItems.find(item => {
      const targetClassroom = item[CONSTANTS.HEADERS.ACCOUNTING.TARGET_CLASSROOM];
      return targetClassroom === classroom || targetClassroom.includes(classroom);
    });

    if (baseItem && baseItem[CONSTANTS.HEADERS.ACCOUNTING.UNIT] === '30分') {
      const unitPrice = Number(baseItem[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE]);
      const tuitionAmount = timeUnits * unitPrice;

      timeCalculation.innerHTML = `${hours}時間 ×${Components.priceDisplay({ amount: unitPrice * 2 })} =${Components.priceDisplay({ amount: tuitionAmount })}`;
    }
  }

  /**
   * 材料価格個別表示更新
   * @param {Object} result - 計算結果
   */
  function updateMaterialPricesDisplay(result) {
    const materials = document.querySelectorAll('.material-row');
    const salesItems = result.sales?.items || [];

    materials.forEach((row, index) => {
      const priceDisplay = row.querySelector(`#material-price-${index}`);
      const typeSelect = row.querySelector(`#material-type-${index}`);

      if (priceDisplay && typeSelect) {
        const selectedType = typeSelect.value;
        if (selectedType) {
          // 選択された材料タイプに一致するアイテムを検索
          const materialItem = salesItems.find(item => {
            return (
              item.name === selectedType ||
              item.name.startsWith(selectedType + ' (')
            );
          });

          if (materialItem) {
            priceDisplay.innerHTML = Components.priceDisplay({
              amount: materialItem.price,
            });
          } else {
            priceDisplay.innerHTML = Components.priceDisplay({ amount: 0 });
          }
        } else {
          priceDisplay.innerHTML = Components.priceDisplay({ amount: 0 });
        }
      }
    });
  }

  /**
   * 物販価格個別表示更新
   * @param {Object} result - 計算結果
   */
  function updateProductPricesDisplay(result) {
    const products = document.querySelectorAll('.product-row');
    const salesItems = result.sales?.items || [];

    products.forEach((row, index) => {
      const priceDisplay = row.querySelector(`#product-price-${index}`);
      const typeSelect = row.querySelector(`#product-type-${index}`);

      if (priceDisplay && typeSelect) {
        const selectedType = typeSelect.value;
        if (selectedType) {
          // 選択された物販タイプに一致するアイテムを検索
          const productItem = salesItems.find(item => item.name === selectedType);

          if (productItem) {
            priceDisplay.innerHTML = Components.priceDisplay({
              amount: productItem.price,
            });
          } else {
            priceDisplay.innerHTML = Components.priceDisplay({ amount: 0 });
          }
        } else {
          priceDisplay.innerHTML = Components.priceDisplay({ amount: 0 });
        }
      }
    });
  }

  /**
   * 自由入力物販価格個別表示更新
   * @param {Object} result - 計算結果
   */
  function updateCustomSalesPricesDisplay(result) {
    const customSales = document.querySelectorAll('.custom-sales-row');
    const salesItems = result.sales?.items || [];

    customSales.forEach((row, index) => {
      const priceDisplay = row.querySelector(`#custom-sales-display-${index}`);
      const nameInput = row.querySelector(`#custom-sales-name-${index}`);

      if (priceDisplay && nameInput) {
        const itemName = nameInput.value.trim();
        if (itemName) {
          // 入力された名前に一致するアイテムを検索
          const customItem = salesItems.find(item => item.name === itemName);

          if (customItem) {
            priceDisplay.innerHTML = Components.priceDisplay({
              amount: customItem.price,
            });
          } else {
            priceDisplay.innerHTML = Components.priceDisplay({ amount: 0 });
          }
        } else {
          priceDisplay.innerHTML = Components.priceDisplay({ amount: 0 });
        }
      }
    });
  }

  /**
   * 支払い方法UI初期化（既存関数を活用）
   * @param {string} selectedPaymentMethod - 選択済みの支払い方法
   */
  function initializePaymentMethodUI(selectedPaymentMethod = '') {
    const paymentOptionsContainer = document.getElementById(
      'payment-options-container',
    );
    const paymentInfoContainer = document.getElementById(
      'payment-info-container',
    );

    if (paymentOptionsContainer) {
      paymentOptionsContainer.innerHTML = getPaymentOptionsHtml(
        selectedPaymentMethod,
      );
    }

    if (paymentInfoContainer) {
      paymentInfoContainer.innerHTML = getPaymentInfoHtml(selectedPaymentMethod);
    }

    // 確認ボタンの初期状態設定
    updateConfirmButtonState();
  }

  /**
   * 支払い方法変更時の処理（既存関数を活用）
   * @param {string} selectedMethod - 選択された支払い方法
   */
  function handlePaymentMethodChange(selectedMethod) {
    const paymentInfoContainer = document.getElementById(
      'payment-info-container',
    );

    if (paymentInfoContainer) {
      paymentInfoContainer.innerHTML = getPaymentInfoHtml(selectedMethod);
    }

    // 支払い方法のスタイルを更新
    updatePaymentMethodStyles(selectedMethod);

    // 確認ボタンの状態を更新
    updateConfirmButtonState();
  }

  /**
   * 支払い方法のラベルスタイルを動的に更新
   * @param {string} selectedMethod - 選択された支払い方法
   */
  function updatePaymentMethodStyles(selectedMethod) {
    const paymentMethodRadios = document.querySelectorAll(
      'input[name="payment-method"]',
    );

    paymentMethodRadios.forEach(radio => {
      const label = radio.closest('label');
      if (label) {
        const span = label.querySelector('span');
        if (span) {
          // 選択されている場合は太字・濃い色、未選択は薄い色
          if (radio.value === selectedMethod) {
            label.className = label.className.replace(
              /text-brand-muted/,
              'font-bold text-brand-text',
            );
          } else {
            label.className = label.className.replace(
              /font-bold text-brand-text/,
              'text-brand-muted',
            );
          }
        }
      }
    });
  }

  /**
   * 確認ボタンの有効/無効状態を更新
   */
  function updateConfirmButtonState() {
    const confirmButton = document.getElementById('confirm-payment-button');
    const selectedPaymentMethod = document.querySelector(
      'input[name="payment-method"]:checked',
    );

    if (confirmButton) {
      if (selectedPaymentMethod) {
        // 有効状態：明示的にaccountingスタイルを復元
        confirmButton.removeAttribute('disabled');
        confirmButton.removeAttribute('style');
        confirmButton.style.pointerEvents = '';
        confirmButton.className = confirmButton.className.replace(
          /\sopacity-\d+|\scursor-not-allowed/g,
          '',
        );
      } else {
        // 無効状態：明示的に無効スタイルを適用
        confirmButton.setAttribute('disabled', 'true');
        confirmButton.style.pointerEvents = 'none';
        // 既存のクラスに無効状態のクラスを追加
        if (!confirmButton.className.includes('opacity-60')) {
          confirmButton.className += ' opacity-60 cursor-not-allowed';
        }
      }
    }
  }

  /**
   * 新フォームデータを既存バックエンド形式に変換
   * @param {AccountingFormData} formData - 新フォームデータ
   * @param {Object} result - 計算結果
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @returns {Object} 既存バックエンド形式のuserInput
   */
  function convertToLegacyFormat(formData, result, classifiedItems) {
    // デバッグログ追加
    if (!window.isProduction) {
      console.log('🔍 convertToLegacyFormat入力データ:', {
        formData,
        result,
        'result.tuition.items': result.tuition.items,
        'result.sales.items': result.sales.items,
      });
    }

    const userInput = {
      paymentMethod: formData.paymentMethod || CONSTANTS.PAYMENT_DISPLAY.CASH,
      tuitionItems: result.tuition.items || [],
      salesItems: result.sales.items || [],
      timeBased:
        formData.startTime && formData.endTime
          ? {
              startTime: formData.startTime,
              endTime: formData.endTime,
              breakMinutes: formData.breakTime || 0,
              discountApplied: result.tuition.items.some(item => item.price < 0),
            }
          : null,
    };

    // デバッグログ追加
    if (!window.isProduction) {
      console.log('🔍 convertToLegacyFormat出力データ:', userInput);
    }

    return userInput;
  }

  /**
   * ダッシュボード画面にもどる処理
   */
  function handleBackToDashboard() {
    try {
      // 現在のフォームデータをキャッシュに保存
      const currentFormData = collectAccountingFormData();
      saveAccountingCache(currentFormData);

      // スマートナビゲーションで前の画面にもどる
      if (typeof actionHandlers !== 'undefined' && actionHandlers.smartGoBack) {
        actionHandlers.smartGoBack();
      } else {
        // フォールバック: StateManagerを使用
        if (
          window.stateManager &&
          typeof window.stateManager.dispatch === 'function'
        ) {
          window.stateManager.dispatch({
            type: 'CHANGE_VIEW',
            payload: { view: 'dashboard' },
          });
        } else if (typeof updateView === 'function') {
          // 直接ビュー更新を試行
          updateView('dashboard');
        } else {
          // 最終フォールバック: ページリロード
          window.location.reload();
        }
      }
    } catch (error) {
      console.error('ダッシュボード画面への遷移エラー:', error);
      if (typeof showError === 'function') {
        showError('画面遷移でエラーが発生しました。もう一度お試しください。');
      } else {
        alert('画面遷移でエラーが発生しました。もう一度お試しください。');
      }
    }
  }

  /**
   * 支払い確認モーダルHTML生成
   * @param {Object} result - 計算結果
   * @param {string} paymentMethod - 支払い方法
   * @returns {string} モーダルHTML
   */
  function generatePaymentConfirmModal(result, paymentMethod) {
    // 支払い方法に応じた支払先情報
    const paymentInfoHtml =
      typeof getPaymentInfoHtml === 'function'
        ? getPaymentInfoHtml(paymentMethod)
        : '';

    // 金額表示のヘルパー
    const formatPrice = amount => {
      if (typeof Components !== 'undefined' && Components.priceDisplay) {
        return Components.priceDisplay({ amount });
      }
      return `¥${amount.toLocaleString()}`;
    };

    const formatPriceLarge = amount => {
      if (typeof Components !== 'undefined' && Components.priceDisplay) {
        return Components.priceDisplay({ amount, size: 'large' });
      }
      return `¥${amount.toLocaleString()}`;
    };

    // ボタン生成のヘルパー
    const generateButton = (action, text, style, customClass = '') => {
      if (typeof Components !== 'undefined' && Components.button) {
        return Components.button({
          action,
          text,
          style,
          size: 'large',
          customClass: `flex-1 ${customClass}`,
          disabledStyle: 'auto', // 自動無効状態スタイル対応
        });
      }
      const styleClass =
        style === 'primary'
          ? 'bg-action-primary-bg text-action-primary-text hover:bg-action-primary-hover'
          : 'bg-action-secondary-bg text-action-secondary-text hover:bg-action-secondary-hover';
      return `<button data-action="${action}" class="${styleClass} px-4 py-2 rounded font-bold flex-1 ${customClass}">${text}</button>`;
    };

    return `
      <div id="payment-confirm-modal" class="fixed inset-0 bg-gray-800 bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg mx-4 max-w-md w-full max-h-screen overflow-y-auto">

          <!-- モーダルヘッダー -->
          <div class="p-6 border-b-2 border-gray-200">
            <h3 class="text-xl font-bold text-brand-text">支払い確認</h3>
          </div>

          <!-- モーダルボディ -->
          <div class="p-4 space-y-4">

            <!-- 合計金額セクション -->
            <div class="bg-ui-surface rounded-lg p-4">
              <h4 class="font-medium text-brand-text mb-3">金額</h4>
              <div class="space-y-2 text-sm">
                <div class="flex justify-between">
                  <span class="text-brand-subtle">授業料小計:</span>
                  <span class="font-mono-numbers">${formatPrice(result.tuition.subtotal)}</span>
                </div>
                <div class="flex justify-between">
                  <span class="text-brand-subtle">販売小計:</span>
                  <span class="font-mono-numbers">${formatPrice(result.sales.subtotal)}</span>
                </div>
                <div class="border-t-2 border-ui-border pt-2 mt-2">
                  <div class="flex justify-between">
                    <span class="font-bold text-brand-text">総合計:</span>
                    <span class="font-bold text-xl text-brand-text font-mono-numbers">${formatPriceLarge(result.grandTotal)}</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- 支払い方法セクション -->
            <div class="bg-ui-surface rounded-lg p-4">
              <h4 class="font-medium text-brand-text mb-3">支払い方法</h4>
              <div class="text-lg font-bold text-brand-text mb-3">${paymentMethod}</div>
              ${paymentInfoHtml ? `<div class="mt-3">${paymentInfoHtml}</div>` : ''}
            </div>
          </div>
          <!-- モーダルフッター -->
          <div class="p-6 border-t-2 border-gray-200 flex gap-3">
            ${generateButton('cancelPaymentConfirm', '修正する', 'secondary')}
            ${generateButton('processPayment', '支払いました', 'primary')}
          </div>

        </div>
      </div>
    `;
  }

  /**
   * 支払い確認モーダルを表示する処理
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @param {string} classroom - 教室名
   */
  function showPaymentConfirmModal(classifiedItems, classroom) {
    // デバッグ: 関数呼び出しを記録
    if (!window.isProduction) {
      console.log('🔵 showPaymentConfirmModal関数が呼び出されました');
    }

    try {
      const formData = collectAccountingFormData();

      // 支払い方法の選択チェック
      if (!formData.paymentMethod) {
        if (typeof showError === 'function') {
          showError('支払い方法を選択してください。');
        } else {
          alert('支払い方法を選択してください。');
        }
        return;
      }

      // デバッグ：計算前の情報
      if (!window.isProduction) {
        console.log('🔍 支払い確認モーダル: 計算前データ確認', {
          classifiedItems存在: !!classifiedItems,
          baseItemsLength: classifiedItems?.tuition?.baseItems?.length || 0,
          additionalItemsLength:
            classifiedItems?.tuition?.additionalItems?.length || 0,
          materialItemsLength: classifiedItems?.sales?.materialItems?.length || 0,
          productItemsLength: classifiedItems?.sales?.productItems?.length || 0,
          classroom,
        });
      }

      const result = calculateAccountingTotal(
        formData,
        [
          ...classifiedItems.tuition.baseItems,
          ...classifiedItems.tuition.additionalItems,
          ...classifiedItems.sales.materialItems,
          ...classifiedItems.sales.productItems,
        ],
        classroom,
      );

      // デバッグログ
      if (!window.isProduction) {
        console.log('🔍 支払い確認モーダル生成開始', { formData, result });
      }

      // モーダルHTML生成
      const modalHtml = generatePaymentConfirmModal(
        result,
        formData.paymentMethod,
      );

      if (!window.isProduction) {
        console.log('モーダルHTML生成完了:', modalHtml.substring(0, 200) + '...');
      }

      // 既存のモーダルがあれば削除
      const existingModal = document.getElementById('payment-confirm-modal');
      if (existingModal) {
        existingModal.remove();
      }

      // モーダルを表示
      document.body.insertAdjacentHTML('beforeend', modalHtml);

      if (!window.isProduction) {
        console.log('モーダル挿入完了');
      }

      // データを一時保存（後で処理時に使用）
      window.tempPaymentData = {
        formData,
        result,
        classifiedItems,
        classroom,
      };
    } catch (error) {
      console.error('支払い確認エラー:', error);
      console.error('エラースタック:', error.stack);

      // デバッグ情報
      if (!window.isProduction) {
        console.log('エラー発生時の状態:', {
          formData: formData || 'undefined',
          classifiedItems: classifiedItems || 'undefined',
          classroom: classroom || 'undefined',
        });
      }

      if (typeof showError === 'function') {
        showError(`エラーが発生しました: ${error.message}`);
      } else {
        alert(`エラーが発生しました: ${error.message}`);
      }
    }
  }

  /**
   * 支払い確認モーダルを閉じる
   */
  function closePaymentConfirmModal() {
    const modal = document.getElementById('payment-confirm-modal');
    if (modal) {
      modal.remove();
    }

    // 支払い処理が完了していない場合のみデータをクリア
    // 「修正する」ボタンでキャンセルされた場合
    if (window.tempPaymentData) {
      window.tempPaymentData = null;
    }
  }

  /**
   * 支払い処理を実行（モーダルから呼び出し）
   */
  function handleProcessPayment() {
    // 重複実行防止チェック
    if (window.paymentProcessing) {
      if (!window.isProduction) {
        console.log('⚠️ 支払い処理は既に実行中です');
      }
      return;
    }

    if (!window.tempPaymentData) {
      console.error('支払いデータが見つかりません');
      if (!window.isProduction) {
        console.log('デバッグ: window.tempPaymentData =', window.tempPaymentData);
      }

      if (typeof showError === 'function') {
        showError(
          '支払いデータが見つかりません。会計画面から再度お試しください。',
        );
      } else {
        alert('支払いデータが見つかりません。会計画面から再度お試しください。');
      }

      // モーダルを閉じる
      const modal = document.getElementById('payment-confirm-modal');
      if (modal) {
        modal.remove();
      }
      return;
    }

    // 処理中フラグを設定
    window.paymentProcessing = true;

    const { formData, result, classifiedItems, classroom } =
      window.tempPaymentData;

    // デバッグログ
    if (!window.isProduction) {
      console.log('🟢 支払い処理開始:', {
        formData,
        result,
        classifiedItems,
        classroom,
      });
    }

    // モーダルを閉じる（データクリアなし）
    const modal = document.getElementById('payment-confirm-modal');
    if (modal) {
      modal.remove();
    }

    // 実際の会計処理を実行（14_WebApp_Handlers.jsのconfirmAndPay関数を呼び出し）
    try {
      if (!window.isProduction) {
        console.log('🔍 handleProcessPayment: 処理方法を判定中', {
          actionHandlers存在: typeof actionHandlers !== 'undefined',
          confirmAndPay存在:
            typeof actionHandlers !== 'undefined' && actionHandlers.confirmAndPay,
        });
      }

      if (typeof actionHandlers !== 'undefined' && actionHandlers.confirmAndPay) {
        if (!window.isProduction) {
          console.log(
            '🔍 handleProcessPayment: actionHandlers.confirmAndPay()を実行',
          );
        }
        actionHandlers.confirmAndPay();
      } else {
        if (!window.isProduction) {
          console.log('🔍 handleProcessPayment: フォールバック処理を実行');
        }
        // フォールバック: 直接処理
        processAccountingPayment(formData, result, classifiedItems, classroom);
      }
    } finally {
      // 支払い処理完了後にデータとフラグをクリア
      window.tempPaymentData = null;
      window.paymentProcessing = false;
    }
  }

  /**
   * 制作メモ保存処理
   * @param {HTMLElement} target - ボタン要素
   */
  function handleSaveMemo(target) {
    const reservationId = target.getAttribute('data-reservation-id');
    if (!reservationId) {
      console.error('予約IDが見つかりません');
      return;
    }

    const textareaId = `memo-edit-textarea-${reservationId}`;
    const textarea = document.getElementById(textareaId);
    if (!textarea) {
      console.error('制作メモのテキストエリアが見つかりません');
      return;
    }

    const newMemoText = textarea.value;

    // ローディング表示
    if (typeof showLoading === 'function') {
      showLoading('memo');
    }

    // バックエンドAPIコール
    if (typeof google !== 'undefined' && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(response => {
          if (typeof hideLoading === 'function') {
            hideLoading();
          }

          if (response.success) {
            // 成功メッセージ表示
            if (typeof showSuccess === 'function') {
              showSuccess('制作メモを更新しました。');
            } else {
              alert('制作メモを更新しました。');
            }

            // テキストエリアの値を更新
            textarea.value = newMemoText;
          } else {
            if (typeof showError === 'function') {
              showError(
                '制作メモの更新に失敗しました: ' + (response.message || ''),
              );
            } else {
              alert('制作メモの更新に失敗しました: ' + (response.message || ''));
            }
          }
        })
        .withFailureHandler(error => {
          if (typeof hideLoading === 'function') {
            hideLoading();
          }
          console.error('制作メモ更新エラー:', error);
          if (typeof showError === 'function') {
            showError('制作メモの更新でエラーが発生しました。');
          } else {
            alert('制作メモの更新でエラーが発生しました。');
          }
        })
        .updateWorkInProgress({
          reservationId: reservationId,
          workInProgress: newMemoText,
        });
    } else {
      // Google Apps Script環境でない場合のフォールバック
      if (typeof hideLoading === 'function') {
        hideLoading();
      }
      alert('システムエラー：Google Apps Scriptとの通信ができません。');
    }
  }

  /**
   * 実際の会計処理を実行
   * @param {AccountingFormData} formData - フォームデータ
   * @param {Object} result - 計算結果
   * @param {ClassifiedAccountingItems} classifiedItems - 分類済み会計項目
   * @param {string} classroom - 教室名
   */
  function processAccountingPayment(
    formData,
    result,
    classifiedItems,
    classroom,
  ) {
    try {
      // ローディング表示
      if (typeof showLoading === 'function') {
        showLoading('accounting');
      }

      // 既存バックエンド形式に変換
      const legacyUserInput = convertToLegacyFormat(
        formData,
        result,
        classifiedItems,
      );

      // 制作メモデータを収集
      const memoData = collectMemoData();

      // ペイロード準備
      const payload = {
        reservationId:
          window.stateManager?.getState()?.accountingReservation?.reservationId,
        classroom:
          window.stateManager?.getState()?.accountingReservation?.classroom,
        studentId: window.stateManager?.getState()?.currentUser?.studentId,
        userInput: legacyUserInput,
        // 制作メモデータを追加
        workInProgress: memoData.workInProgress || '',
      };

      // デバッグログ：最終ペイロード
      if (!window.isProduction) {
        console.log('🔍 最終送信ペイロード:', payload);
        console.log('🔍 userInput詳細:', {
          tuitionItems: payload.userInput.tuitionItems,
          salesItems: payload.userInput.salesItems,
          paymentMethod: payload.userInput.paymentMethod,
          timeBased: payload.userInput.timeBased,
        });
        console.log('🔍 制作メモデータ:', {
          reservationId: memoData.reservationId,
          workInProgress: memoData.workInProgress,
        });
      }

      // バックエンドAPIコール
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        google.script.run
          .withSuccessHandler(response => {
            if (typeof hideLoading === 'function') {
              hideLoading();
            }

            if (response.success) {
              // 会計キャッシュをクリア（ローカルの一時データをクリア）
              if (typeof clearAccountingCache === 'function') {
                clearAccountingCache();
              }

              // データを最新に更新
              if (response.data && window.stateManager) {
                window.stateManager.dispatch({
                  type: 'UPDATE_STATE',
                  payload: {
                    myReservations: response.data.myReservations || [],
                    lessons: response.data.lessons || [],
                  },
                });
              }

              // 完了画面に遷移（会計完了として認識されるメッセージを使用）
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  view: 'complete',
                  completionMessage: '会計情報を記録しました。',
                },
              });
            } else {
              if (typeof showError === 'function') {
                showError('会計処理に失敗しました: ' + (response.message || ''));
              } else {
                alert('会計処理に失敗しました: ' + (response.message || ''));
              }
            }
          })
          .withFailureHandler(error => {
            if (typeof hideLoading === 'function') {
              hideLoading();
            }
            console.error('会計処理エラー:', error);
            if (typeof showError === 'function') {
              showError('会計処理でエラーが発生しました。');
            } else {
              alert('会計処理でエラーが発生しました。');
            }
          })
          .saveAccountingDetailsAndGetLatestData(payload);
      } else {
        // Google Apps Script環境でない場合のフォールバック
        if (typeof hideLoading === 'function') {
          hideLoading();
        }
        alert('システムエラー：Google Apps Scriptとの通信ができません。');
      }
    } catch (error) {
      if (typeof hideLoading === 'function') {
        hideLoading();
      }
      console.error('支払い処理エラー:', error);
      alert('エラーが発生しました。もう一度お試しください。');
    }
  }

  // ================================================================================
  // 【ユーティリティ層】
  // ================================================================================

  /**
   * 制作メモのデータを収集
   * @returns {Object} 制作メモデータ
   */
  function collectMemoData() {
    const memoData = {};

    // 会計画面の制作メモテキストエリアを探す
    const textareas = document.querySelectorAll('.memo-edit-textarea');
    textareas.forEach(textarea => {
      // テキストエリアのIDからreservationIdを推測
      const id = textarea.id;
      if (id && id.includes('memo-edit-textarea-')) {
        const reservationId = id.replace('memo-edit-textarea-', '');
        memoData.reservationId = reservationId;
        memoData.workInProgress = textarea.value;
      } else {
        // IDパターンが違う場合、親要素から予約IDを取得
        const card = textarea.closest('[data-reservation-id]');
        if (card) {
          const reservationId = card.getAttribute('data-reservation-id');
          memoData.reservationId = reservationId;
          memoData.workInProgress = textarea.value;
        }
      }
    });

    return memoData;
  }

  /**
   * フォームデータ収集
   * @returns {AccountingFormData} 収集されたフォームデータ
   */
  function collectAccountingFormData() {
    const formData = {};

    // デバッグ: フォームデータ収集開始
    if (!window.isProduction) {
      console.log('🔍 collectAccountingFormData開始');
    }

    // 時刻データ収集
    const startTimeEl = document.getElementById('start-time');
    const endTimeEl = document.getElementById('end-time');
    const breakTimeEl = document.getElementById('break-time');

    // デバッグ: 時刻要素の存在確認
    if (!window.isProduction) {
      console.log('🔍 時刻要素チェック:', {
        startTimeEl: !!startTimeEl,
        endTimeEl: !!endTimeEl,
        breakTimeEl: !!breakTimeEl,
        startTimeValue: startTimeEl?.value,
        endTimeValue: endTimeEl?.value,
        breakTimeValue: breakTimeEl?.value,
      });
    }

    if (startTimeEl) formData.startTime = startTimeEl.value;
    if (endTimeEl) formData.endTime = endTimeEl.value;
    if (breakTimeEl) formData.breakTime = Number(breakTimeEl.value) || 0;

    // チェックボックス項目収集
    const checkedItems = {};

    // 基本授業料のチェック状態を確認
    const baseTuitionCheckbox = document.getElementById('base-tuition');
    if (baseTuitionCheckbox && baseTuitionCheckbox.checked) {
      checkedItems['基本授業料'] = true;
    }

    // 追加項目のチェックボックス
    const checkboxes = document.querySelectorAll(
      '.accounting-container input[type="checkbox"]:not(#base-tuition)',
    );

    checkboxes.forEach(checkbox => {
      if (checkbox.checked) {
        // data属性から項目名を取得（優先）
        const itemName = checkbox.getAttribute('data-item-name');
        if (itemName) {
          checkedItems[itemName] = true;
        } else {
          // フォールバック: ラベルテキストから項目名を抽出
          const labelElement = checkbox.parentElement.querySelector('span');
          if (labelElement) {
            const fallbackItemName = labelElement.textContent.trim();
            checkedItems[fallbackItemName] = true;
          }
        }
      }
    });

    if (Object.keys(checkedItems).length > 0) {
      formData.checkedItems = checkedItems;
    }

    // 材料データ収集
    const materials = [];
    const materialRows = document.querySelectorAll('.material-row');

    materialRows.forEach((row, index) => {
      const typeSelect = row.querySelector(`#material-type-${index}`);
      if (typeSelect && typeSelect.value) {
        const material = { type: typeSelect.value };

        // サイズデータがある場合
        const lengthInput = row.querySelector(`#material-length-${index}`);
        const widthInput = row.querySelector(`#material-width-${index}`);
        const heightInput = row.querySelector(`#material-height-${index}`);

        if (lengthInput && widthInput && heightInput) {
          material.l = Number(lengthInput.value) || 0;
          material.w = Number(widthInput.value) || 0;
          material.h = Number(heightInput.value) || 0;
        }

        materials.push(material);
      }
    });

    if (materials.length > 0) {
      formData.materials = materials;
    }

    // 物販データ収集（プルダウン選択式）
    const selectedProducts = [];
    const productRows = document.querySelectorAll('.product-row');

    productRows.forEach((row, index) => {
      const typeSelect = row.querySelector(`#product-type-${index}`);
      if (typeSelect && typeSelect.value) {
        const selectedOption = typeSelect.options[typeSelect.selectedIndex];
        const price = selectedOption.getAttribute('data-price');
        selectedProducts.push({
          name: typeSelect.value,
          price: Number(price) || 0,
        });
      }
    });

    if (selectedProducts.length > 0) {
      formData.selectedProducts = selectedProducts;
    }

    // 自由入力物販データ収集
    const customSales = [];
    const customSalesRows = document.querySelectorAll('.custom-sales-row');

    customSalesRows.forEach((row, index) => {
      const nameInput = row.querySelector(`#custom-sales-name-${index}`);
      const priceInput = row.querySelector(`#custom-sales-price-${index}`);

      if (nameInput && priceInput && nameInput.value && priceInput.value) {
        customSales.push({
          name: nameInput.value.trim(),
          price: Number(priceInput.value) || 0,
        });
      }
    });

    if (customSales.length > 0) {
      formData.customSales = customSales;
    }

    // 支払い方法収集
    const paymentMethodRadio = document.querySelector(
      'input[name="payment-method"]:checked',
    );
    if (paymentMethodRadio) {
      formData.paymentMethod = paymentMethodRadio.value;
    }
    // 支払い方法が選択されていない場合は undefined のまま（必須チェックで弾く）

    // デバッグ: 収集されたフォームデータを出力
    if (!window.isProduction) {
      console.log('🔍 collectAccountingFormData結果:', formData);
      console.log(
        '🔍 基本授業料チェック状態:',
        document.getElementById('base-tuition')?.checked,
      );
      console.log('🔍 支払い方法:', formData.paymentMethod);
      console.log('🔍 チェック済み項目:', formData.checkedItems);
    }

    return formData;
  }

  /**
   * 会計キャッシュ保存
   * @param {AccountingFormData} formData - 保存するフォームデータ
   */
  function saveAccountingCache(formData) {
    try {
      const cacheKey = 'accounting_form_data';
      const cacheData = {
        data: formData,
        timestamp: Date.now(),
        version: '1.0',
      };

      localStorage.setItem(cacheKey, JSON.stringify(cacheData));
    } catch (error) {
      console.error('会計キャッシュ保存エラー:', error);
    }
  }

  /**
   * 会計キャッシュ読込
   * @returns {AccountingFormData} 読み込まれたフォームデータ
   */
  function loadAccountingCache() {
    try {
      const cacheKey = 'accounting_form_data';
      const cached = localStorage.getItem(cacheKey);

      if (!cached) return {};

      const cacheData = JSON.parse(cached);
      const maxAge = 24 * 60 * 60 * 1000; // 24時間

      // キャッシュが古い場合は削除
      if (Date.now() - cacheData.timestamp > maxAge) {
        localStorage.removeItem(cacheKey);
        return {};
      }

      return cacheData.data || {};
    } catch (error) {
      console.error('会計キャッシュ読込エラー:', error);
      return {};
    }
  }

  /**
   * 会計システム初期化関数
   * @param {Array} masterData - 会計マスタデータ
   * @param {string} classroom - 教室名
   * @param {AccountingFormData} initialFormData - 初期フォームデータ
   * @param {Object} reservationData - 予約データ（講座基本情報表示用）
   * @returns {string} 生成された会計画面HTML
   */
  function initializeAccountingSystem(
    masterData,
    classroom,
    initialFormData = {},
    reservationData = null,
  ) {
    // グローバル変数に保存（イベント処理で使用）
    const classifiedItems = classifyAccountingItems(masterData, classroom);
    window.currentClassifiedItems = classifiedItems;
    window.currentClassroom = classroom;

    // キャッシュから既存データを読み込み、初期データとマージ
    const cachedData = loadAccountingCache();
    const formData = { ...cachedData, ...initialFormData };

    // 会計画面HTML生成
    const accountingHtml = generateAccountingView(
      classifiedItems,
      classroom,
      formData,
      reservationData,
    );

    // DOMに挿入後の初期化処理を予約
    setTimeout(() => {
      // 支払い方法UI初期化（初期状態では何も選択しない）
      initializePaymentMethodUI('');

      // イベントリスナー設定
      setupAccountingEventListeners(classifiedItems, classroom);

      // 初期計算実行
      updateAccountingCalculation(classifiedItems, classroom);

      // キャッシュ保存の定期実行
      setInterval(() => {
        const currentFormData = collectAccountingFormData();
        saveAccountingCache(currentFormData);
      }, 30000); // 30秒ごと
    }, 100);

    return accountingHtml;
  }

  /**
   * 会計システムクリーンアップ
   */
  function cleanupAccountingSystem() {
    // タイマーをクリア
    if (window.accountingCalculationTimeout) {
      clearTimeout(window.accountingCalculationTimeout);
      window.accountingCalculationTimeout = null;
    }

    // グローバル変数をクリア
    window.currentClassifiedItems = null;
    window.currentClassroom = null;

    // 最終的なキャッシュ保存
    try {
      const currentFormData = collectAccountingFormData();
      saveAccountingCache(currentFormData);
    } catch (error) {
      console.error('クリーンアップ時のキャッシュ保存エラー:', error);
    }
  }


  // =================================================================
  // 12_WebApp_Core_Data.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 12_WebApp_Core_Data.js
   * 【バージョン】: 1.0
   * 【役割】: WebAppのフロントエンドにおける、データ処理と環境管理を
   * 集約します。初期データ処理、環境検出、StateManager初期化など。
   * 【構成】: 12_WebApp_Core.jsから分割されたデータ管理ファイル
   * 【新規作成理由】:
   * - メインコアファイルの肥大化対策
   * - データ処理機能の独立性向上
   * - AIの作業効率向上のためのファイル分割
   * =================================================================
   */

  // =================================================================
  // --- Initial Data Processing ---
  // -----------------------------------------------------------------

  /**
   * シンプルなダッシュボード状態を構築する（簡素化版）
   * @param {any} currentUser - 軽量認証から取得したユーザー情報
   * @param {ReservationData[]} myReservations - 個人の予約データ
   * @returns {Partial<UIState>} シンプルなダッシュボード状態
   */
  function createSimpleDashboardState(currentUser, myReservations) {
    return {
      view: 'dashboard',
      currentUser: currentUser,
      myReservations: myReservations || [],
      // 他のデータは必要時に取得
      lessons: [],
      classrooms: CONSTANTS.CLASSROOMS ? Object.values(CONSTANTS.CLASSROOMS) : [],
      today: new Date().toISOString().split('T')[0], // フロントで生成
    };
  }

  /**
   * 会計システムの事前初期化（アプリ起動時）
   * 全教室分の会計データを分類してキャッシュし、会計画面への高速遷移を実現
   * @param {Array<any>} accountingMaster - 会計マスタデータ
   */
  function preInitializeAccountingSystem(accountingMaster) {
    if (!accountingMaster || accountingMaster.length === 0) {
      console.warn(
        '⚠️ 会計マスタデータが存在しないため、事前初期化をスキップします',
      );
      return;
    }

    try {
      // 全教室の分類済みデータを事前生成
      const classrooms = CONSTANTS.CLASSROOMS
        ? Object.values(CONSTANTS.CLASSROOMS)
        : [];
      /** @type {Record<string, ClassifiedAccountingItems>} */
      const preInitializedData = {};

      classrooms.forEach(classroom => {
        if (typeof classifyAccountingItems === 'function') {
          const classifiedItems = classifyAccountingItems(
            accountingMaster,
            classroom,
          );
          preInitializedData[classroom] = classifiedItems;
        }
      });

      // グローバルキャッシュに保存
      /** @type {any} */ (window).accountingSystemCache = preInitializedData;

      if (!window.isProduction) {
        console.log('✅ 会計システム事前初期化完了:', {
          classrooms: classrooms.length,
          masterItems: accountingMaster.length,
        });
      }
    } catch (error) {
      console.error('❌ 会計システム事前初期化エラー:', error);
      // エラーが発生してもアプリ全体の動作は継続
    }
  }

  // =================================================================
  // --- Environment Detection & Data Management ---
  // -----------------------------------------------------------------
  // 実行環境を自動検出し、適切なデータソースを選択します。
  // テスト環境: ブラウザ + モックデータ
  // 本番環境: Google Apps Script + 実データ
  // =================================================================

  /**
   * 実行環境の検出
   * @returns {string} 'test' | 'production'
   */
  const detectEnvironment = () => {
    try {
      // GAS環境の検出
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        return 'production';
      }
      return 'test';
    } catch (error) {
      return 'test';
    }
  };

  /**
   * 環境に応じたデータ取得
   * @param {string} dataType - データタイプ
   * @param {unknown} fallback - フォールバックデータ
   */
  const getEnvironmentData = (dataType, fallback = null) => {
    const env = detectEnvironment();

    if (env === 'test' && typeof MockData !== 'undefined') {
      return MockData[dataType] || fallback;
    }

    // GAS環境では初期値のみ返し、データは後でAPI呼び出しで取得
    return fallback;
  };

  // =================================================================
  // --- StateManager Initialization ---
  // -----------------------------------------------------------------

  // StateManagerの再初期化（依存関数が読み込まれた後）
  if (
    typeof window.initializeStateManager === 'function' &&
    !window.stateManager
  ) {
    console.log('🔄 StateManagerを再初期化中...');
    window.initializeStateManager();
  }

  // StateManagerが初期化された後にビューリスナーを設定
  // DOMContentLoadedまたはページ読み込み完了後に実行
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      // Googleサイト埋め込み環境の調整を適用
      if (
        window.EmbedConfig &&
        typeof window.EmbedConfig.applyEmbedStyles === 'function'
      ) {
        window.EmbedConfig.applyEmbedStyles();
      }

      if (window.stateManager && typeof setupViewListener === 'function') {
        setupViewListener();
      }
    });
  } else {
    // 既にDOMが読み込み済みの場合は即座に実行

    // Googleサイト埋め込み環境の調整を適用
    if (
      window.EmbedConfig &&
      typeof window.EmbedConfig.applyEmbedStyles === 'function'
    ) {
      window.EmbedConfig.applyEmbedStyles();
    }

    if (window.stateManager && typeof setupViewListener === 'function') {
      setupViewListener();
    }
  }

  // =================================================================
  // --- Modal Management System ---
  // -----------------------------------------------------------------

  /**
   * モーダル管理オブジェクト
   * カプセル化された方式でモーダルのコールバック処理を管理する
   * グローバル変数の乱用を避けるための設計
   */
  window.ModalManager = window.ModalManager || {
    onConfirmCallback: null,

    /**
     * モーダル確認時のコールバック関数を設定
     * @param {() => void} callback - 確認ボタン押下時に実行する関数
     */
    setCallback: function (callback) {
      this.onConfirmCallback = callback;
    },

    /**
     * 設定されたコールバック関数をクリア
     */
    clearCallback: function () {
      this.onConfirmCallback = null;
    },

    /**
     * 設定されたコールバック関数を実行し、自動でクリアする
     * モーダル確認ボタンから呼び出される
     */
    executeCallback: function () {
      if (this.onConfirmCallback) {
        this.onConfirmCallback();
        this.clearCallback();
      }
    },
  };

  // =================================================================
  // --- Schedule Master Helper Functions ---
  // -----------------------------------------------------------------
  // 日程マスタデータから情報を取得するヘルパー関数群
  // フェーズ1: tuitionItemRule依存からの脱却のための新機能
  // =================================================================

  /**
   * 日程マスタから教室形式を取得します
   * @param {ScheduleInfo} scheduleData - 日程マスタのデータオブジェクト
   * @returns {string | null} 教室形式 ('時間制' | '回数制' | '材料制') またはnull
   */
  function getClassroomTypeFromSchedule(scheduleData) {
    if (!scheduleData) return null;
    return scheduleData['classroomType'] || scheduleData['教室形式'] || null;
  }

  /**
   * 教室形式が時間制かどうかを判定します
   * @param {ScheduleInfo} scheduleData - 日程マスタのデータオブジェクト
   * @returns {boolean} 時間制の場合true
   */
  function isTimeBasedClassroom(scheduleData) {
    const classroomType = getClassroomTypeFromSchedule(scheduleData);
    // 時間制の教室形式をすべてチェック（時間制・2部制、時間制・全日）
    return classroomType && classroomType.includes('時間制');
  }

  /**
   * バックエンドから特定の日程マスタ情報を取得
   * @param {string} date - 日付 (YYYY-MM-DD)
   * @param {string} classroom - 教室名
   * @returns {Promise<ScheduleInfo | null>} 日程マスタ情報またはnull
   */
  function getScheduleInfoFromCache(date, classroom) {
    return new Promise(resolve => {
      google.script.run['withSuccessHandler'](
        (
          /** @type {ServerResponse<{ scheduleInfo: ScheduleInfo }>} */ response,
        ) => {
          if (response.success && response.data) {
            console.log(
              '✅ getScheduleInfoFromCache: 日程マスタ情報取得成功',
              response.data.scheduleInfo,
            );
            resolve(response.data.scheduleInfo);
          } else {
            console.warn(
              '⚠️ getScheduleInfoFromCache: 日程マスタ情報が見つかりません',
              { date, classroom, message: response.message },
            );
            resolve(null);
          }
        },
      )
        ['withFailureHandler']((/** @type {Error} */ error) => {
          console.error('❌ getScheduleInfoFromCache: API呼び出しエラー', error);
          if (window.FrontendErrorHandler) {
            window.FrontendErrorHandler.handle(
              error,
              'getScheduleInfoFromCache',
              { date, classroom },
            );
          }
          resolve(null);
        })
        .getScheduleInfo({ date, classroom });
    });
  }

  /**
   * 予約データから対応する日程マスタ情報を取得
   * @param {ReservationData} reservation - 予約データ (date, classroom を含む)
   * @returns {ScheduleInfo | null} 日程マスタ情報またはnull (lessons経由の場合)
   */
  function getScheduleDataFromLessons(reservation) {
    if (!reservation || !reservation.date || !reservation.classroom) {
      console.warn(
        '⚠️ getScheduleDataFromLessons: 予約データが不正',
        reservation,
      );
      return null;
    }

    const state = stateManager.getState();
    const lessons = state.lessons;

    if (!lessons || !Array.isArray(lessons)) {
      console.warn(
        '⚠️ getScheduleDataFromLessons: lessonsが存在しません',
        lessons,
      );
      return null;
    }

    console.log('🔍 getScheduleDataFromLessons: 検索対象', {
      date: reservation.date,
      classroom: reservation.classroom,
      lessonsLength: lessons.length,
    });

    // 予約の日付と教室に対応する講座を検索
    const matchingLesson = lessons.find(
      lesson =>
        lesson.schedule.date === reservation.date &&
        lesson.schedule.classroom === reservation.classroom,
    );

    if (!matchingLesson) {
      console.warn(
        '⚠️ getScheduleDataFromLessons: 一致する講座が見つかりません',
        {
          date: reservation.date,
          classroom: reservation.classroom,
          availableLessons: lessons.map(l => ({
            date: l.schedule.date,
            classroom: l.schedule.classroom,
          })),
        },
      );
      return null;
    }

    console.log('✅ getScheduleDataFromLessons: 講座発見', matchingLesson);

    // 日程マスタ形式の情報を返す
    const schedule = /** @type {ScheduleInfo} */ (matchingLesson.schedule);
    return {
      classroom: reservation.classroom,
      date: reservation.date,
      classroomType: /** @type {string} */ (
        schedule.classroomType || schedule['教室形式']
      ),
      firstStart: /** @type {string} */ (
        schedule.firstStart || schedule['1部開始']
      ),
      firstEnd: /** @type {string} */ (schedule.firstEnd || schedule['1部終了']),
      secondStart: /** @type {string} */ (
        schedule.secondStart || schedule['2部開始']
      ),
      secondEnd: /** @type {string} */ (
        schedule.secondEnd || schedule['2部終了']
      ),
    };
  }


  // =================================================================
  // 12_WebApp_Core_ErrorHandler.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 12_WebApp_Core_ErrorHandler.js
   * 【バージョン】: 1.0
   * 【役割】: WebAppのフロントエンドにおける、統一エラーハンドリングシステムを
   * 集約します。ユーザー通知、開発環境でのデバッグ支援など。
   * 【構成】: 12_WebApp_Core.jsから分割されたエラーハンドリング専用ファイル
   * 【新規作成理由】:
   * - バックエンドとフロントエンドの完全分離
   * - エラーハンドリング機能の独立性向上
   * - TypeScript型競合の解決
   * =================================================================
   */

  /**
   * フロントエンド統一エラーハンドラー
   * ユーザーへの適切な通知とデバッグ情報の管理を行います
   */
  class FrontendErrorHandler {
    /**
     * エラーを処理し、ユーザーに適切に通知（パフォーマンス最適化版）
     * @param {Error} error - エラーオブジェクト
     * @param {string} context - エラーコンテキスト
     * @param {Object} [additionalInfo={}] - 追加情報
     */
    static handle(error, context = '', additionalInfo = {}) {
      // eslint-disable-line no-unused-vars
      // 軽量ログ出力（本番環境では最小限の情報のみ）
      if (!window.isProduction) {
        console.error(`[ERROR] ${context}: ${error.message}`);
      }
    }

    /**
     * 詳細エラーハンドリング（重要なエラーのみで使用）
     * @param {Error} error - エラーオブジェクト
     * @param {string} context - エラーコンテキスト
     * @param {Object} [additionalInfo={}] - 追加情報
     */
    static handleDetailed(error, context = '', additionalInfo = {}) {
      const errorInfo = {
        message: error.message || 'Unknown error',
        stack: error.stack || 'No stack trace available',
        context: context,
        timestamp: new Date().toISOString(),
        additionalInfo: additionalInfo,
        type: error.constructor.name || 'Error',
      };

      // 重要なエラーの場合は常に詳細ログを出力
      console.error(`[CRITICAL_FRONTEND_ERROR] ${context}:`, errorInfo);

      // ユーザー向けエラー通知
      const userMessage = this.getUserMessage(error, context);

      // エラーメッセージをユーザーに表示
      if (typeof window.showInfo === 'function') {
        window.showInfo(userMessage, 'エラー');
      } else if (typeof alert !== 'undefined') {
        alert(`エラー: ${userMessage}`);
      }

      // 本番環境では簡略化されたログのみ
      if (window.isProduction) {
        console.error(`[ERROR] ${context}: ${error.message}`);
      }
    }

    /**
     * コンテキストに応じた適切なユーザーメッセージを生成
     * @param {Error} error - エラーオブジェクト
     * @param {string} context - エラーコンテキスト
     * @returns {string} ユーザー向けメッセージ
     */
    static getUserMessage(error, context) {
      switch (context) {
        case 'server-error':
          return 'サーバーとの通信でエラーが発生しました。しばらく待ってからもう一度お試しください。';

        case 'network-error':
          return 'ネットワークエラーが発生しました。インターネット接続を確認してください。';

        case 'validation-error':
          return error.message || '入力内容に問題があります。';

        case 'authentication-error':
          return 'ログイン情報に問題があります。再度ログインしてください。';

        case 'permission-error':
          return 'この操作を実行する権限がありません。';

        case 'data-error':
          return 'データの処理でエラーが発生しました。';

        case 'global-error':
        case 'unhandled-promise-rejection':
          return '予期しないエラーが発生しました。ページを再読み込みしてみてください。';

        default:
          return error.message || 'エラーが発生しました。';
      }
    }

    /**
     * サーバーエラーの特別処理
     * サーバーから返される様々な形式のエラーを正規化して処理
     * @param {any} serverError - サーバーから返されたエラー
     */
    static handleServerError(serverError) {
      let error = serverError;

      // サーバーレスポンスの形式を正規化
      if (typeof serverError === 'string') {
        error = new Error(serverError);
      } else if (serverError && typeof serverError === 'object') {
        if (serverError.message) {
          error = new Error(serverError.message);
        } else if (serverError.error) {
          error = new Error(serverError.error);
        } else {
          error = new Error('サーバーエラーが発生しました');
        }
      } else if (!(serverError instanceof Error)) {
        error = new Error('不明なサーバーエラーが発生しました');
      }

      this.handle(error, 'server-error', {
        originalError: serverError,
        errorType: typeof serverError,
      });
    }

    /**
     * 非同期処理用のエラーハンドリング
     * Promise チェーンでの使用に最適化
     * @param {string} context - エラーコンテキスト
     * @returns {(error: Error) => void} エラーハンドリング関数
     */
    static createAsyncHandler(context) {
      return (/** @type {Error} */ error) => {
        this.handle(error, context);
      };
    }

    /**
     * 複数のエラーを一括処理
     * バッチ処理などで使用
     * @param {Error[]} errors - エラーの配列
     * @param {string} context - エラーコンテキスト
     */
    static handleMultiple(errors, context) {
      if (!Array.isArray(errors) || errors.length === 0) return;

      if (errors.length === 1) {
        this.handle(errors[0], context);
        return;
      }

      const combinedMessage = `複数のエラーが発生しました（${errors.length}件）`;
      const combinedError = new Error(combinedMessage);

      this.handle(combinedError, context, {
        errorCount: errors.length,
        errors: errors.map(e => ({
          message: e.message,
          type: e.constructor.name,
        })),
      });
    }

    /**
     * ユーザーフレンドリーなエラーメッセージを取得
     * TypedErrorHandler インターフェース実装
     * @param {Error} error - エラーオブジェクト
     * @param {string} context - エラーコンテキスト
     * @returns {string} ユーザー向けメッセージ
     */
    static getUserFriendlyMessage(error, context) {
      return this.getUserMessage(error, context);
    }

    /**
     * 重要なエラーかどうかを判定
     * TypedErrorHandler インターフェース実装
     * @param {Error} error - エラーオブジェクト
     * @returns {boolean} 重要なエラーの場合true
     */
    static isCriticalError(error) {
      const criticalErrors = ['TypeError', 'ReferenceError', 'SyntaxError'];
      return criticalErrors.includes(error.constructor.name);
    }

    /**
     * エラー情報をレポート
     * TypedErrorHandler インターフェース実装
     * @param {FrontendErrorInfo} errorInfo - エラー情報
     */
    static reportError(errorInfo) {
      // 既存のhandle メソッドと同様の処理
      const error = new Error(errorInfo.message);
      this.handle(
        error,
        errorInfo.context || 'unknown',
        errorInfo.additionalInfo || {},
      );
    }
  }

  /**
   * 既存のhandleServerError関数との完全互換性を保つラッパー関数
   * レガシーコードサポート用
   * @param {any} err - サーバーから返されたエラーオブジェクト
   */
  function handleServerError(err) {
    FrontendErrorHandler.handleServerError(err);
  }

  // グローバルエラーハンドラーの設定
  window.addEventListener('error', (/** @type {ErrorEvent} */ event) => {
    FrontendErrorHandler.handle(event.error, 'global-error', {
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    });
  });

  // Promise拒否エラーのハンドリング
  window.addEventListener(
    'unhandledrejection',
    (/** @type {PromiseRejectionEvent} */ event) => {
      FrontendErrorHandler.handle(
        new Error(event.reason),
        'unhandled-promise-rejection',
      );
    },
  );

  // デバッグ用: エラーハンドラーをグローバルに公開（開発環境のみ）
  if (!window.isProduction) {
    window.FrontendErrorHandler = FrontendErrorHandler;
  }


  // =================================================================
  // 12_WebApp_Core_Search.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 12_WebApp_Core_Search.js
   * 【バージョン】: 1.0
   * 【役割】: WebAppのフロントエンドにおける、統一検索システムを
   * 集約します。「よやく」と「きろく」を統一的に検索する機能。
   * 【構成】: 12_WebApp_Core.jsから分割された検索機能ファイル
   * 【新規作成理由】:
   * - メインコアファイルの肥大化対策
   * - 検索機能の独立性向上
   * - AIの作業効率向上のためのファイル分割
   * =================================================================
   */

  /**
   * =================================================================
   * --- 統一検索関数システム (2025-08-30) ---
   * 「よやく」(myBookings) と「きろく」(history) を統一的に検索する関数群
   * =================================================================
   */

  /**
   * 予約IDで「よやく」と「きろく」を統一的に検索します
   * @param {string} reservationId - 検索対象の予約ID
   * @param {UIState | null} [state=null] - stateManager.getState()の戻り値
   * @returns {ReservationSearchResult | null} 見つかった予約/記録データ、見つからない場合はnull
   */
  function findReservationById(reservationId, state = null) {
    const currentState = state || window.stateManager?.getState();
    if (!currentState) return null;

    // myReservationsから直接検索
    const reservation = currentState.myReservations?.find(
      item => item.reservationId === reservationId,
    );
    if (reservation) {
      // ステータスに基づいてtype分類を追加
      if (reservation.status === CONSTANTS.STATUS.COMPLETED) {
        return { ...reservation, type: 'record' };
      } else {
        return { ...reservation, type: 'booking' };
      }
    }

    return null;
  }

  /**
   * 日付と教室で「よやく」と「きろく」を統一的に検索します
   * @param {string} date - 検索対象の日付 (YYYY-MM-DD)
   * @param {string} classroom - 検索対象の教室名
   * @param {UIState | null} [state=null] - stateManager.getState()の戻り値
   * @returns {ReservationSearchResult | null} 見つかった予約/記録データ、見つからない場合はnull
   */
  function findReservationByDateAndClassroom(date, classroom, state = null) {
    const currentState = state || window.stateManager?.getState();
    if (!currentState) return null;

    // myReservationsから直接検索（キャンセル済みは既にバックエンドで除外済み）
    const reservation = currentState.myReservations?.find(
      item => item.date === date && item.classroom === classroom,
    );

    if (reservation) {
      // ステータスに基づいてtype分類を追加
      if (reservation.status === CONSTANTS.STATUS.COMPLETED) {
        return { ...reservation, type: 'record' };
      } else {
        return { ...reservation, type: 'booking' };
      }
    }

    return null;
  }

  /**
   * 指定されたステータスの予約/記録を検索します
   * @param {string} status - 検索対象のステータス
   * @param {UIState | null} [state=null] - stateManager.getState()の戻り値
   * @returns {ReservationSearchResult[]} 条件に合致する予約/記録の配列
   */
  function findReservationsByStatus(status, state = null) {
    const currentState = state || window.stateManager?.getState();
    if (!currentState) return [];

    // myReservationsから直接検索
    const reservations =
      currentState.myReservations?.filter(item => item.status === status) || [];

    // ステータスに基づいてtype分類を追加
    return reservations.map(item => {
      if (item.status === CONSTANTS.STATUS.COMPLETED) {
        return { ...item, type: 'record' };
      } else {
        return { ...item, type: 'booking' };
      }
    });
  }


  // =================================================================
  // 12_WebApp_StateManager.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 12_WebApp_StateManager.js
   * 【バージョン】: 2.1 (JavaScript分離開発版)
   * 【役割】: シンプルで確実な状態管理システム
   * - 無限ループの完全回避
   * - JavaScript分離開発環境対応
   * - 完全なTypeScript型チェック対応
   * =================================================================
   */

  /**
   * フロントエンド用PerformanceLogフォールバック
   * バックエンドで定義されたPerformanceLogがフロントエンドで未定義の場合の安全策
   */
  if (!window.PerformanceLog) {
    window.PerformanceLog = {
      debug(/** @type {string} */ message, /** @type {...any} */ ...args) {
        if (typeof debugLog === 'function') {
          debugLog(`[DEBUG] ${message}`);
        } else if (typeof console !== 'undefined') {
          console.log(`[DEBUG] ${message}`, ...args);
        }
      },
      info(/** @type {string} */ message, /** @type {...any} */ ...args) {
        if (typeof debugLog === 'function') {
          debugLog(`[INFO] ${message}`);
        } else if (typeof console !== 'undefined') {
          console.info(`[INFO] ${message}`, ...args);
        }
      },
      error(/** @type {string} */ message, /** @type {...any} */ ...args) {
        if (typeof console !== 'undefined') {
          console.error(`[ERROR] ${message}`, ...args);
        }
      },
    };
  }

  /**
   * シンプルな状態管理システム（リロード時状態保持対応）
   */
  class SimpleStateManager {
    constructor() {
      /** @type {string} */
      this.STORAGE_KEY = 'yoyaku_kiroku_state';

      /** @type {UIState} */
      this.state = {
        // --- User & Session Data ---
        /** @type {UserData | null} */
        currentUser: null,
        /** @type {string} */
        loginPhone: '',
        /** @type {boolean} */
        isFirstTimeBooking: false,
        /** @type {RegistrationFormData} */
        registrationData: {},
        /** @type {string | null} */
        registrationPhone: null,

        // --- Core Application Data ---
        /** @type {LessonData[]} */
        lessons: [],
        /** @type {ReservationData[]} */
        myReservations: [],
        /** @type {AccountingMasterData[]} */
        accountingMaster: [],

        // --- UI State ---
        /** @type {ViewType} */
        view: 'login',
        /** @type {string | null} */
        selectedClassroom: null,
        /** @type {Set<string>} 編集モード中の予約ID一覧 */
        editingReservationIds: new Set(),
        editingMemo: null, // { reservationId: string, originalValue: string } | null
        memoInputChanged: false,
        /** @type {LessonData | null} */
        selectedLesson: null,
        /** @type {ReservationDetails | null} */
        editingReservationDetails: null,
        /** @type {ReservationData | null} - 会計画面の基本予約情報 (ID, 教室, 日付など) */
        accountingReservation: null,
        /** @type {AccountingReservationDetails} - 予約固有の詳細情報 (開始時刻, レンタル, 割引など) */
        accountingReservationDetails: {},
        /** @type {ScheduleInfo | null} - 講座固有情報 (教室形式, 開講時間など) */
        accountingScheduleInfo: null,
        /** @type {AccountingCalculation | null} - 会計計算結果 */
        accountingDetails: null,
        /** @type {string} */ completionMessage: '',
        /** @type {number} */ recordsToShow: 10,
        /** @type {number} */ registrationStep: 1,
        /** @type {UserData[]} */
        searchedUsers: [],
        /** @type {boolean} */
        searchAttempted: false,

        // --- New Context for Forms ---
        /** @type {ReservationFormContext | null} - 予約フォーム専用コンテキスト */
        currentReservationFormContext: null,

        // --- Navigation History ---
        /** @type {StateNavigationHistoryEntry[]} */
        navigationHistory: [],

        // --- System State ---
        /** @type {boolean} */
        isDataFresh: false,
        /** @type {boolean} */
        _dataUpdateInProgress: false,
        /** @type {string | null} */
        _lessonsVersion: null,
        /** @type {Record<string, boolean>} データタイプ別取得中フラグ */
        _dataFetchInProgress: /** @type {Record<string, boolean>} */ ({}),
        /** @type {Record<string, number>} データタイプ別最終更新時刻 */
        _dataLastUpdated: /** @type {Record<string, number>} */ ({}),

        // --- Computed Data ---
        /** @type {ComputedStateData} */
        computed: {},
      };

      /** @type {boolean} 無限ループ防止フラグ */
      this.isUpdating = false;
      /** @type {StateSubscriber[]} 状態変更の購読者リスト */
      this.subscribers = [];
      /** @type {number | null} 自動保存タイマーID */
      this._saveTimeout = null;

      // 【リロード対応】ページロード時に保存状態を復元
      this.restoreStateFromStorage();
    }

    /**
     * アクションをディスパッチして状態を更新し、UIを自動再描画
     * @param {StateAction} action - アクションオブジェクト { type: ActionType, payload?: StateActionPayload }
     */
    dispatch(action) {
      if (this.isUpdating) {
        console.warn('状態更新中のため処理をスキップ');
        return;
      }

      if (!window.isProduction) {
        console.log(
          '🎯 Action dispatched:',
          action.type,
          action.payload ? Object.keys(action.payload) : 'no payload',
        );
      }

      // 現在のビューを記録（ページ遷移判定用）
      const previousView = this.state.view;

      // アクションに基づいて状態更新
      let newState = {};
      switch (action.type) {
        case 'SET_STATE':
          newState = action.payload || {};
          break;
        case 'UPDATE_STATE':
          newState = action.payload || {};
          break;
        case 'CHANGE_VIEW':
          newState = { view: action.payload.view };
          break;
        case 'NAVIGATE':
          newState = this._handleNavigate(action.payload);
          break;
        default:
          console.warn('未知のアクションタイプ:', action.type);
          return;
      }

      // 内部の状態更新メソッドを呼び出し
      this._updateState(newState);

      // ページ遷移が発生した場合のスクロール管理
      if (
        'view' in newState &&
        newState.view &&
        newState.view !== previousView &&
        window.pageTransitionManager
      ) {
        const viewValue = /** @type {ViewType} */ (newState.view);
        window.pageTransitionManager.onPageTransition(viewValue);
      }

      // 最終的な状態更新（画面遷移を伴う）でのみローディング非表示を実行
      const isViewChange =
        'view' in newState && newState.view && newState.view !== previousView;
      const hasSubstantialData =
        ('lessons' in newState && newState.lessons) ||
        ('myReservations' in newState && newState.myReservations) ||
        ('currentUser' in newState && newState.currentUser);
      const isFinalUpdate =
        action.type === 'SET_STATE' && (isViewChange || hasSubstantialData);

      if (isFinalUpdate) {
        this._shouldHideLoadingAfterRender = true;
      }

      // UI を自動で再描画
      this._scheduleRender();
    }

    /**
     * 状態を更新（内部メソッド）
     * @param {Partial<UIState>} newState - 新しい状態
     */
    _updateState(newState) {
      if (this.isUpdating) {
        console.warn('状態更新中のため処理をスキップ');
        return;
      }

      this.isUpdating = true;

      try {
        // 変更前の状態を保存（subscriber用）
        const oldState = { ...this.state };

        // 状態を直接更新
        Object.assign(this.state, newState);

        // 基本的な計算済みデータ更新
        this.updateComputed();

        // subscriberに変更を通知
        this._notifySubscribers(this.state, oldState);

        // 【リロード対応】重要な状態変更時は自動保存
        this._autoSaveIfNeeded(oldState, newState);

        if (!window.isProduction) {
          if (
            typeof ENVIRONMENT_CONFIG !== 'undefined' &&
            typeof ENVIRONMENT_CONFIG.DEBUG_ENABLED !== 'undefined' &&
            ENVIRONMENT_CONFIG.DEBUG_ENABLED
          )
            console.log('✅ 状態更新完了:', Object.keys(newState));
        }
      } catch (error) {
        console.error('❌ 状態更新エラー:', error);
      } finally {
        this.isUpdating = false;
      }
    }

    /**
     * 計算済みデータの基本更新
     */
    updateComputed() {
      if (!this.state.myReservations) return;

      // isFirstTimeBooking の計算：予約データが全くない場合
      this.state.isFirstTimeBooking = this.state.myReservations.length === 0;
    }

    /**
     * requestAnimationFrameを使ったレンダリングスケジューリング
     */
    _scheduleRender() {
      if (this._renderScheduled) {
        return; // 既にスケジュール済み
      }

      this._renderScheduled = true;
      requestAnimationFrame(() => {
        this._renderScheduled = false;
        if (typeof window.render === 'function') {
          console.log('🎨 Auto-rendering UI...');
          window.render();
          // 特定のaction.typeでのみローディングを非表示（最終的な状態更新のみ）
          if (this._shouldHideLoadingAfterRender) {
            if (typeof hideLoading === 'function') hideLoading();
            this._shouldHideLoadingAfterRender = false;
          }
        } else {
          console.warn('render関数が見つかりません');
        }
      });
    }

    /**
     * 現在の状態を取得
     * @returns {UIState} 現在の状態
     */
    getState() {
      return this.state;
    }

    /**
     * 状態変更を購読する
     * @param {StateSubscriber} callback - 状態変更時に呼び出される関数 (newState, oldState) => void
     * @returns {() => void} unsubscribe関数
     */
    subscribe(callback) {
      this.subscribers.push(callback);

      // unsubscribe関数を返す
      return () => {
        const index = this.subscribers.indexOf(callback);
        if (index > -1) {
          this.subscribers.splice(index, 1);
        }
      };
    }

    /**
     * subscriberに状態変更を通知する
     * @param {UIState} newState - 新しい状態
     * @param {UIState} oldState - 古い状態
     */
    _notifySubscribers(newState, oldState) {
      this.subscribers.forEach(callback => {
        try {
          callback(newState, oldState);
        } catch (error) {
          console.error('subscriber callback error:', error);
        }
      });
    }

    /**
     * ナビゲーションアクションを処理し、履歴を管理する
     * @param {StateActionPayload} payload - { to: ViewType, context?: NavigationContext, saveHistory?: boolean }
     * @returns {Partial<UIState>} 新しい状態
     */
    _handleNavigate(payload) {
      const { to, context = {}, saveHistory = true } = payload;
      const currentView = this.state.view;

      // 現在のビューを履歴に保存（もどる履歴として）
      if (saveHistory && currentView !== to) {
        const currentContext = this._extractCurrentContext();
        const historyEntry = { view: currentView, context: currentContext };

        // 同じビューの連続エントリを避ける
        const lastEntry =
          this.state.navigationHistory[this.state.navigationHistory.length - 1];
        if (!lastEntry || lastEntry.view !== currentView) {
          const newHistory = [...this.state.navigationHistory, historyEntry];
          // 履歴を最大10件に制限
          if (newHistory.length > 10) {
            newHistory.shift();
          }
          return {
            view: to,
            ...context,
            navigationHistory: newHistory,
          };
        }
      }

      return {
        view: to,
        ...context,
      };
    }

    /**
     * 現在のビューのコンテキストを抽出する
     * @returns {NavigationContext} コンテキストオブジェクト
     */
    _extractCurrentContext() {
      const context = {};

      // ビューに応じて重要な状態を保存
      switch (this.state.view) {
        case 'bookingLessons':
          if (this.state.selectedClassroom) {
            context.selectedClassroom = this.state.selectedClassroom;
          }
          break;
        case 'newReservation':
        case 'editReservation':
          if (this.state.selectedLesson) {
            context.selectedLesson = this.state.selectedLesson;
            context.selectedClassroom = this.state.selectedClassroom;
          }
          if (this.state.editingReservationDetails) {
            context.editingReservationDetails =
              this.state.editingReservationDetails;
          }
          break;
        case 'accounting':
          if (this.state.accountingReservation) {
            context.accountingReservation = this.state.accountingReservation;
          }
          break;
        default:
          break;
      }

      return context;
    }

    /**
     * 前のビューにもどる
     * @returns {Partial<UIState>} 新しい状態、または戻れない場合はnull
     */
    goBack() {
      const history = this.state.navigationHistory;
      if (history.length === 0) {
        console.log('ナビゲーション履歴が空です - ホームに戻ります');
        return { view: 'dashboard' };
      }

      const previousEntry = history[history.length - 1];
      const newHistory = history.slice(0, -1); // 最後のエントリを削除

      return {
        view: previousEntry.view,
        ...previousEntry.context,
        navigationHistory: newHistory,
      };
    }

    /**
     * 編集モードを開始する
     * @param {string} reservationId - 予約ID
     * @param {string} [originalMemo=''] - 編集前のメモ内容
     */
    startEditMode(reservationId, originalMemo = '') {
      this.state.editingReservationIds.add(reservationId);
      // 同期的状態更新のみ実行（dispatch不要でチラツキ防止）
      this.state.editingMemo = { reservationId, originalValue: originalMemo };
      this.state.memoInputChanged = false;
    }

    /**
     * メモの変更状態を更新する（同期的に実行）
     * @param {string} reservationId - 予約ID
     * @param {string} currentValue - 現在のメモ内容
     */
    updateMemoInputChanged(reservationId, currentValue) {
      const editingMemo = this.state.editingMemo;
      if (editingMemo && editingMemo.reservationId === reservationId) {
        const hasChanged = currentValue !== editingMemo.originalValue;
        if (this.state.memoInputChanged !== hasChanged) {
          // 同期的に状態を更新（UI全体再描画を避けるため、dispatchを使わない）
          this.state.memoInputChanged = hasChanged;

          return hasChanged; // 変更状態を返す
        }
      }
      return this.state.memoInputChanged; // 現在の状態を返す
    }

    /**
     * 編集モードを終了する
     * @param {string} reservationId - 予約ID
     */
    endEditMode(reservationId) {
      this.state.editingReservationIds.delete(reservationId);
      if (
        this.state.editingMemo &&
        this.state.editingMemo.reservationId === reservationId
      ) {
        // 同期的状態更新のみ実行（dispatch不要でチラツキ防止）
        this.state.editingMemo = null;
        this.state.memoInputChanged = false;
      }
    }

    /**
     * 指定された予約が編集モードかチェック
     * @param {string} reservationId - 予約ID
     * @returns {boolean}
     */
    isInEditMode(reservationId) {
      return this.state.editingReservationIds.has(reservationId);
    }

    /**
     * すべての編集モードをクリア
     */
    clearAllEditModes() {
      this.state.editingReservationIds.clear();
      this.dispatch({
        type: 'UPDATE_STATE',
        payload: {
          editingMemo: null,
          memoInputChanged: false,
        },
      });
    }
    /**
     * 自動保存判定 - 重要な状態が変更された時のみ保存
     * @param {UIState} oldState - 変更前の状態
     * @param {Partial<UIState>} newState - 変更された部分
     * @private
     */
    _autoSaveIfNeeded(oldState, newState) {
      // ログイン画面に戻る場合は保存状態をクリア（ログアウト扱い）
      if (
        'view' in newState &&
        newState.view === 'login' &&
        oldState.view !== 'login'
      ) {
        window.PerformanceLog?.info('ログイン画面に戻るため保存状態をクリア');
        this.clearStoredState();
        return;
      }

      // 保存対象となる重要な状態変更
      const importantChanges = [
        'currentUser',
        'loginPhone',
        'view',
        'selectedClassroom',
        'isFirstTimeBooking',
        'registrationData',
        'registrationPhone',
      ];

      const hasImportantChange = importantChanges.some(
        key => key in newState && oldState[key] !== newState[key],
      );

      if (hasImportantChange) {
        // 500ms後に保存（連続変更をまとめるため）
        clearTimeout(this._saveTimeout);
        this._saveTimeout = setTimeout(() => {
          this.saveStateToStorage();
        }, 500);
      }
    }

    /**
     * リロード時状態保持機能 - 状態をSessionStorageに保存
     * ブラウザタブが開いている間のみ保持（タブ閉じで自動クリア）
     */
    saveStateToStorage() {
      try {
        // Setオブジェクトは直接JSON化できないため、Arrayに変換
        const stateToSave = {
          ...this.state,
          editingReservationIds: Array.from(this.state.editingReservationIds),
        };

        // 保存対象の状態のみを選択（大量データは除外）
        const essentialState = {
          currentUser: stateToSave.currentUser,
          loginPhone: stateToSave.loginPhone,
          view: stateToSave.view,
          selectedClassroom: stateToSave.selectedClassroom,
          isFirstTimeBooking: stateToSave.isFirstTimeBooking,
          registrationData: stateToSave.registrationData,
          registrationPhone: stateToSave.registrationPhone,
          editingReservationIds: stateToSave.editingReservationIds,
          // タイムスタンプを追加（有効期限チェック用）
          savedAt: Date.now(),
        };

        sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(essentialState));
        window.PerformanceLog?.debug('状態をSessionStorageに保存しました');
      } catch (error) {
        window.PerformanceLog?.error(`状態保存エラー: ${error.message}`);
      }
    }

    /**
     * リロード時状態保持機能 - SessionStorageから状態を復元
     * @returns {boolean} 復元が成功したかどうか
     */
    restoreStateFromStorage() {
      try {
        const savedState = sessionStorage.getItem(this.STORAGE_KEY);
        if (!savedState) {
          window.PerformanceLog?.debug('保存された状態がありません');
          return false;
        }

        const parsedState = JSON.parse(savedState);

        // 有効期限チェック（6時間以内）
        const sixHoursInMs = 6 * 60 * 60 * 1000;
        if (Date.now() - parsedState.savedAt > sixHoursInMs) {
          window.PerformanceLog?.debug('保存された状態が期限切れです');
          sessionStorage.removeItem(this.STORAGE_KEY);
          return false;
        }

        // 状態を復元（マージ）
        this.state = {
          ...this.state,
          ...parsedState,
          editingReservationIds: new Set(parsedState.editingReservationIds || []),
        };

        // savedAtは内部データなので削除
        delete this.state.savedAt;

        window.PerformanceLog?.info('状態をSessionStorageから復元しました');
        return true;
      } catch (error) {
        window.PerformanceLog?.error(`状態復元エラー: ${error.message}`);
        sessionStorage.removeItem(this.STORAGE_KEY);
        return false;
      }
    }

    /**
     * 状態保存を無効にする（ログアウト時など）
     */
    clearStoredState() {
      try {
        sessionStorage.removeItem(this.STORAGE_KEY);
        window.PerformanceLog?.debug('保存された状態をクリアしました');
      } catch (error) {
        window.PerformanceLog?.error(`状態クリアエラー: ${error.message}`);
      }
    }

    /**
     * 講座データの更新が必要かチェック
     * @param {number} [cacheExpirationMinutes=10] - キャッシュ有効期限（分）
     * @returns {boolean} 更新が必要な場合true
     */
    needsLessonsUpdate(cacheExpirationMinutes = 10) {
      // 安全な初期化
      if (!this._dataFetchInProgress) {
        this._dataFetchInProgress = {};
      }
      if (!this._dataLastUpdated) {
        this._dataLastUpdated = {};
      }

      // 現在講座データ取得中の場合はfalse
      if (
        /** @type {Record<string, boolean>} */ (this._dataFetchInProgress)[
          'lessons'
        ]
      ) {
        window.PerformanceLog?.debug('講座データ取得中のため更新スキップ');
        return false;
      }

      // 講座データが存在しない場合は更新必要
      if (
        !this.state.lessons ||
        !Array.isArray(this.state.lessons) ||
        this.state.lessons.length === 0
      ) {
        window.PerformanceLog?.debug('講座データが存在しないため更新必要');
        return true;
      }

      // 最終更新時刻チェック
      const lastUpdated = /** @type {Record<string, number>} */ (
        this._dataLastUpdated
      )['lessons'];
      if (!lastUpdated) {
        window.PerformanceLog?.debug(
          '講座データの更新時刻が未設定のため更新必要',
        );
        return true;
      }

      const expirationTime = cacheExpirationMinutes * 60 * 1000; // ミリ秒に変換
      const isExpired = Date.now() - lastUpdated > expirationTime;

      if (isExpired) {
        window.PerformanceLog?.debug(
          `講座データキャッシュが期限切れ（${cacheExpirationMinutes}分経過）`,
        );
        return true;
      }

      window.PerformanceLog?.debug('講座データキャッシュは有効');
      return false;
    }

    /**
     * データタイプの取得状態を管理
     * @param {string} dataType - データタイプ（'lessons', 'reservations'など）
     * @param {boolean} isInProgress - 取得中かどうか
     */
    setDataFetchProgress(dataType, isInProgress) {
      // 安全な初期化
      if (!this._dataFetchInProgress) {
        this._dataFetchInProgress = {};
      }
      if (!this._dataLastUpdated) {
        this._dataLastUpdated = {};
      }

      /** @type {Record<string, boolean>} */ (this._dataFetchInProgress)[
        dataType
      ] = isInProgress;

      if (!isInProgress) {
        // 取得完了時に更新時刻を記録
        /** @type {Record<string, number>} */ (this._dataLastUpdated)[dataType] =
          Date.now();
        window.PerformanceLog?.debug(
          `${dataType}データ取得完了：${new Date().toLocaleTimeString()}`,
        );
      } else {
        window.PerformanceLog?.debug(`${dataType}データ取得開始`);
      }
    }

    /**
     * 特定のデータタイプが取得中かチェック
     * @param {string} dataType - データタイプ
     * @returns {boolean} 取得中の場合true
     */
    isDataFetchInProgress(dataType) {
      // 安全な初期化
      if (!this._dataFetchInProgress) {
        this._dataFetchInProgress = {};
      }
      return !!(
        /** @type {Record<string, boolean>} */ (this._dataFetchInProgress)[
          dataType
        ]
      );
    }

    /**
     * 講座データのキャッシュバージョンを更新
     * @param {string} newVersion - 新しいバージョン
     */
    updateLessonsVersion(newVersion) {
      if (this.state._lessonsVersion !== newVersion) {
        this.state._lessonsVersion = newVersion;
        this.setDataFetchProgress('lessons', false);
        window.PerformanceLog?.debug(`講座データバージョンを更新: ${newVersion}`);
      }
    }
  }

  // グローバルインスタンスを作成
  window.stateManager = new SimpleStateManager();


  // =================================================================
  // 13_WebApp_Components.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 13_WebApp_Components.js
   * 【バージョン】: 2.0 (シンプル化設計版)
   * 【役割】: WebAppのUIコンポーネント生成関数を集約します。
   * - 再利用可能なUIコンポーネントの定義
   * - シンプル化されたパラメータ設計
   * - 3層構造: Atomic → Molecular → Organisms
   * 【構成】: 14ファイル構成のうちの13番目（新規追加）
   * 【設計原則】:
   * - 単一責任原則: 1コンポーネント = 1つの明確な責任
   * - 最小パラメータ: 本質的なデータのみ受け取る
   * - 関心の分離: UIコンポーネントとビジネスデータを分離
   * - 組み合わせ可能: 小さな部品の組み合わせで複雑な画面を構築
   */

  // =================================================================
  // --- HTML Escape Utility ---
  // -----------------------------------------------------------------
  // HTMLエスケープ機能（12_WebApp_Core.htmlから移動）
  // =================================================================

  /**
   * HTML文字列をエスケープします。
   * @param {string | number | boolean} str - エスケープする文字列、数値、真偽値
   * @returns {string} エスケープされた文字列
   */
  window.escapeHTML = /** @type {HTMLEscapeFunction} */ (
    str => {
      if (typeof str !== 'string') {
        return String(str);
      }
      return str.replace(/[&<>"']/g, function (match) {
        /** @type {Record<string, string>} */
        const escapeMap = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
        };
        return escapeMap[match] || match;
      });
    }
  );

  // =================================================================
  // --- Level 1: 基本要素（Atomic Components） ---
  // -----------------------------------------------------------------
  // 最小単位のUIコンポーネント。単一責任でパラメータ最小化。
  // =================================================================

  const Components = {
    /**
     * 汎用モーダルコンポーネントを生成します
     * @param {ModalConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    modal: config => {
      const maxWidth = config.maxWidth || 'max-w-sm';
      const showCloseButton = config.showCloseButton !== false;

      return `
          <div id="${escapeHTML(config.id)}" class="modal-fade fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden" onclick="Components.closeModalOnBackdrop(event, '${escapeHTML(config.id)}')">
            <div class="bg-white rounded-lg ${maxWidth} mx-4 max-h-[90vh] overflow-y-auto" onclick="Components.handleModalContentClick(event)" data-modal-content="true">
              <div class="flex justify-between items-center p-4 border-b-2 border-ui-border">
                <h2 class="text-xl font-bold text-brand-text">${escapeHTML(config.title)}</h2>
                ${showCloseButton ? `<button onclick="Components.closeModal('${escapeHTML(config.id)}')" class="text-gray-500 hover:text-gray-700 text-2xl font-bold leading-none">&times;</button>` : ''}
              </div>
              <div class="p-4">
                ${config.content}
              </div>
            </div>
          </div>`;
    },

    /**
     * モーダルを表示します（フェードインアニメーション付き）
     * @param {string} modalId - モーダルのID
     */
    showModal: modalId => {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.classList.remove('hidden');
        // フェードインアニメーションのための遅延
        requestAnimationFrame(() => {
          modal.classList.add('active');
        });
        // フォーカストラップの設定
        const focusableElements = modal.querySelectorAll(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
        );
        if (focusableElements.length > 0) {
          const firstElement = /** @type {HTMLElement} */ (focusableElements[0]);
          if (firstElement && typeof firstElement.focus === 'function') {
            firstElement.focus();
          }
        }
      }
    },

    /**
     * モーダルを非表示にします（フェードアウトアニメーション付き）
     * @param {string} modalId - モーダルのID
     */
    closeModal: modalId => {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.classList.remove('active');
        // フェードアウトアニメーション完了後に完全に非表示にする
        setTimeout(() => {
          modal.classList.add('hidden');
        }, 300); // CSS transitionと同じ時間
      }
    },

    /**
     * 背景クリックでモーダルを閉じる処理
     * @param {Event} event - クリックイベント
     * @param {string} modalId - モーダルのID
     */
    closeModalOnBackdrop: (event, modalId) => {
      if (event.target === event.currentTarget) {
        Components.closeModal(modalId);
      }
    },

    /**
     * モーダルコンテンツ内のクリック処理
     * ボタンなどのインタラクティブ要素はイベントを継続し、その他では伝播を停止
     * @param {Event} event - クリックイベント
     */
    handleModalContentClick: event => {
      // ボタンまたはdata-action要素の場合はイベントを継続
      const actionElement = event.target.closest('button, [data-action]');
      if (actionElement) {
        // ボタンクリックの場合は伝播を継続（外側のハンドラーで処理）
        return;
      }
      // それ以外の場合は伝播を停止
      event.stopPropagation();
    },

    /**
     * 進化版ボタンコンポーネント
     * @param {ButtonConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    button: ({
      action,
      text,
      style = 'primary',
      size = 'normal',
      disabled = false,
      customClass = '',
      dataAttributes = {},
      id = '',
      disabledStyle = 'auto', // 'auto', 'none', 'custom'
    }) => {
      // スタイルマッピング
      const styleClasses = {
        primary: DesignConfig.colors['primary'],
        secondary: DesignConfig.colors['secondary'],
        danger: DesignConfig.colors['danger'],
        accounting: DesignConfig.colors['accounting'],
        bookingCard: DesignConfig.buttons['bookingCard'],
        recordCard: DesignConfig.buttons['recordCard'],
      };

      /** @type {Record<ComponentSize, string>} */
      const sizeClasses = {
        normal: '',
        full: DesignConfig.buttons['full'],
        small: 'text-sm px-3 py-1.5',
        xs: 'text-xs px-2 py-1',
        large: 'text-lg px-4 py-2.5',
      };

      // データ属性をHTML文字列に変換
      const dataAttrs = Object.entries(dataAttributes)
        .map(
          ([key, value]) =>
            `data-${key.replace(/([A-Z])/g, '-$1').toLowerCase()}="${escapeHTML(String(value))}"`,
        )
        .join(' ');

      // スタイルが'none'の場合は基本クラスを最小限にする
      const baseClass = style === 'none' ? '' : DesignConfig.buttons['base'];
      const styleClass = style === 'none' ? '' : styleClasses[style] || '';

      const sizeClass = size && sizeClasses[size] ? sizeClasses[size] : '';

      // 無効状態の自動スタイル適用
      let disabledClass = '';
      let inlineStyle = '';

      if (disabled && disabledStyle === 'auto') {
        // 自動無効状態スタイル：視覚的に押せないことを明確にする
        disabledClass = 'opacity-60 cursor-not-allowed';
        inlineStyle =
          'pointer-events: none; background-color: #d1d5db !important; color: #6b7280 !important; border-color: #d1d5db !important;';
      }

      // ID属性の生成
      const idAttr = id ? `id="${escapeHTML(id)}"` : '';

      return `<button type="button"
          ${idAttr}
          data-action="${escapeHTML(action || '')}"
          class="${[baseClass, styleClass, sizeClass, disabledClass, customClass || ''].filter(Boolean).join(' ')}"
          ${dataAttrs}
          ${disabled ? 'disabled' : ''}
          ${inlineStyle ? `style="${inlineStyle}"` : ''}
        >${text}</button>`;
    },

    /**
     * シンプル化された入力フィールドコンポーネント
     * @param {InputConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    input: ({
      id,
      label,
      type = 'text',
      value = '',
      placeholder = '',
      required = false,
    }) => {
      // 電話番号・メールの場合は専用クラスを使用
      const inputClass =
        type === 'tel' || type === 'email'
          ? /** @type {any} */ (DesignConfig.inputs)['phone'] ||
            DesignConfig.inputs['base']
          : DesignConfig.inputs['base'];

      return `<div class="mb-4">
          <label
            for="${id}"
            class="${DesignConfig.text['labelBlock']}"
          >${escapeHTML(label)}</label>
          <input
            type="${type}"
            id="${id}"
            value="${escapeHTML(value)}"
            class="${inputClass}"
            placeholder="${escapeHTML(placeholder)}"
            ${required ? 'required' : ''}
            autocomplete="off"
          >
        </div>`;
    },

    /**
     * シンプル化されたセレクトボックスコンポーネント
     * @param {SelectConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    select: ({ id, label, options }) => {
      return `<div class="mb-4">
          <label for="${id}" class="${DesignConfig.text['labelBlock']}">${escapeHTML(label)}</label>
          <select
            id="${id}"
            class="${DesignConfig.inputs['base']}"
          >${options}</select>
        </div>`;
    },

    /**
     * テキストエリアコンポーネント
     * @param {TextareaConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    textarea: ({ id, label, value = '', placeholder = '', rows = 5 }) => {
      return `<div class="mb-4">
          <label for="${id}" class="${DesignConfig.text['labelBlock']}">${escapeHTML(label)}</label>
          <textarea
            id="${id}"
            class="${DesignConfig.inputs['textarea']}"
            placeholder="${escapeHTML(placeholder)}"
            rows="${rows}"
          >${escapeHTML(value)}</textarea>
        </div>`;
    },

    /**
     * チェックボックスコンポーネント
     * @param {CheckboxConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    checkbox: ({
      id,
      label,
      checked = false,
      disabled = false,
      dynamicStyle = false,
      dataAttributes = {},
    }) => {
      // 動的スタイル用のクラス設定
      const labelClass = dynamicStyle
        ? checked
          ? 'font-bold text-brand-text'
          : 'text-brand-muted'
        : DesignConfig.colors['text'];

      // disabledの場合のスタイル調整
      const finalLabelClass = disabled
        ? `${labelClass} opacity-50 cursor-not-allowed`
        : labelClass;

      // data属性を文字列として生成
      const dataAttributesString = Object.entries(dataAttributes)
        .map(([key, value]) => `data-${key}="${escapeHTML(String(value))}"`)
        .join(' ');

      return `<label class="flex items-center space-x-2 ${finalLabelClass}">
          <input
            type="checkbox"
            id="${id}"
            ${checked ? 'checked' : ''}
            ${disabled ? 'disabled' : ''}
            class="accent-action-primary-bg"
            ${dynamicStyle ? 'data-dynamic-style="true"' : ''}
            ${dataAttributesString}
          >
          <span>${label}</span>
        </label>`;
    },

    // =================================================================
    // --- UI統一化コンポーネント ---
    // -----------------------------------------------------------------

    /**
     * 統一ページコンテナ
     * @param {PageContainerConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    pageContainer: ({ content, maxWidth = '2xl' }) => {
      return `<div class="max-w-${maxWidth} mx-auto px-4">${content}</div>`;
    },

    /**
     * 統一カードコンテナ
     * @param {CardContainerConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    cardContainer: ({
      content,
      variant = 'default',
      padding = 'normal',
      touchFriendly = false,
      customClass = '',
      dataAttributes = '',
    }) => {
      const variants = {
        default: DesignConfig.cards.background,
        highlight: 'bg-blue-50 border-blue-200',
        success: 'bg-green-50 border-green-200',
        warning: 'bg-yellow-50 border-yellow-200',
        available: `${DesignConfig.cards.base} ${DesignConfig.cards.state.available.card}`,
        waitlist: `${DesignConfig.cards.base} ${DesignConfig.cards.state.waitlist.card}`,
        booked: `${DesignConfig.cards.base} ${DesignConfig.cards.state.booked.card}`,
        history: `record-card ${DesignConfig.cards.state.history.card}`,
      };

      const paddings = {
        compact: 'p-2',
        normal: 'p-3',
        spacious: 'p-4',
      };

      // タッチフレンドリー対応
      const touchClass = touchFriendly
        ? 'touch-friendly transition-all duration-150'
        : '';

      // 状態バリエーションではDesignConfig.cards.baseが含まれている
      const baseClasses = ['available', 'waitlist', 'booked', 'history'].includes(
        variant,
      )
        ? ''
        : 'rounded-lg border-2';

      const finalClasses =
        `${variants[variant]} ${paddings[padding]} ${baseClasses} ${touchClass} ${customClass}`.trim();

      return `<div class="${finalClasses}" ${dataAttributes}>
        ${content}
      </div>`;
    },

    // =================================================================
    // --- 新設計コンポーネント ---
    // -----------------------------------------------------------------

    /**
     * ステータスバッジ
     * @param {StatusBadgeConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    statusBadge: ({ type, text }) => {
      const typeClasses = {
        success: 'bg-state-success-bg text-state-success-text',
        warning: 'bg-ui-warning-bg text-ui-warning-text',
        error: 'bg-ui-error-bg text-ui-error-text',
        info: 'bg-action-secondary-bg text-action-secondary-text',
      };

      return `<span class="inline-block px-1 py-0.5 text-sm font-bold rounded ${typeClasses[type] || typeClasses.info}">${escapeHTML(text)}</span>`;
    },

    /**
     * 拡張料金表示コンポーネント
     * @param {PriceDisplayConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    priceDisplay: ({
      amount,
      label = '',
      size = 'normal',
      style = 'default',
      showCurrency = true,
      align = 'right',
    }) => {
      const sizes = {
        small: 'text-sm',
        normal: 'text-base',
        large: 'text-xl',
      };

      const styles = {
        default: 'text-brand-text',
        highlight: 'text-brand-text font-semibold',
        subtotal: 'text-brand-text font-semibold text-lg',
        total: 'text-brand-text font-bold text-xl',
      };

      // 負の値の場合は赤い文字色を適用
      const isNegative = typeof amount === 'number' && amount < 0;
      const negativeClass = isNegative ? 'text-red-600' : '';

      const aligns = {
        left: 'text-left',
        center: 'text-center',
        right: 'text-right',
      };

      const formattedAmount =
        typeof amount === 'number' ? amount.toLocaleString() : amount;
      const currency = showCurrency ? '¥' : '';

      // サイズに応じて価格表示の幅クラスを決定
      let priceWidthClass = '';
      if (size === 'large') {
        priceWidthClass = 'large';
      } else if (size === 'small') {
        priceWidthClass = 'small';
      }

      return `<span class="${aligns[align] || aligns.right}">
          ${label ? `<span class="text-brand-subtle text-sm">${escapeHTML(label)}: </span>` : ''}
          <span class="${sizes[size] || sizes.normal} ${negativeClass || styles[style] || styles.default} price-amount ${priceWidthClass}">${currency}${formattedAmount}</span>
        </span>`;
    },

    /**
     * 統一ボタンセクション
     * @param {ActionButtonSectionConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    actionButtonSection: ({
      primaryButton,
      secondaryButton,
      dangerButton,
      layout = 'vertical',
      spacing = 'normal',
    }) => {
      const buttons = [secondaryButton, primaryButton, dangerButton]
        .filter(btn => btn)
        .map(btn =>
          Components.button({
            ...btn,
            size: btn.size || (layout === 'horizontal' ? 'large' : 'full'),
          }),
        );

      if (buttons.length === 0) return '';

      const layoutClasses = {
        vertical: 'flex flex-col',
        horizontal: 'flex justify-between items-center gap-4',
      };

      const spacingClasses = {
        compact: layout === 'vertical' ? 'space-y-2' : '',
        normal: layout === 'vertical' ? 'space-y-3' : '',
        spacious: layout === 'vertical' ? 'space-y-4' : '',
      };

      return `<div class="mt-8 ${layoutClasses[layout] || layoutClasses.vertical} ${spacingClasses[spacing] || spacingClasses.normal}">
        ${buttons.join('')}
      </div>`;
    },

    // =================================================================
    // --- ページヘッダー ---
    // -----------------------------------------------------------------

    /**
     * ページヘッダー（タイトル + もどるボタン）
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.title - ページタイトル
     * @param {string} [config.backAction='smartGoBack'] - もどるボタンのアクション
     * @param {boolean} [config.showBackButton=true] - もどるボタンを表示するか
     * @returns {string} HTML文字列
     */
    pageHeader: ({
      title,
      backAction = 'smartGoBack',
      showBackButton = true,
    }) => {
      const backButtonHtml = showBackButton
        ? Components.button({
            action: backAction,
            text: 'もどる',
            style: 'secondary',
            size: 'xs',
            customClass: 'mobile-button',
          })
        : '';

      return `
        <div class="sticky top-0 bg-white border-b-2 border-ui-border z-10 py-3 mb-4 -mx-4">
          <div class="flex justify-between items-center px-4">
            <h1 class="text-lg font-bold text-brand-text">${escapeHTML(title)}</h1>
            ${backButtonHtml}
          </div>
        </div>`;
    },

    // =================================================================
    // --- 会計系専用コンポーネント ---
    // -----------------------------------------------------------------

    /**
     * 会計項目行（チェックボックス付き）
     * @param {AccountingRowConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    accountingRow: ({
      name,
      itemType,
      price,
      checked = false,
      disabled = false,
    }) => {
      return `<div class="flex items-center justify-between mb-2">
          <label class="flex items-center space-x-2 text-brand-text">
            <input type="checkbox"
                   name="${name}"
                   data-item-type="${itemType}"
                   data-item-name="${name}"
                   class="accounting-item h-5 w-5 rounded border-ui-border text-brand-text focus:ring-brand-text accent-action-primary-bg"
                   ${checked ? 'checked' : ''}
                   ${disabled ? 'disabled' : ''}>
            <span>${escapeHTML(name)}</span>
          </label>
          <span class="text-brand-subtle">¥${price.toLocaleString()}</span>
        </div>`;
    },

    /**
     * 材料入力行
     * @param {MaterialRowConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    materialRow: ({ index, values = {} }) => {
      const { type = '', l = '', w = '', h = '' } = values;

      // マスターデータから材料オプションを動的に生成
      let materialOptions = '';
      try {
        const master = window.stateManager?.getState?.()?.accountingMaster;
        if (master && Array.isArray(master)) {
          materialOptions = master
            .filter(
              m =>
                m[CONSTANTS.HEADERS.ACCOUNTING.TYPE] ===
                CONSTANTS.ITEM_TYPES.MATERIAL,
            )
            .map(
              m =>
                `<option value="${escapeHTML(m[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME])}" ${type === m[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME] ? 'selected' : ''}>${escapeHTML(m[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME])}</option>`,
            )
            .join('');
        }
      } catch (e) {
        // フォールバック: 静的オプション
        const staticOptions = ['桂', 'シナ', '檜', '楠', '桜', '朴', 'その他'];
        materialOptions = staticOptions
          .map(
            option =>
              `<option value="${option}" ${type === option ? 'selected' : ''}>${option}</option>`,
          )
          .join('');
      }

      return `<div data-material-row-index="${index}">
          <div class="grid grid-cols-1 gap-y-2">
            <select id="material-type-${index}" name="materialType${index}" class="${DesignConfig.inputs.base} accounting-item">
              <option value="">-- 樹種を選択 --</option>
              ${materialOptions}
            </select>
          </div>
          <div class="grid grid-cols-4 gap-2 mt-2 items-center">
            <input type="number" id="material-l-${index}" name="materialL${index}" value="${l || ''}" placeholder="縦(mm)" step="5" class="${DesignConfig.inputs.base} accounting-item custom-placeholder">
            <input type="number" id="material-w-${index}" name="materialW${index}" value="${w || ''}" placeholder="横(mm)" step="5" class="${DesignConfig.inputs.base} accounting-item custom-placeholder">
            <input type="number" id="material-h-${index}" name="materialH${index}" value="${h || ''}" placeholder="厚(mm)" step="5" class="${DesignConfig.inputs.base} accounting-item custom-placeholder">
            <div id="material-price-${index}" class="text-right text-base text-brand-subtle">¥0</div>
          </div>
        </div>`;
    },

    /**
     * その他販売項目行
     * @param {OtherSalesRowConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    otherSalesRow: ({ index, values = {} }) => {
      const { name = '', price = '' } = values;
      return `<div data-other-sales-row="${index}" class="mt-2 pt-2 border-t border-ui-border grid grid-cols-3 gap-2 items-center">
          <input type="text" id="other-sales-name-${index}" name="otherSalesName${index}" value="${escapeHTML(name)}" placeholder="商品名" class="col-span-2 ${DesignConfig.inputs.base} accounting-item">
          <input type="text" inputted="decimal" id="other-sales-price-${index}" name="otherSalesPrice${index}" value="${price}" placeholder="金額" class="${DesignConfig.inputs.base} accounting-item">
        </div>`;
    },

    /**
     * 統一された授業料セクション（セッション制ベース、時間制対応）
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.type - 授業料タイプ（'timeBased' | 'fixed'）
     * @param {AccountingMasterData[]} config.master - 会計マスター
     * @param {ReservationData} config.reservation - 予約データ
     * @param {ReservationData} config.reservationDetails - 予約固有情報
     * @param {ScheduleInfo} config.scheduleInfo - 講座固有情報
     * @returns {string} HTML文字列
     */
    unifiedTuitionSection: ({
      type,
      master,
      reservation,
      reservationDetails,
      scheduleInfo,
    }) => {
      // isFirstTimeBooking をstateManagerから取得
      const state = stateManager.getState();
      const isFirstTimeBooking = state['isFirstTimeBooking'];

      // 使用する授業料項目を決定（初回授業料 or 基本授業料）
      const targetItemName = isFirstTimeBooking
        ? CONSTANTS.ITEMS.FIRST_LECTURE
        : CONSTANTS.ITEMS.MAIN_LECTURE;

      // 時間制の場合のみ時間選択UIを追加
      let timeSelectionHtml = '';
      if (type === 'timeBased' && scheduleInfo) {
        if (!scheduleInfo.firstStart || !scheduleInfo.firstEnd) {
          return `<div class="text-ui-error-text p-4 bg-ui-error-bg rounded-lg">エラー: この教室の講座時間が設定されていません。</div>`;
        }

        // 講座時間の設定
        const startParts = scheduleInfo.firstStart.split(':');
        const endParts = scheduleInfo.firstEnd.split(':');
        const classStart = parseInt(startParts[0] || '0');
        const classEnd = parseInt(endParts[0] || '0');
        const endBuffer = 3;

        // 時間プルダウンのオプション生成
        const startTimeOptions = getTimeOptionsHtml(
          classStart,
          classEnd + endBuffer,
          30,
          reservationDetails.startTime || '',
        );
        const endTimeOptions = getTimeOptionsHtml(
          classStart,
          classEnd + endBuffer,
          30,
          reservationDetails.endTime || '',
        );
        const breakOptions = [...Array(5).keys()]
          .map(
            i =>
              `<option value="${i * 30}" ${String(i * 30) === (reservationDetails['breakTime'] || '0') ? 'selected' : ''}>${i * 30}分</option>`,
          )
          .join('');

        timeSelectionHtml = `
          <div class="mb-4 p-4 bg-gray-50 rounded-lg border">
            <h4 class="text-sm font-medium text-gray-700 mb-3">参加時間を選択してください</h4>
            <div class="grid grid-cols-3 gap-2 items-end">
              <div class="col-span-1">
                ${Components.select({
                  id: 'start-time',
                  label: '開始時刻',
                  options: startTimeOptions,
                })}
              </div>
              <div class="col-span-1">
                ${Components.select({
                  id: 'end-time',
                  label: '終了時刻',
                  options: endTimeOptions,
                })}
              </div>
              <div class="col-span-1">
                ${Components.select({
                  id: 'break-time',
                  label: '休憩時間',
                  options: breakOptions,
                })}
              </div>
            </div>
            <div id="calculated-hours" class="text-left text-base ${DesignConfig.colors['textSubtle']} mt-2"></div>
          </div>`;
      }

      const tuitionItems = Array.isArray(master)
        ? master.filter(
            /** @param {AccountingMasterData} item */
            item =>
              item[CONSTANTS.HEADERS.ACCOUNTING.TYPE] ===
                CONSTANTS.ITEM_TYPES.TUITION &&
              (item[CONSTANTS.HEADERS.ACCOUNTING.TARGET_CLASSROOM] === '共通' ||
                item[CONSTANTS.HEADERS.ACCOUNTING.TARGET_CLASSROOM]?.includes(
                  reservation.classroom,
                )),
          )
        : [];

      const tuitionRowsHtml = tuitionItems
        .map(
          /** @param {AccountingMasterData} item */ item => {
            const itemName = item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME];

            // メイン授業料項目の処理（初回参加時は差し替え）
            if (itemName === targetItemName) {
              return Components.accountingRow({
                name: itemName,
                itemType: CONSTANTS.ITEM_TYPES.TUITION,
                price: item[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE],
                checked: true,
                disabled: true,
              });
            }

            // 使わない授業料項目をスキップ
            if (
              (itemName === CONSTANTS.ITEMS.FIRST_LECTURE &&
                !isFirstTimeBooking) ||
              (itemName === CONSTANTS.ITEMS.MAIN_LECTURE && isFirstTimeBooking)
            ) {
              return '';
            }

            // その他の項目（彫刻刀レンタルなど）
            const isChecked = !!(
              reservationDetails && reservationDetails[itemName]
            );

            return Components.accountingRow({
              name: itemName,
              itemType: CONSTANTS.ITEM_TYPES.TUITION,
              price: item[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE],
              checked: isChecked,
              disabled: false,
            });
          },
        )
        .filter(html => html !== '')
        .join('');

      return Components.cardContainer({
        variant: 'default',
        padding: 'spacious',
        content: `
          <div class="space-y-3">
            <h3 class="${DesignConfig.text['heading']} mb-2">授業料</h3>

            ${timeSelectionHtml}
            <div class="space-y-3">${tuitionRowsHtml}</div>

            <div id="tuition-breakdown" class="mt-4 pt-4 border-t border-ui-border space-y-1 text-base ${DesignConfig.colors['textSubtle']}"></div>
            <div class="text-right font-bold mt-2" id="tuition-subtotal">小計: ¥0</div>
          </div>
        `,
      });
    },

    /**
     * セクションヘッダーコンポーネント
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.title - ヘッダータイトル
     * @param {string} [config.symbol='■'] - 先頭記号
     * @param {boolean} [config.asSummary=false] - サマリー表示スタイル
     * @returns {string} HTML文字列
     */
    sectionHeader: ({ title, symbol = '■', asSummary = false }) => {
      const baseClasses = 'text-lg font-bold text-brand-text';

      if (asSummary) {
        // summaryの場合は▶記号のみ使用（二重記号を避ける）
        // スマホユーザー向けに押しやすく、分かりやすいデザイン
        return `<summary class="${baseClasses} flex items-center justify-between hover:bg-ui-hover active:bg-ui-pressed transition-colors">
          <div class="flex items-center">
            <span class="mr-3 text-brand-accent transition-transform">▶</span>
            ${escapeHTML(title)}
          </div>
          <span class="text-xs text-brand-subtle rounded-md bg-ui-surface border-2 border-ui-border p-1">タップで展開</span>
        </summary>`;
      }

      // 通常のh3の場合は指定されたsymbolを使用
      const content = `${escapeHTML(symbol)} ${escapeHTML(title)}`;
      return `<h3 class="${baseClasses} mb-3">${content}</h3>`;
    },

    /**
     * 小計表示セクションコンポーネント
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.title - 小計タイトル
     * @param {number} config.amount - 小計金額
     * @param {string} [config.id=''] - 金額表示要素のID
     * @returns {string} HTML文字列
     */
    subtotalSection: ({ title, amount, id = '' }) => {
      return `<div class="subtotal mt-4 pt-3 border-t border-ui-border text-right">
        <span class="text-lg font-bold text-brand-text">${escapeHTML(title)}: </span>
        <span ${id ? `id="${escapeHTML(id)}"` : ''} class="text-lg font-bold text-brand-text">${Components.priceDisplay({ amount, size: 'large' })}</span>
      </div>`;
    },

    /**
     * 時刻選択用のselect options生成
     * @param {Object} config - 設定オブジェクト
     * @param {string} [config.startTime='09:00'] - 開始時刻
     * @param {string} [config.endTime='17:00'] - 終了時刻
     * @param {number} [config.interval=30] - 間隔（分）
     * @param {string} [config.selectedValue=''] - 選択済みの値
     * @returns {string} HTML文字列
     */
    timeOptions: ({
      startTime = '09:00',
      endTime = '17:00',
      interval = 30,
      selectedValue = '',
    }) => {
      const options = [];
      const [startHour, startMin] = startTime.split(':').map(Number);
      const [endHour, endMin] = endTime.split(':').map(Number);

      const startMinutes = startHour * 60 + startMin;
      const endMinutes = endHour * 60 + endMin;

      for (
        let minutes = startMinutes;
        minutes <= endMinutes;
        minutes += interval
      ) {
        const hour = Math.floor(minutes / 60);
        const min = minutes % 60;
        const timeString = `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
        const selected = timeString === selectedValue ? 'selected' : '';
        options.push(
          `<option value="${timeString}" ${selected}>${timeString}</option>`,
        );
      }

      return options.join('');
    },

    // =================================================================
    // --- Level 3: 画面セクション（Organisms） ---
    // -----------------------------------------------------------------
    // 複合的なUIセクション（ホーム、予約一覧等）
    // =================================================================

    /**
     * ホームセクション（予約または履歴）
     * @param {DashboardSectionConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    dashboardSection: ({
      title,
      items,
      showNewButton = false,
      newAction,
      showMoreButton = false,
      moreAction,
    }) => {
      let newButtonHtml = '';
      if (showNewButton && newAction) {
        newButtonHtml = Components.newReservationCard({ action: newAction });
      }

      const itemsHtml = items.join('');

      let moreButtonHtml = '';
      if (showMoreButton && moreAction) {
        moreButtonHtml = `<div class="text-center mt-4">
            ${Components.button({ action: moreAction, text: 'もっとみる', style: 'secondary', size: 'small' })}
          </div>`;
      }

      return `
          <div class="mb-8 w-full">
            <div class="bg-ui-surface border-2 border-ui-border p-3 rounded-lg space-y-3">
              <h2 class="text-xl font-medium text-brand-text text-center mb-2">${escapeHTML(title)}</h2>
              ${newButtonHtml}
              ${itemsHtml}
              ${moreButtonHtml}
            </div>
          </div>
        `;
    },

    /**
     * 新規予約カード（ホーム用）
     * @param {ComponentConfig & {action: string}} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    newReservationCard: ({ action }) => {
      return `
          <div data-action="${action}" class="w-full p-4 rounded-lg border-2 border-dashed border-action-primary-border bg-action-primary-light cursor-pointer mobile-card touch-friendly">
            <div class="text-center">
              <span class="text-xl font-bold text-action-primary-bg">+ あたらしく よやく する</span>
            </div>
          </div>
        `;
    },

    /**
     * 統一カードレイアウト（予約・履歴共通）- 純粋描画層
     * @param {ListCardConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    listCard: ({
      item,
      badges = [],
      editButtons = [],
      accountingButtons = [],
      type = 'booking',
      isEditMode = false,
      showMemoSaveButton = true,
    }) => {
      // カード基本スタイル
      const cardColorClass =
        type === 'booking'
          ? `booking-card ${DesignConfig.cards.state.booked.card}`
          : `record-card ${DesignConfig.cards.state.history.card}`;

      // バッジHTML生成
      const badgesHtml = badges
        .map(badge =>
          Components.statusBadge({
            type: /** @type {BadgeType} */ (badge.type),
            text: badge.text,
          }),
        )
        .join('');

      // 編集ボタンHTML生成
      const editButtonsHtml = editButtons
        .map(btn =>
          Components.button({
            action: btn.action,
            text: btn.text,
            style: /** @type {ComponentStyle} */ (
              btn.style || (type === 'booking' ? 'bookingCard' : 'recordCard')
            ),
            size: /** @type {ComponentSize} */ (btn.size || 'xs'),
            //          customClass: 'mobile-button',
            dataAttributes: {
              classroom: item.classroom,
              reservationId: item.reservationId,
              date: item.date,
              ...(btn.details && { details: JSON.stringify(btn.details) }),
            },
          }),
        )
        .join('');

      // 会計ボタンHTML生成
      const accountingButtonsHtml = accountingButtons
        .map(btn =>
          Components.button({
            action: btn.action,
            text: btn.text,
            style: /** @type {ComponentStyle} */ (btn.style || 'accounting'),
            size: /** @type {ComponentSize} */ ('xs'),
            //          customClass: `mobile-button ${DesignConfig.colors.accounting}`,
            dataAttributes: {
              classroom: item.classroom,
              reservationId: item.reservationId,
              date: item.date,
              ...(btn.details && { details: JSON.stringify(btn.details) }),
            },
          }),
        )
        .join('');

      // 日時・会場表示
      const dateTimeDisplay = item.startTime
        ? ` <span class="time-display">${item.startTime}~${item.endTime}</span>`.trim()
        : '';
      const classroomDisplay = item.classroom ? ` ${item.classroom}` : '';
      const venueDisplay = item.venue ? ` ${item.venue}` : '';

      // 制作メモ表示（予約・履歴共通） - 編集モード対応
      const memoSection = Components.memoSection({
        reservationId: item.reservationId,
        workInProgress: item.workInProgress,
        isEditMode: isEditMode, // パラメータで制御
        showSaveButton: showMemoSaveButton, // 保存ボタン表示制御
      });

      return `
        <div class="w-full mb-4 px-0">
          <div class="${cardColorClass} p-2 rounded-lg shadow-sm" data-reservation-id="${item.reservationId}">
            <!-- 上部：教室情報+会計・編集ボタン -->
            <div class="flex justify-between items-start mb-0">
              <div class="flex-1 min-w-0">
                <div class="flex items-center flex-wrap">
                  <h3 class="font-bold text-brand-text">${formatDate(item.date)} <span class="font-normal text-brand-subtle text-sm">${dateTimeDisplay}</span></h3>
                </div>
                <h4 class="text-sm text-brand-text font-bold mt-0">${escapeHTML(classroomDisplay)}${escapeHTML(venueDisplay)} ${badgesHtml}</h4>
              </div>
              ${accountingButtonsHtml || editButtonsHtml ? `<div class="flex-shrink-0 self-start flex gap-1">${accountingButtonsHtml}${editButtonsHtml}</div>` : ''}
            </div>

            ${memoSection}
          </div>
        </div>
      `;
    },

    /**
     * 制作メモセクション（表示・編集両対応）
     * @param {MemoSectionConfig} config - 設定オブジェクト
     * @returns {string} HTML文字列
     */
    memoSection: ({
      reservationId,
      workInProgress,
      isEditMode = false,
      showSaveButton = true, // eslint-disable-line no-unused-vars
    }) => {
      if (isEditMode) {
        // 編集モード：textareaと保存ボタン
        const textareaId = `memo-edit-textarea-${reservationId}`;
        return `
          <div class="p-0.5 bg-white/75">
            <h4 class="text-xs font-bold text-brand-subtle mb-0">制作メモ</h4>
            <textarea
              id="${textareaId}"
              class="memo-edit-textarea ${DesignConfig.inputs.textarea} min-h-14 w-full mt-1 px-1"
              rows="4"
              placeholder="制作内容や進捗をメモしてね"
              data-reservation-id="${reservationId}"
            >${escapeHTML(workInProgress || '')}</textarea>
          </div>
        `;
      } else {
        // 通常モード：読み取り専用表示
        return `
          <div class="p-0.5 bg-white/75">
            <h4 class="text-xs font-bold text-brand-subtle mb-0">制作メモ</h4>
            <p class="text-sm text-brand-text whitespace-pre-wrap px-1 min-h-14">${escapeHTML(workInProgress)}</p>
          </div>
        `;
      }
    },

    /**
     * 販売セクション
     * @param {Object} config - 設定オブジェクト
     * @param {AccountingMasterData[]} config.master - 会計マスター
     * @param {ReservationData} config.reservationDetails - 予約固有情報
     * @returns {string} HTML文字列
     */
    salesSection: ({ master, reservationDetails }) => {
      const salesItems = Array.isArray(master)
        ? master.filter(
            /** @param {AccountingMasterData} item */
            item =>
              item[CONSTANTS.HEADERS.ACCOUNTING.TYPE] ===
              CONSTANTS.ITEM_TYPES.SALES,
          )
        : [];
      const salesItemsHtml = salesItems
        .map(item => {
          // truthy値でチェック状態を判定（より柔軟）
          const isChecked = !!(
            reservationDetails &&
            reservationDetails[item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME]]
          );

          return Components.accountingRow({
            name: item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME],
            itemType: CONSTANTS.ITEM_TYPES.SALES,
            price: item[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE],
            checked: isChecked,
          });
        })
        .join('');

      return `<div class="p-4 bg-ui-surface border-2 border-ui-border rounded-lg">
          <h3 class="text-xl font-bold mb-3 text-left text-brand-text">販売</h3>
          <div class="mb-3 space-y-4">
            <label class="block text-brand-text text-base font-bold">材料代</label>
            <div id="materials-container">
              ${Components.materialRow({
                index: 0,
                values: {
                  type: reservationDetails?.materialType0,
                  l: reservationDetails?.materialL0,
                  w: reservationDetails?.materialW0,
                  h: reservationDetails?.materialH0,
                },
              })}
            </div>
          </div>
          ${Components.button({ action: 'addMaterialRow', text: '+ 材料を追加', style: 'secondary', size: 'full' })}
          <details class="mt-4">
            <summary class="font-bold text-brand-text flex items-center">
              <span class="arrow mr-2">▶</span> その他の販売品
            </summary>
            <div class="mt-2 space-y-2 pt-2 border-t border-ui-border">
              ${salesItemsHtml}
              <div id="other-sales-container" class="mt-2 pt-2 border-t border-ui-border">
                ${Components.otherSalesRow({
                  index: 0,
                  values: {
                    name: reservationDetails?.otherSalesName0,
                    price: reservationDetails?.otherSalesPrice0,
                  },
                })}
              </div>
            </div>
            ${Components.button({ action: 'addOtherSalesRow', text: '+ 自由入力欄を追加', style: 'secondary', size: 'full' })}
          </details>
          <div class="text-right font-bold mt-2 text-brand-text" id="sales-subtotal">小計: ¥0</div>
        </div>`;
    },

    /**
     * 右上固定配置のもどるボタンを生成します
     * @param {string} action - アクション名（デフォルト: 'smartGoBack'）
     * @param {string} text - ボタンテキスト（デフォルト: 'もどる'）
     * @returns {string} HTML文字列
     */
    createBackButton: (action = 'smartGoBack', text = 'もどる') => {
      return `
          <div class="back-button-container fixed top-4 right-4 z-30">
            <button
              data-action="${escapeHTML(action)}"
              class="bg-action-secondary-bg text-action-secondary-text active:bg-action-secondary-hover font-bold py-2 px-4 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly shadow-lg"
            >
              ${escapeHTML(text)}
            </button>
          </div>`;
    },

    /**
     * 現在のビューに応じて適切なもどるボタンを生成します
     * @param {string} currentView - 現在のビュー名
     * @param {UIState|null} appState - アプリケーション状態
     * @returns {string} HTML文字列
     */
    createSmartBackButton: (currentView, appState = null) => {
      // eslint-disable-line no-unused-vars
      // 現在のビューに応じてアクションとテキストを決定
      let action = 'smartGoBack';
      let text = 'もどる';

      // 特定のビューでの動作をカスタマイズ
      switch (currentView) {
        case 'bookingSuccess':
          action = 'goToMainMenu';
          text = 'メインメニュー';
          break;
        case 'history':
          action = 'goToMainMenu';
          text = 'メインメニュー';
          break;
        default:
          action = 'smartGoBack';
          text = 'もどる';
      }

      return Components.createBackButton(action, text);
    },
  };

  // =================================================================
  // --- Specialized Components ---
  // -----------------------------------------------------------------
  // 特定用途に特化したコンポーネント
  // =================================================================

  /**
   * 右上固定配置のもどるボタンを生成します
   * @param {string} action - アクション名（デフォルト: 'smartGoBack'）
   * @param {string} text - ボタンテキスト（デフォルト: 'もどる'）
   * @returns {string} HTML文字列
   */
  Components.createBackButton = (action = 'smartGoBack', text = 'もどる') => {
    return `
        <div class="back-button-container fixed top-4 right-4 z-30">
          <button
            data-action="${escapeHTML(action)}"
            class="bg-action-secondary-bg text-action-secondary-text active:bg-action-secondary-hover font-bold py-2 px-4 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly shadow-lg"
          >
            ${escapeHTML(text)}
          </button>
        </div>`;
  };

  /**
   * 現在のビューに応じて適切なもどるボタンを生成します
   * @param {string} currentView - 現在のビュー名
   * @returns {string} HTML文字列
   */
  Components.createSmartBackButton = currentView => {
    let action = 'smartGoBack';
    let text = 'もどる';

    // ビューに応じて適切なアクションとテキストを設定
    switch (currentView) {
      case 'login':
        // ログイン画面ではもどるボタンを表示しない
        return '';

      case 'register':
        text = 'ログインへ';
        action = 'goBackToLogin';
        break;

      case 'registrationStep2':
        text = '前へ';
        action = 'backToStep1';
        break;

      case 'registrationStep3':
        text = '前へ';
        action = 'backToStep2';
        break;

      case 'registrationStep4':
        text = '前へ';
        action = 'backToStep3';
        break;

      case 'dashboard':
        // ダッシュボードではもどるボタンを表示しない
        return '';

      case 'bookingLessons':
        text = 'ホーム';
        action = 'goBackToDashboard';
        break;

      case 'newReservation':
        text = '予約一覧';
        action = 'goBackToBooking';
        break;

      case 'editReservation':
        text = 'ホーム';
        action = 'goBackToDashboard';
        break;

      case 'accounting':
        text = 'ホーム';
        action = 'goBackToDashboard';
        break;

      case 'complete':
        text = 'ホーム';
        action = 'goBackToDashboard';
        break;

      default:
        // デフォルトはスマートもどる
        break;
    }

    return Components.createBackButton(action, text);
  };

  // =================================================================
  // --- レガシー互換性サポート ---
  // -----------------------------------------------------------------
  // 既存のコード互換性を維持するための旧式コンポーネント
  // 段階的移行期間中のみ使用
  // =================================================================

  // =================================================================
  // --- モーダルコンポーネント ---
  // -----------------------------------------------------------------
  // 汎用モーダル機能
  // =================================================================

  // 注意: createBackButton と createSmartBackButton は Components オブジェクト内で定義済み

  // グローバルに公開
  window.Components = Components;


  // =================================================================
  // 13_WebApp_Views_Auth.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 13_WebApp_Views_Auth.js
   * 【バージョン】: 1.0
   * 【役割】: 認証関連のビュー（ログイン、新規登録、プロフィール編集）を管理
   * 【構成】: Views.jsから分割された認証関連機能
   * =================================================================
   */

  // =================================================================
  // --- Authentication Views ---
  // -----------------------------------------------------------------
  // ログイン、新規登録、プロフィール編集に関連するビュー関数群
  // =================================================================

  /**
   * ログイン画面
   * 【主要機能】電話番号入力による認証とユーザー識別
   * @returns {HTMLString} ログイン画面のHTML文字列
   */
  const getLoginView = () => {
    const phoneValue = stateManager.getState()['loginPhone'] || '';
    return Components.pageContainer({
      maxWidth: 'md',
      content: `
        <div class="text-center pt-8 pb-4">
            <h1 class="text-3xl font-bold text-brand-text tracking-tight">きぼりの<br>よやく・きろく</h1>
            <h2 class="text-xl text-brand-subtle mt-2 mb-10">川崎誠二 木彫り教室</h2>
        </div>
        <div class="${DesignConfig.inputs.container}">
          <label for="phone" class="block text-brand-subtle text-base text-center mb-2">携帯電話番号</label>
          <div class="flex justify-center">
            <input
              type="tel"
              id="phone"
              value="${phoneValue}"
              class="${DesignConfig.inputs.phone} text-center"
              placeholder="090 1234 5678"
              autocomplete="tel"
              inputmode="numeric"
              pattern="[0-9]*"
            >
          </div>
        </div>
        ${Components.actionButtonSection({
          primaryButton: {
            action: 'login',
            text: 'ログイン または 新規登録',
            style: 'primary',
          },
          spacing: 'normal',
        })}
      `,
    });
  };

  /**
   * ユーザー情報入力フォーム（新規登録・プロフィール編集共通）
   * 【統合設計】新規登録と編集を1つの関数で処理する効率的な実装
   * @param {UserFormConfig} config - 設定オブジェクト
   * @returns {HTMLString} HTML文字列
   */
  const getUserFormView = config => {
    const { mode, phone } = config;
    const isEdit = mode === 'edit';
    const u = stateManager.getState().currentUser || {};

    // 入力値の保持: 新規登録Step1ではstateManager.getState().registrationDataを参照
    let regData = /** @type {RegistrationFormData} */ (
      stateManager.getState()['registrationData'] || {}
    );
    const userData = /** @type {UserData} */ (u);
    const realNameValue = isEdit
      ? userData.realName || ''
      : regData.realName || '';
    const nicknameValue = isEdit
      ? userData.displayName || ''
      : regData.nickname || '';
    const phoneValue = isEdit
      ? stateManager.getState().registrationPhone || userData.phone || ''
      : regData.phone || phone || '';

    // 電話番号表示の判定
    const isPhoneInputNeeded =
      isEdit && (stateManager.getState().registrationPhone || !userData.phone);

    // タイトルと説明文
    const title = isEdit ? 'プロフィール編集' : '新規登録';
    const description = isEdit
      ? ''
      : '<p class="text-brand-subtle mb-6">お名前を登録してください。</p>';

    // 電話番号セクション
    let phoneSection = '';
    if (!isEdit) {
      // 新規登録時：電話番号を表示のみ
      const formattedPhoneValue =
        typeof formatPhoneNumberForDisplay === 'function'
          ? formatPhoneNumberForDisplay(phoneValue)
          : phoneValue;
      phoneSection = `
          <div class="mb-4">
              <label class="block text-brand-text text-base font-bold mb-2">携帯電話番号</label>
              <input type="tel" id="reg-phone" value="${formattedPhoneValue}" class="${DesignConfig.inputs.phone}" placeholder="090 1234 5678" autocomplete="tel" inputmode="numeric" pattern="[0-9]*">
          </div>`;
    } else if (isPhoneInputNeeded) {
      // プロフィール編集時：電話番号入力が必要
      const formattedPhoneValue =
        typeof formatPhoneNumberForDisplay === 'function'
          ? formatPhoneNumberForDisplay(phoneValue)
          : phoneValue;
      phoneSection = `
          <div class="mb-4">
              <label for="edit-phone" class="block text-brand-text text-base font-bold mb-2">携帯電話番号</label>
              <input type="tel" id="edit-phone" value="${formattedPhoneValue}"
                     class="${DesignConfig.inputs.phone}" placeholder="090 1234 5678"
                     autocomplete="tel" inputmode="numeric" pattern="[0-9]*">
              <p class="text-sm text-brand-subtle mt-1">携帯電話番号を登録すると次回からスムーズにログインできます。</p>
          </div>`;
    } else {
      // プロフィール編集時：電話番号表示のみ
      const formattedPhoneValue =
        typeof formatPhoneNumberForDisplay === 'function'
          ? formatPhoneNumberForDisplay(phoneValue)
          : phoneValue;
      phoneSection = `
          <div class="mb-4">
              <label class="block text-brand-text text-base font-bold mb-2">携帯電話番号</label>
              <p class="font-semibold p-3 bg-ui-surface text-brand-text rounded-lg w-auto inline-block"><span class="font-mono-numbers">${formattedPhoneValue}</span></p>
          </div>`;
    }

    // メール設定セクション（プロフィール編集時のみ）
    const emailSection = isEdit
      ? `
          <div class="space-y-4">
            ${Components.input({
              id: 'edit-email',
              label: 'メールアドレス',
              type: 'email',
              value: /** @type {UserData} */ (u).email || '',
              placeholder: 'example@email.com',
            })}
            <div class="p-3 bg-ui-surface rounded-md">
              <label class="flex items-center space-x-3">
                <input type="checkbox" id="edit-wants-email"
                       class="h-5 w-5 accent-action-primary-bg"
                       ${/** @type {UserData} */ (u).wantsEmail ? 'checked' : ''}>
                <span class="text-brand-text text-sm">メール連絡を希望します（教室日程、予約受付、など）**初回予約時は、すべての方へ連絡します**</span>
              </label>
            </div>
          </div>
        `
      : '';

    // ボタン設定
    // ボタン設定を統一フォーマットで定義
    const buttonConfig = isEdit
      ? {
          secondaryButton: {
            text: 'もどる',
            action: 'smartGoBack',
            style: /** @type {ComponentStyle} */ ('secondary'),
          },
          primaryButton: {
            text: 'この内容で更新',
            action: 'saveProfile',
            style: /** @type {ComponentStyle} */ ('primary'),
          },
        }
      : {
          secondaryButton: {
            text: 'もどる',
            action: 'goBackToLogin',
            style: /** @type {ComponentStyle} */ ('secondary'),
          },
          primaryButton: {
            text: 'すすむ',
            action: 'goToStep2',
            style: /** @type {ComponentStyle} */ ('primary'),
          },
        };

    const nameIdPrefix = isEdit ? 'edit' : 'reg';

    return Components.pageContainer({
      maxWidth: 'md',
      content: `
        <h1 class="text-xl font-bold text-brand-text text-center mb-4">${title}</h1>
        ${description}
        <form id="${isEdit ? 'edit-profile-form' : 'register-step1-form'}" class="space-y-4">
          ${Components.input({
            id: `${nameIdPrefix}-realname`,
            label: 'お名前 *必須項目*',
            type: 'text',
            required: true,
            value: realNameValue,
            containerClass: '',
            autocomplete: 'name',
          })}
          ${Components.input({
            id: `${nameIdPrefix}-nickname`,
            label: 'ニックネーム（表示名）',
            caption: '他の生徒さんにも表示されます',
            type: 'text',
            value: nicknameValue,
            placeholder: '空欄の場合はお名前',
            containerClass: '',
          })}
          ${phoneSection}
          ${emailSection}
        </form>

        ${Components.actionButtonSection({
          ...buttonConfig,
          layout: 'horizontal',
        })}
      `,
    });
  };

  /**
   * 新規登録画面（ステップ1）
   * 【設計方針】userFormViewへの簡潔なラッパー
   * @param {PhoneNumber} p - 電話番号
   * @returns {HTMLString} HTML文字列
   */
  const getRegisterView = p => getUserFormView({ mode: 'register', phone: p });

  /**
   * 新規登録フローのステップ2（プロフィール詳細）
   * 【設計方針】ステップ式登録により、ユーザー負担を軽減
   * @returns {string} プロフィール詳細フォームのHTML文字列
   */
  const getRegistrationStep2View = () => {
    const data = /** @type {RegistrationFormData} */ (
      stateManager.getState()['registrationData']
    );
    const genderOptions = ['女性', '男性', 'その他']
      .map(
        opt =>
          `<label class="flex items-center space-x-2"><input type="radio" name="gender" value="${opt}" ${data?.gender === opt ? 'checked' : ''}><span class="text-brand-text">${opt}</span></label>`,
      )
      .join('');
    const handOptions = ['右利き', '左利き', '両利き']
      .map(
        opt =>
          `<label class="flex items-center space-x-2"><input type="radio" name="dominantHand" value="${opt}" ${data?.dominantHand === opt ? 'checked' : ''}><span class="text-brand-text">${opt}</span></label>`,
      )
      .join('');
    const ageOptions = [
      '----',
      '10代（16歳以上）',
      '20代',
      '30代',
      '40代',
      '50代',
      '60代',
      '70代',
      '80代以上',
      'ひみつ',
    ]
      .map(
        opt =>
          `<option value="${opt}" ${data?.ageGroup === opt ? 'selected' : ''}>${opt}</option>`,
      )
      .join('');

    return Components.pageContainer({
      maxWidth: 'md',
      content: `
        <h1 class="text-xl font-bold text-brand-text mb-4 text-center">プロフィール</h1>
        <form id="step2-form" class="space-y-6">
          ${Components.input({ id: 'q-email', label: 'メールアドレス *必須項目*', type: 'email', value: data?.email || '', required: true })}
          <div class="p-3 bg-ui-surface rounded-md">
            <label class="flex items-center space-x-3">
              <input type="checkbox" id="q-wants-email" name="wantsEmail" class="h-5 w-5 accent-action-primary-bg" ${data?.wantsEmail ? 'checked' : ''}>
              <span class="text-brand-text text-sm">メール連絡を希望します（教室日程、予約受付、など）</span>
            </label>
          </div>
          ${Components.select({ id: 'q-age-group', label: '年代', options: ageOptions })}
          <div><label class="block text-brand-text text-base font-bold mb-2">性別</label><div class="flex space-x-4">${genderOptions}</div></div>
          <div><label class="block text-brand-text text-base font-bold mb-2">利き手</label><div class="flex space-x-4">${handOptions}</div></div>
          ${Components.input({ id: 'q-address', label: '住所（市区町村まででOK！）', type: 'text', value: (data && data.address) || '' })}
        </form>
        ${Components.actionButtonSection({
          secondaryButton: {
            text: 'もどる',
            action: 'backToStep1',
            style: 'secondary',
          },
          primaryButton: {
            text: 'すすむ',
            action: 'goToStep3',
            style: 'primary',
          },
          layout: 'horizontal',
        })}
      `,
    });
  };

  /**
   * 新規登録フローのステップ3（木彫り関連情報）
   * 【UX配慮】動的表示制御により、経験者には詳細質問を表示
   * @returns {string} 木彫りアンケートフォームのHTML文字列
   */
  const getRegistrationStep3View = () => {
    const data = stateManager.getState()['registrationData'];
    const experienceOptions = ['はじめて！', 'ちょっと', 'そこそこ', 'かなり！']
      .map(
        opt =>
          `<label class="flex items-center space-x-2"><input type="radio" name="experience" value="${opt}" ${data['experience'] === opt ? 'checked' : ''}><span class="text-brand-text">${opt}</span></label>`,
      )
      .join('');

    return Components.pageContainer({
      maxWidth: 'md',
      content: `
        <h1 class="text-xl font-bold text-brand-text mb-4 text-center">木彫りについて</h1>
        <form id="step3-form" class="space-y-6">
          <div>
            <label class="block text-brand-text text-base font-bold mb-2">木彫りの経験はありますか？</label>
            <div class="space-y-2" id="experience-radio-group">${experienceOptions}</div>
          </div>
          <div id="past-work-container" class="${data['experience'] && data['experience'] !== 'はじめて！' ? '' : 'hidden'}">
            ${Components.textarea({
              id: 'q-past-work',
              label: 'いつ頃、どこで、何を作りましたか？',
              value: data['pastWork'] || '',
              placeholder: 'だいたいでOK！',
            })}
          </div>
          ${Components.textarea({
            id: 'q-future-goal',
            label: '将来的に制作したいものはありますか？',
            value: data['futureGoal'] || '',
            placeholder: '曖昧な内容でも大丈夫！',
          })}
        </form>
        ${Components.actionButtonSection({
          secondaryButton: {
            text: 'もどる',
            action: 'backToStep2',
            style: 'secondary',
          },
          primaryButton: {
            text: 'すすむ',
            action: 'proceedToStep4',
            style: 'primary',
          },
          layout: 'horizontal',
        })}
      `,
    });
  };

  /**
   * 新規登録フローのステップ4（アンケート）
   * 【設計方針】最終ステップでユーザーの参加意向とフィードバックを収集
   * @returns {string} アンケートフォームのHTML文字列
   */
  const getRegistrationStep4View = () => {
    const data = stateManager.getState()['registrationData'];
    const participationOptions = [
      '毎月通いたい！',
      '2,3ヶ月ごとくらいで通いたい！',
      'これるときにたまに通いたい！',
      '1回やってみたい！',
      '通いたいがむずかしい…',
    ]
      .map(
        opt =>
          `<label class="flex items-center space-x-2 p-2 rounded hover:bg-ui-surface cursor-pointer">
              <input type="radio" name="futureParticipation" value="${opt}" ${data['futureParticipation'] === opt ? 'checked' : ''} class="text-action-primary-bg focus:ring-action-primary-bg">
              <span class="text-brand-text">${opt}</span>
            </label>`,
      )
      .join('');

    return Components.pageContainer({
      maxWidth: 'md',
      content: `
        <h1 class="text-xl font-bold text-brand-text mb-4 text-center">アンケート</h1>
        <form id="step4-form" class="space-y-6">
          <div>
            <label class="block text-brand-text text-base font-bold mb-3">今後のご参加について</label>
            <div class="space-y-2" id="participation-radio-group">${participationOptions}</div>
          </div>

          ${Components.textarea({
            id: 'q-trigger',
            label: 'この教室を知ったきっかけは？参加しようと思ったきっかけは？',
            value: data['trigger'] || '',
          })}

          ${Components.textarea({
            id: 'q-first-message',
            label: 'メッセージ',
            value: data['firstMessage'] || '',
            placeholder: 'その他コメント・要望・意見など、あればどうぞ〜',
          })}
        </form>
        ${Components.actionButtonSection({
          secondaryButton: {
            text: 'もどる',
            action: 'backToStep3',
            style: 'secondary',
          },
          primaryButton: {
            text: 'とうろく する！',
            action: 'submitRegistration',
            style: 'primary',
          },
          layout: 'horizontal',
        })}
      `,
    });
  };

  /**
   * プロフィール編集画面
   * 【設計方針】getUserFormViewへの簡潔なラッパー
   * @returns {HTMLString} HTML文字列
   */
  const getEditProfileView = () => getUserFormView({ mode: 'edit' });


  // =================================================================
  // 13_WebApp_Views_Booking.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 13_WebApp_Views_Booking.js
   * 【バージョン】: 1.1
   * 【役割】: 予約関連のビュー（予約枠一覧、予約フォーム、教室選択）
   * 【構成】: Views.jsから分割された予約機能
   * 【v1.1での変更点】: JSDocの型定義を更新
   * =================================================================
   */

  /**
   * 特定の教室の予約枠一覧画面のUIを生成します。
   * @param {string} classroom - 教室名
   * @returns {string} HTML文字列
   */
  const getBookingView = classroom => {
    const currentState = stateManager.getState();
    const relevantLessons =
      currentState.lessons && Array.isArray(currentState.lessons)
        ? currentState.lessons.filter(
            lesson => lesson.schedule.classroom === classroom,
          )
        : [];

    const bookingLessonsHtml = renderBookingLessons(relevantLessons);

    if (!bookingLessonsHtml) {
      return `
        ${Components.pageHeader({ title: classroom })}
        ${Components.pageContainer({
          maxWidth: 'md',
          content: `
                <p class="${DesignConfig.colors.textSubtle} mb-6">現在、予約可能な日がありません。</p>
          `,
        })}
      `;
    } else {
      return `
        ${Components.pageHeader({ title: classroom })}
        ${Components.pageContainer({
          maxWidth: 'md',
          content: `
                <div class="${DesignConfig.cards.container}">${bookingLessonsHtml}</div>
          `,
        })}
      `;
    }
  };

  /**
   * 予約の詳細入力・編集画面のUIを生成します。
   * state.currentReservationFormContext からデータを取得して描画します。
   * @returns {string} HTML文字列
   */
  const getReservationFormView = () => {
    const {
      currentUser,
      accountingMaster,
      isFirstTimeBooking,
      currentReservationFormContext,
    } = stateManager.getState();

    if (!currentReservationFormContext) {
      return 'エラー: 予約フォームのデータが見つかりません。';
    }

    const { lessonInfo, reservationInfo } = currentReservationFormContext;
    const isEdit = !!reservationInfo.reservationId;

    const { schedule, status } = lessonInfo;
    const { classroom, date, venue, classroomType, beginnerStart } = schedule;
    const {
      firstLecture,
      chiselRental,
      workInProgress,
      materialInfo,
      order,
      messageToTeacher,
      startTime,
      endTime,
    } = reservationInfo;
    const isWaiting = reservationInfo.status === CONSTANTS.STATUS.WAITLISTED;

    const isTimeBased = isTimeBasedClassroom(schedule);

    const title = isEdit
      ? '予約内容の編集'
      : status.isFull || (isFirstTimeBooking && status.firstLectureIsFull)
        ? 'キャンセル待ち申込み'
        : '予約詳細の入力';
    const submitAction = isEdit ? 'updateReservation' : 'confirmBooking';
    const submitButtonText = isEdit
      ? 'この内容で更新する'
      : status.isFull
        ? 'キャンセル待ちで登録する'
        : 'この内容で予約する';

    const _renderStatusHtml = () => {
      if (isEdit) {
        return isWaiting ? 'キャンセル待ち' : '予約済み';
      }
      if (isFirstTimeBooking) {
        return status.firstLectureIsFull
          ? '初回者枠 満席（キャンセル待ち申込み）'
          : `初回者枠 空き <span class="font-mono-numbers">${status.firstLectureSlots}</span>`;
      }
      if (status.isFull) return '満席（キャンセル待ち申込み）';
      if (typeof status.morningSlots !== 'undefined') {
        const morningLabel = CONSTANTS.SESSIONS.MORNING || '午前';
        const afternoonLabel = CONSTANTS.SESSIONS.AFTERNOON || '午後';
        return `空き ${morningLabel} <span class="font-mono-numbers">${status.morningSlots}</span> | ${afternoonLabel} <span class="font-mono-numbers">${status.afternoonSlots}</span>`;
      }
      return `空き <span class="font-mono-numbers">${status.availableSlots}</span>`;
    };

    const _renderTuitionDisplaySection = () => {
      if (isTimeBased) {
        const basicTuitionRule = accountingMaster.find(
          item =>
            item.item === CONSTANTS.ITEMS.MAIN_LECTURE &&
            item.classroom?.includes(classroom),
        );
        if (basicTuitionRule) {
          return Components.priceDisplay({
            amount: basicTuitionRule.price,
            label: `${CONSTANTS.ITEMS.MAIN_LECTURE} / 30分`,
            style: 'highlight',
          });
        }
      } else {
        const targetItemName = isFirstTimeBooking
          ? CONSTANTS.ITEMS.FIRST_LECTURE
          : CONSTANTS.ITEMS.MAIN_LECTURE;
        const tuitionItem = accountingMaster.find(
          item =>
            item.type === CONSTANTS.ITEM_TYPES.TUITION &&
            item.item === targetItemName &&
            (item.classroom === '共通' || item.classroom?.includes(classroom)),
        );
        if (tuitionItem) {
          return Components.priceDisplay({
            amount: tuitionItem.price,
            label: targetItemName,
            style: isFirstTimeBooking ? 'highlight' : 'default',
          });
        }
      }
      return '';
    };

    const _renderTimeOptionsSection = () => {
      // セッション制教室の場合、隠し入力として時刻を設定
      if (!isTimeBased) {
        if (!schedule.firstStart || !schedule.firstEnd) {
          return `<div class="text-ui-error-text p-4 bg-ui-error-bg rounded-lg">エラー: この教室の時間設定が不正です</div>`;
        }
        return `
          <input type="hidden" id="res-start-time" value="${schedule.firstStart}" />
          <input type="hidden" id="res-end-time" value="${schedule.firstEnd}" />
        `;
      }

      if (!schedule.firstStart || !schedule.firstEnd) {
        return `<div class="text-ui-error-text p-4 bg-ui-error-bg rounded-lg">エラー: この教室の時間設定が不正です</div>`;
      }

      const startHour = parseInt(schedule.firstStart.split(':')[0]);
      const endHour = parseInt(
        (schedule.secondEnd || schedule.firstEnd).split(':')[0],
      );
      const endMinutes = parseInt(
        (schedule.secondEnd || schedule.firstEnd).split(':')[1],
      );

      let fixedStartTime = startTime;
      let isTimeFixed = false;
      if (
        isFirstTimeBooking &&
        beginnerStart &&
        /** @type {any} */ (schedule).beginnerCapacity > 0
      ) {
        fixedStartTime = beginnerStart;
        isTimeFixed = true;
      }

      const startTimeOptions = isTimeFixed
        ? `<option value="${fixedStartTime}" selected>${fixedStartTime}</option>`
        : getTimeOptionsHtml(
            startHour,
            endHour,
            CONSTANTS.FRONTEND_UI.TIME_SETTINGS.STEP_MINUTES,
            startTime,
          );
      let endTimeOptions = getTimeOptionsHtml(
        startHour,
        endHour,
        CONSTANTS.FRONTEND_UI.TIME_SETTINGS.STEP_MINUTES,
        endTime,
      );
      if (endMinutes > 0) {
        const finalEndTime = `${String(endHour).padStart(2, '0')}:${String(endMinutes).padStart(2, '0')}`;
        endTimeOptions += `<option value="${finalEndTime}">${finalEndTime}</option>`;
      }

      const timeFixedMessage = isTimeFixed
        ? `<p class="${/** @type {any} */ (DesignConfig.text).caption} mb-2">初回の方は <span class="time-display">${fixedStartTime}</span> より開始です。昼をまたぐ場合は、1時間休憩を挟みます</p>`
        : '';

      return `
          <div class="mt-4 pt-4 border-t-2">
            <h4 class="font-bold ${DesignConfig.colors.text} mb-2">予約時間</h4>
            ${timeFixedMessage}
            <div class="grid grid-cols-2 gap-4 mb-2">
              ${Components.select({ id: 'res-start-time', label: '開始予定', options: startTimeOptions })}
              ${Components.select({ id: 'res-end-time', label: '終了予定', options: endTimeOptions })}
            </div>
          </div>`;
    };

    const _renderBookingOptionsSection = () => {
      const firstLectureChecked = firstLecture || (!isEdit && isFirstTimeBooking);
      const firstLectureDisabled = !isEdit && isFirstTimeBooking;

      if (classroomType === CONSTANTS.CLASSROOM_TYPES.SESSION_BASED) {
        return `
          <div class="mt-4 pt-4 border-t-2">
            <h4 class="font-bold text-left mb-2">オプション</h4>
            ${Components.checkbox({ id: 'option-first-lecture', label: CONSTANTS.ITEMS.FIRST_LECTURE, checked: firstLectureChecked, disabled: firstLectureDisabled })}
            <div class="mt-2">${Components.checkbox({ id: 'option-rental', label: `${CONSTANTS.ITEMS.CHISEL_RENTAL} 1回 ¥500`, checked: chiselRental })}</div>
          </div>`;
      }
      return '';
    };

    const _renderDetailsInputSection = () => {
      const salesChecklistHtml =
        typeof buildSalesChecklist === 'function'
          ? buildSalesChecklist(accountingMaster)
          : '';
      return `
          <div class="mt-4 pt-4 border-t-2 space-y-4">
            ${Components.textarea({ id: 'wip-input', label: isFirstTimeBooking && !isEdit ? '今回つくりたいもの/やりたいこと' : 'つくりたいもの/やりたいこと/作業予定', placeholder: 'あとからでも記入できます。当日に相談でも大丈夫！', value: workInProgress || '' })}
            ${Components.textarea({ id: 'material-input', label: '材料のサイズや樹種の希望', placeholder: '例：30×30×40mmくらい」「高さが6cmくらい」「たまごぐらい」 など', value: materialInfo || '' })}
          </div>
          <div class="mt-4 pt-4 border-t-2 space-y-4">
            ${salesChecklistHtml}
            ${Components.textarea({ id: 'order-input', label: '購入希望（自由記入）', placeholder: '（任意）例：彫刻刀セット、テキスト', value: order || '' })}
            ${Components.textarea({ id: 'message-input', label: 'その他の連絡事項や要望など', placeholder: '', value: messageToTeacher || '' })}
          </div>`;
    };

    const _getSelectedSalesOrder = () =>
      Array.from(document.querySelectorAll('input[name="orderSales"]:checked'))
        .map(cb => cb.value)
        .join(', ');

    setTimeout(() => {
      const submitBtn = document.querySelector(`[data-action="${submitAction}"]`);
      if (submitBtn) {
        submitBtn.addEventListener('click', () => {
          const selectedOrder = _getSelectedSalesOrder();
          const orderInput = document.getElementById('order-input');
          if (orderInput) {
            const freeText = orderInput.value.trim();
            orderInput.value = selectedOrder
              ? freeText
                ? `${selectedOrder}, ${freeText}`
                : selectedOrder
              : freeText;
          }
        });
      }
    }, 300);

    let buttonsHtml = Components.button({
      text: submitButtonText,
      action: submitAction,
      style: 'primary',
      size: 'full',
    });
    if (isEdit) {
      buttonsHtml += Components.button({
        text: 'この予約をキャンセルする',
        action: 'cancel',
        style: 'danger',
        size: 'full',
        dataAttributes: {
          reservationId: reservationInfo.reservationId,
          classroom: reservationInfo.classroom,
          date: String(reservationInfo.date),
        },
      });
    }
    buttonsHtml += Components.button({
      text: 'もどる',
      action: 'smartGoBack',
      style: 'secondary',
      size: 'full',
    });

    const _renderOpeningHoursHtml = () => {
      if (!schedule.firstStart || !schedule.firstEnd)
        return '<span class="text-ui-error-text">開講時間未設定</span>';
      if (schedule.secondStart && schedule.secondEnd)
        return `<span class="time-display">${schedule.firstStart}~${schedule.firstEnd}</span> , <span class="time-display">${schedule.secondStart}~${schedule.secondEnd}</span>`;
      return `<span class="time-display">${schedule.firstStart}~${schedule.firstEnd}</span>`;
    };

    return `
        ${Components.pageHeader({ title: title })}
        ${Components.cardContainer({
          variant: 'default',
          padding: 'spacious',
          content: `
            <div class="space-y-4 text-left">
              <p><span class="font-bold w-20 inline-block">お名前:</span> ${currentUser.displayName}さん</p>
              <p><span class="font-bold w-20 inline-block">教室:</span> ${classroom}${venue ? ` ${venue}` : ''}</p>
              <p><span class="font-bold w-20 inline-block">日付:</span> ${formatDate(String(date))}</p>
              <p><span class="font-bold w-20 inline-block">状況:</span> ${_renderStatusHtml()}</p>
              <p><span class="font-bold w-20 inline-block">開講時間:</span> ${_renderOpeningHoursHtml()}</p>
              ${_renderTuitionDisplaySection()}
              ${_renderTimeOptionsSection()}
              ${_renderBookingOptionsSection()}
              ${_renderDetailsInputSection()}
            </div>
          `,
        })}
        <div class="mt-8 flex flex-col space-y-3">
          ${buttonsHtml}
        </div>`;
  };

  /**
   * 予約スロットのリストからHTMLを生成します。
   * この関数は getBookingView と getCompleteView で共有されます。
   * @param {LessonData[]} lessons - 表示する講座情報の配列
   * @returns {string} HTML文字列
   */
  const renderBookingLessons = lessons => {
    if (!lessons || lessons.length === 0) {
      return '';
    }

    /** @type {Record<number, LessonData[]>} */
    const lessonsByMonth = lessons.reduce((acc, lesson) => {
      const month = new Date(lesson.schedule.date).getMonth() + 1;
      if (!acc[month]) acc[month] = [];
      acc[month].push(lesson);
      return acc;
    }, /** @type {Record<number, LessonData[]>} */ ({}));

    const result = Object.keys(lessonsByMonth)
      .sort((a, b) => Number(a) - Number(b))
      .map(monthStr => {
        const month = Number(monthStr);
        const monthHeader = `<h4 class="text-lg font-medium ${DesignConfig.colors.textSubtle} mt-4 mb-2 text-center">${month}月</h4>`;

        const lessonsHtml = lessonsByMonth[month]
          .map(
            /** @param {LessonData} lesson */ lesson => {
              const state = stateManager.getState();
              const isBooked = (state.myReservations || []).some(
                b =>
                  String(b.date) === lesson.schedule.date &&
                  b.classroom === lesson.schedule.classroom,
              );
              let cardClass, statusBadge, actionAttribute;
              const tag = isBooked ? 'div' : 'button';

              const isFirstTimeBooking =
                stateManager.getState().isFirstTimeBooking;
              let statusText;

              if (isFirstTimeBooking) {
                if (
                  lesson.schedule.beginnerStart &&
                  /** @type {any} */ (lesson.schedule).beginnerCapacity > 0
                ) {
                  statusText = `初回者 空き <span class="font-mono-numbers">${lesson.status.firstLectureSlots}</span>`;
                } else {
                  statusText = '経験者のみ';
                }
              } else {
                if (typeof lesson.status.morningSlots !== 'undefined') {
                  const morningLabel = CONSTANTS.SESSIONS.MORNING || '午前';
                  const afternoonLabel = CONSTANTS.SESSIONS.AFTERNOON || '午後';
                  statusText = `空き ${morningLabel}<span class="font-mono-numbers">${lesson.status.morningSlots}</span> ${afternoonLabel}<span class="font-mono-numbers">${lesson.status.afternoonSlots}</span>`;
                } else {
                  statusText = `空き <span class="font-mono-numbers">${lesson.status.availableSlots}</span>`;
                }
              }

              if (isBooked) {
                const reservationData = findReservationByDateAndClassroom(
                  lesson.schedule.date,
                  lesson.schedule.classroom,
                );
                if (reservationData?.status === CONSTANTS.STATUS.COMPLETED) {
                  cardClass = `${DesignConfig.cards.base} ${DesignConfig.cards.state.booked.card}`;
                  statusBadge = `<span class="text-sm font-bold ${DesignConfig.cards.state.booked.text}">受講済み</span>`;
                  actionAttribute = '';
                } else if (
                  reservationData?.status === CONSTANTS.STATUS.WAITLISTED
                ) {
                  cardClass = `${DesignConfig.cards.base} ${DesignConfig.cards.state.waitlist.card}`;
                  statusBadge = `<span class="text-sm font-bold ${DesignConfig.cards.state.waitlist.text}">キャンセル待ち 登録済</span>`;
                  actionAttribute = '';
                } else {
                  cardClass = `${DesignConfig.cards.base} ${DesignConfig.cards.state.booked.card}`;
                  statusBadge = `<span class="text-sm font-bold ${DesignConfig.cards.state.booked.text}">予約済み</span>`;
                  actionAttribute = '';
                }
              } else {
                let isSlotFull = false;
                let canBook = true;

                if (isFirstTimeBooking) {
                  if (
                    !lesson.schedule.beginnerStart ||
                    /** @type {any} */ (lesson.schedule).beginnerCapacity <= 0
                  ) {
                    canBook = false;
                  }
                  isSlotFull = lesson.status.firstLectureIsFull;
                } else {
                  isSlotFull = lesson.status.isFull;
                }

                if (!canBook) {
                  cardClass = `${DesignConfig.cards.base} ${DesignConfig.cards.state.waitlist.card} opacity-50`;
                  statusBadge = `<span class="text-sm font-bold ${DesignConfig.cards.state.waitlist.text}">${statusText}</span>`;
                  actionAttribute = '';
                } else if (isSlotFull) {
                  cardClass = `${DesignConfig.cards.base} ${DesignConfig.cards.state.waitlist.card}`;
                  statusBadge = `<span class="text-sm font-bold ${DesignConfig.cards.state.waitlist.text}">満席（キャンセル待ち申込み）</span>`;
                  actionAttribute = `data-action="bookLesson" data-classroom="${lesson.schedule.classroom}" data-date="${lesson.schedule.date}"`;
                } else {
                  cardClass = `${DesignConfig.cards.base} ${DesignConfig.cards.state.available.card}`;
                  statusBadge = `<span class="text-sm font-bold ${DesignConfig.cards.state.available.text}">${statusText}</span>`;
                  actionAttribute = `data-action="bookLesson" data-classroom="${lesson.schedule.classroom}" data-date="${lesson.schedule.date}"`;
                }
              }

              const venueDisplay = lesson.schedule.venue
                ? ` ${lesson.schedule.venue}`
                : '';
              const text = `<div class="flex justify-between items-center w-full"><span class="${DesignConfig.colors.text}">${formatDate(lesson.schedule.date)}${venueDisplay}</span>${statusBadge}</div>`;

              return `<${tag} ${actionAttribute} class="${cardClass}">${text}</${tag}>`;
            },
          )
          .join('');

        return monthHeader + lessonsHtml;
      })
      .join('');

    return result;
  };

  /**
   * 教室選択モーダル用のコンテンツを生成します。
   * @returns {string} HTML文字列
   */
  const getClassroomSelectionModalContent = () => {
    const classrooms = Object.values(CONSTANTS.CLASSROOMS || {});

    if (!classrooms.length) {
      return `<div class="text-center"><p class="text-brand-subtle mb-4">現在、予約可能な教室がありません。</p></div>`;
    }

    const desiredOrder = ['東京教室', 'つくば教室', '沼津教室'];
    const sortedClassrooms = classrooms.sort((a, b) => {
      const indexA = desiredOrder.indexOf(a);
      const indexB = desiredOrder.indexOf(b);
      if (indexA === -1 && indexB === -1) return a.localeCompare(b);
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    });

    const classroomButtonsHtml = sortedClassrooms
      .map(classroomName => {
        const colorClass = getClassroomColorClass(classroomName);
        const fullButtonClass = `w-full h-16 text-center px-6 py-4 rounded-xl mobile-card touch-friendly flex items-center justify-center text-xl font-bold border-2 transition-all duration-200 hover:scale-105 hover:shadow-lg active:scale-95 ${colorClass}`;

        return Components.button({
          action: 'selectClassroom',
          text: classroomName,
          style: 'none',
          customClass: fullButtonClass,
          dataAttributes: {
            classroomName: classroomName,
            classroom: classroomName,
          },
        });
      })
      .join('');

    return `
        <div class="space-y-4">
          ${classroomButtonsHtml}
        </div>
      `;
  };

  /**
   * 教室選択モーダル全体のHTMLを生成します。
   * @returns {string} HTML文字列
   */
  const getClassroomSelectionModal = () => {
    return Components.modal({
      id: 'classroom-selection-modal',
      title: 'おえらびください',
      content: getClassroomSelectionModalContent(),
      maxWidth: 'max-w-md',
    });
  };

  /**
   * 編集モード対応の履歴カードを生成します
   * @param {ReservationData} historyItem - 履歴データ
   * @param {Array<any>} editButtons - 編集ボタン配列
   * @param {Array<any>} accountingButtons - 会計ボタン配列
   * @param {boolean} isInEditMode - 編集モード状態
   * @returns {string} HTML文字列
   */
  function _buildHistoryCardWithEditMode(
    historyItem,
    editButtons,
    accountingButtons,
    isInEditMode,
  ) {
    // 履歴カード特有の会計ボタン追加ロジック
    let allAccountingButtons = [...accountingButtons];

    if (isInEditMode) {
      const isToday = _isToday(String(historyItem.date));
      if (historyItem.status === CONSTANTS.STATUS.COMPLETED && !isToday) {
        // 重複チェック：既に「会計記録」ボタンが存在しない場合のみ追加
        const hasAccountingDetailsButton = allAccountingButtons.some(
          btn => btn.action === 'showHistoryAccounting',
        );

        if (!hasAccountingDetailsButton) {
          allAccountingButtons.push({
            action: 'showHistoryAccounting',
            text: '会計<br>記録',
            style: 'accounting',
            size: 'xs',
            details: historyItem.accountingDetails,
          });
        }
      }
    }

    // listCard を使用してカードを生成
    return Components.listCard({
      item: historyItem,
      badges: [], // 履歴カードはバッジなし
      editButtons: editButtons,
      accountingButtons: allAccountingButtons,
      type: 'record',
      isEditMode: isInEditMode,
      showMemoSaveButton: true,
    });
  }


  // =================================================================
  // 13_WebApp_Views_Dashboard.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 13_WebApp_Views_Dashboard.js
   * 【バージョン】: 1.0
   * 【役割】: ダッシュボード関連のビュー（予約一覧、履歴表示、ボタン管理）
   * 【構成】: Views.jsから分割されたダッシュボード機能
   * =================================================================
   */

  /**
   * メインのホーム画面のUIを生成します。
   * 【改善】ビジネスロジックをヘルパー関数に分離して可読性向上
   * @returns {string} HTML文字列
   */
  const getDashboardView = () => {
    // myReservationsから直接フィルタリングして表示（シンプル化）
    const state = stateManager.getState();
    const myReservations = state.myReservations || [];

    // 予約セクション用のカード配列を構築：確定・待機ステータスのみ表示
    const activeReservations = myReservations
      .filter(
        res =>
          res.status === CONSTANTS.STATUS.CONFIRMED ||
          res.status === CONSTANTS.STATUS.WAITLISTED,
      )
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()); // 新しい順ソート

    const bookingCards = activeReservations.map(b => {
      const badges = _buildBookingBadges(b);
      const editButtons = _buildEditButtons(b);
      const accountingButtons = _buildAccountingButtons(b);

      return Components.listCard({
        type: 'booking',
        item: b,
        badges: badges,
        editButtons: editButtons,
        accountingButtons: accountingButtons,
      });
    });

    // 予約セクションを生成（Componentsに構造生成を委任）
    const yourBookingsHtml = Components.dashboardSection({
      title: 'よやく',
      items: bookingCards,
      showNewButton: true,
      newAction: 'showClassroomModal',
    });

    // 履歴セクション用のカード配列を構築：完了ステータスのみ表示
    let historyHtml = '';
    const completedReservations = myReservations
      .filter(res => res.status === CONSTANTS.STATUS.COMPLETED)
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()); // 新しい順ソート

    const recordsToShow = state.recordsToShow;
    const completedRecords = completedReservations.slice(0, recordsToShow);

    if (completedRecords.length > 0) {
      // 「きろく」は COMPLETED ステータスのみ表示
      const historyCards = completedRecords.map(h => {
        // 編集モード状態を取得
        const isInEditMode = stateManager.isInEditMode(h.reservationId);

        const editButtons = _buildHistoryEditButtons(
          isInEditMode,
          h.reservationId,
        );
        const accountingButtons = _buildHistoryAccountingButtons(h);

        return _buildHistoryCardWithEditMode(
          h,
          editButtons,
          accountingButtons,
          isInEditMode,
        );
      });

      const showMore = recordsToShow < completedReservations.length;

      // Componentsに構造生成を委任
      historyHtml = Components.dashboardSection({
        title: 'きろく',
        items: historyCards,
        showMoreButton: showMore,
        moreAction: 'loadMoreHistory',
      });
    }

    return `
          <div class="flex flex-col sm:flex-row justify-between sm:items-center my-2">
              <h1 class="text-base sm:text-xl font-bold ${DesignConfig.colors.text} mr-4 mb-1 sm:mb-0">ようこそ <span class="text-xl whitespace-nowrap">${stateManager.getState().currentUser.displayName} <span class="text-base">さん</span></span></h1>
              <button data-action="goToEditProfile" class="${DesignConfig.colors.info} self-end sm:self-auto text-sm text-action-secondary-text px-3 py-0.5 rounded-md active:bg-action-secondary-hover">Profile 編集</button>
          </div>
          ${yourBookingsHtml}
          ${historyHtml}
      `;
  };

  /**
   * 予約カードの編集ボタン配列を生成します。
   * @param {ReservationData} booking - 予約データ
   * @returns {Array<any>} 編集ボタン設定配列
   */
  const _buildEditButtons = booking => {
    const buttons = [];

    // 確認/編集ボタン
    if (
      booking.status === CONSTANTS.STATUS.CONFIRMED ||
      booking.status === CONSTANTS.STATUS.WAITLISTED
    ) {
      buttons.push({
        action: 'goToEditReservation',
        text: '確認<br>編集',
        // style: カードタイプに応じて自動選択
      });
    }

    return buttons;
  };

  /**
   * 予約カードの会計ボタン配列を生成します。
   * @param {ReservationData} booking - 予約データ
   * @returns {Array<any>} 会計ボタン設定配列
   */
  const _buildAccountingButtons = booking => {
    const buttons = [];

    // 会計ボタン（予約日以降のみ）
    const isBookingPastOrToday = _isPastOrToday(booking.date);
    if (booking.status === CONSTANTS.STATUS.CONFIRMED && isBookingPastOrToday) {
      buttons.push({
        action: 'goToAccounting',
        text: '会計',
        style: 'accounting',
      });
    }

    return buttons;
  };

  /**
   * 履歴カードの編集ボタン配列を生成します。
   * @param {boolean} isInEditMode - 編集モードフラグ
   * @param {string} reservationId - 予約ID
   * @returns {Array<any>} 編集ボタン設定配列
   */
  const _buildHistoryEditButtons = (isInEditMode = false, reservationId = '') => {
    const buttons = [];
    const state = stateManager.getState();

    // 編集モード状態に応じてボタンテキストとアクションを変更
    if (isInEditMode) {
      // 編集モード時：入力変更があるかチェック
      const hasInputChanged =
        state.memoInputChanged &&
        state.editingMemo &&
        state.editingMemo.reservationId === reservationId;

      if (hasInputChanged) {
        // 入力変更あり：保存ボタンを表示
        buttons.push({
          action: 'saveAndCloseMemo',
          text: 'メモを<br>保存',
          size: 'xs',
          dataAttributes: {
            reservationId: reservationId,
          },
        });
      } else {
        // 入力変更なし：とじるボタンを表示
        buttons.push({
          action: 'closeEditMode',
          text: 'とじる',
          size: 'xs',
          dataAttributes: {
            reservationId: reservationId,
          },
        });
      }
    } else {
      // 通常時：編集モードに入る
      buttons.push({
        action: 'expandHistoryCard',
        text: '確認<br>編集',
        size: 'xs',
      });
    }

    return buttons;
  };

  /**
   * 履歴カードの会計ボタン配列を生成します。
   * @param {ReservationData} historyItem - 履歴データ
   * @returns {Array<any>} 会計ボタン設定配列
   */
  const _buildHistoryAccountingButtons = historyItem => {
    const buttons = [];

    if (historyItem.status === CONSTANTS.STATUS.COMPLETED) {
      const isHistoryToday = _isToday(historyItem.date);

      if (isHistoryToday) {
        // きろく かつ 教室の当日 → 「会計を修正」ボタンは維持
        buttons.push({
          action: 'editAccountingRecord',
          text: '会計を<br>修正',
          style: 'accounting',
        });
      }
    }

    return buttons;
  };

  /**
   * 予約カードのバッジ配列を生成します。
   * @param {ReservationData} booking - 予約データ
   * @returns {Array<{type: string, text: string}>} バッジ設定配列
   */
  const _buildBookingBadges = booking => {
    /** @type {Array<{type: string, text: string}>} */
    const badges = [];

    if (booking.firstLecture) {
      badges.push({ type: 'info', text: '初回' });
    }

    if (
      booking.status === CONSTANTS.STATUS.WAITLISTED ||
      /** @type {any} */ (booking).isWaiting
    ) {
      badges.push({ type: 'warning', text: 'キャンセル待ち' });
    }

    return badges;
  };

  /**
   * 特定の履歴カードのメモセクションとボタンのみを部分更新（ちらつき防止・スムーズ切替）
   * @param {string} reservationId - 更新対象の予約ID
   */
  function updateSingleHistoryCard(reservationId) {
    // 該当するカードのDOM要素を取得
    const cardElement = document.querySelector(
      `[data-reservation-id="${reservationId}"]`,
    );
    if (!cardElement) {
      console.warn('カードが見つかりません:', reservationId);
      return;
    }

    // 現在の状態から該当する履歴アイテムを取得
    const state = stateManager.getState();
    const historyItem = state.myReservations.find(
      h => h.reservationId === reservationId,
    );
    if (!historyItem || historyItem.status !== CONSTANTS.STATUS.COMPLETED) return;

    // 編集モード状態を取得
    const isInEditMode = stateManager.isInEditMode(reservationId);

    // スムーズ切替のため更新をバッチ実行
    requestAnimationFrame(() => {
      // 1. メモセクションの更新
      _updateMemoSection(reservationId, historyItem, isInEditMode);

      // 2. ボタンエリアの更新
      _updateHistoryCardButton(reservationId);
    });
  }

  /**
   * メモセクションのみを更新（DOM直接操作）
   * @param {string} reservationId - 予約ID
   * @param {ReservationData} historyItem - 履歴データ
   * @param {boolean} isInEditMode - 編集モード状態
   */
  function _updateMemoSection(reservationId, historyItem, isInEditMode) {
    const cardElement = document.querySelector(
      `[data-reservation-id="${reservationId}"]`,
    );
    if (!cardElement) return;

    // より確実なセレクターを使ってメモセクションを探す
    let existingMemoSection;

    if (isInEditMode) {
      // 通常モード→編集モード：読み取り専用メモセクションを探す
      // 「制作メモ」という見出しを含む要素を探す
      const memoHeaders = Array.from(cardElement.querySelectorAll('h4'));
      for (const header of memoHeaders) {
        if (header.textContent && header.textContent.includes('制作メモ')) {
          existingMemoSection = header.closest('div');
          break;
        }
      }
    } else {
      // 編集モード→通常モード：テキストエリアを含むメモセクションを探す
      const textarea = cardElement.querySelector('.memo-edit-textarea');
      if (textarea) {
        // テキストエリアの適切な親コンテナを探す
        existingMemoSection =
          textarea.closest('div.p-0\\.5.bg-white\\/75') ||
          textarea.closest('div.p-0\\.5') ||
          textarea.closest('.memo-section') ||
          textarea.closest('div[style*="padding"]') ||
          textarea.closest('div');
      }

      // フォールバック：メモセクション全体を再検索
      if (!existingMemoSection) {
        const memoHeaders = Array.from(cardElement.querySelectorAll('h4'));
        for (const header of memoHeaders) {
          if (header.textContent && header.textContent.includes('制作メモ')) {
            existingMemoSection = header.closest('div');
            break;
          }
        }
      }
    }

    if (!existingMemoSection) {
      return; // メモセクションが見つからない場合は処理を中断
    }

    // 新しいメモセクションHTMLを生成
    const newMemoSection = Components.memoSection({
      reservationId: historyItem.reservationId,
      workInProgress: historyItem.workInProgress || '',
      isEditMode: isInEditMode,
      showSaveButton: true,
    });

    // メモセクションを置換
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = newMemoSection;
    const newMemoElement = tempDiv.firstElementChild;

    if (newMemoElement && existingMemoSection.parentNode) {
      // 置換を実行
      existingMemoSection.parentNode.replaceChild(
        newMemoElement,
        existingMemoSection,
      );

      // 編集モードの場合、置換直後にイベントリスナーを設定
      if (isInEditMode) {
        setTimeout(() => {
          _attachMemoEventListeners(reservationId);
        }, 50);
      }
    }
  }

  /**
   * 統一されたテキストエリアID生成
   * @param {string} reservationId - 予約ID
   * @returns {string} テキストエリアID
   */
  function _getMemoTextareaId(reservationId) {
    return `memo-edit-textarea-${reservationId}`;
  }

  /**
   * メモテキストエリアにイベントリスナーを設定
   * @param {string} reservationId - 予約ID
   */
  function _attachMemoEventListeners(reservationId) {
    const textareaId = _getMemoTextareaId(reservationId);

    // テキストエリアを検索（複数の方法で確実に取得）
    let textarea = /** @type {HTMLTextAreaElement | null} */ (
      document.getElementById(textareaId)
    );

    if (!textarea) {
      const cardElement = document.querySelector(
        `[data-reservation-id="${reservationId}"]`,
      );
      if (cardElement) {
        textarea = /** @type {HTMLTextAreaElement | null} */ (
          cardElement.querySelector('.memo-edit-textarea')
        );
        if (!textarea) {
          textarea = /** @type {HTMLTextAreaElement | null} */ (
            cardElement.querySelector(`[data-reservation-id="${reservationId}"]`)
          );
        }
      }
    }

    if (!textarea) {
      const allTextAreas = Array.from(document.querySelectorAll('textarea'));
      textarea = /** @type {HTMLTextAreaElement | null} */ (
        allTextAreas.find(
          ta =>
            ta.id === textareaId || ta.dataset['reservationId'] === reservationId,
        )
      );
    }

    if (textarea) {
      const anyTextarea = /** @type {any} */ (textarea);

      // 既存のリスナーをクリーンアップ
      if (anyTextarea._memoInputHandler) {
        textarea.removeEventListener('input', anyTextarea._memoInputHandler);
      }
      if (anyTextarea._memoFocusHandler) {
        textarea.removeEventListener('focus', anyTextarea._memoFocusHandler);
      }

      let savedScrollY = window.scrollY;

      anyTextarea._memoFocusHandler = () => {
        requestAnimationFrame(() => {
          window.scrollTo(0, savedScrollY);
        });
      };

      anyTextarea._memoInputHandler = (/** @type {Event} */ event) => {
        const currentValue = event.target.value;
        const hasChanged = stateManager.updateMemoInputChanged(
          reservationId,
          currentValue,
        );

        // 状態が実際に変更された場合のみボタンを即座更新
        if (hasChanged !== undefined) {
          _updateHistoryCardButton(reservationId);
        }
      };

      // イベントリスナーを設定
      textarea.addEventListener('focus', anyTextarea._memoFocusHandler);
      textarea.addEventListener('input', anyTextarea._memoInputHandler);

      // マウスダウン時にもスクロール位置を保存（クリック時対応）
      textarea.addEventListener('mousedown', () => {
        savedScrollY = window.scrollY;
      });
    }
  }

  /**
   * 履歴カードのボタンのみを部分更新（無限ループ防止）
   * @param {string} reservationId - 予約ID
   */
  function _updateHistoryCardButton(reservationId) {
    const cardElement = document.querySelector(
      `[data-reservation-id="${reservationId}"]`,
    );
    if (!cardElement) return;

    // ボタンエリアを探す（実際のHTML構造に合わせる）
    let buttonArea = cardElement.querySelector('.flex.gap-1');

    // フォールバック：別のセレクターでも探す
    if (!buttonArea) {
      buttonArea = cardElement.querySelector(
        '.flex-shrink-0.self-start.flex.gap-1',
      );
    }

    if (!buttonArea) {
      console.warn(
        'ボタンエリアが見つかりません:',
        reservationId,
        'カード内要素:',
        cardElement.innerHTML,
      );
      return;
    }

    const state = stateManager.getState();
    const historyItem = state.myReservations.find(
      h => h.reservationId === reservationId,
    );
    if (!historyItem) return;

    const isInEditMode = stateManager.isInEditMode(reservationId);
    const editButtons = _buildHistoryEditButtons(isInEditMode, reservationId);
    let accountingButtons = _buildHistoryAccountingButtons(historyItem);

    // 編集モード時に会計記録ボタンを追加（_buildHistoryCardWithEditModeと同じロジック）
    if (isInEditMode) {
      const isToday = _isToday(String(historyItem.date));
      if (historyItem.status === CONSTANTS.STATUS.COMPLETED && !isToday) {
        // 重複チェック：既に「会計記録」ボタンが存在しない場合のみ追加
        const hasAccountingDetailsButton = accountingButtons.some(
          btn => btn.action === 'showHistoryAccounting',
        );

        if (!hasAccountingDetailsButton) {
          accountingButtons = [
            ...accountingButtons,
            {
              action: 'showHistoryAccounting',
              text: '会計<br>記録',
              style: 'accounting',
              size: 'xs',
              details: historyItem.accountingDetails,
            },
          ];
        }
      }
    }

    // 会計ボタンHTML生成
    const accountingButtonsHtml = accountingButtons
      .map(btn =>
        Components.button({
          action: btn.action,
          text: btn.text,
          style: btn.style || 'accounting',
          size: 'xs',
          dataAttributes: {
            classroom: historyItem.classroom,
            reservationId: historyItem.reservationId,
            date: historyItem.date,
            ...(btn.details && { details: JSON.stringify(btn.details) }),
            ...(btn.dataAttributes || {}),
          },
        }),
      )
      .join('');

    // 編集ボタンHTML生成
    const editButtonsHtml = editButtons
      .map(btn =>
        Components.button({
          action: btn.action,
          text: btn.text,
          style: btn.style || 'recordCard',
          size: btn.size || 'xs',
          dataAttributes: {
            classroom: historyItem.classroom,
            reservationId: historyItem.reservationId,
            date: historyItem.date,
            ...(btn.dataAttributes || {}),
          },
        }),
      )
      .join('');

    // ボタンエリアを更新
    buttonArea.innerHTML = accountingButtonsHtml + editButtonsHtml;
  }


  // =================================================================
  // 13_WebApp_Views_Utils.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 13_WebApp_Views_Utils.js
   * 【バージョン】: 1.0
   * 【役割】: Views関連のユーティリティ関数群
   * 【構成】: Views.jsから分割されたヘルパー関数
   * =================================================================
   */

  // =================================================================
  // --- View Helper Components ---
  // -----------------------------------------------------------------
  // 各ビューを構成するための、より小さな部品を生成するヘルパー関数群。
  // =================================================================

  /**
   * 当日かどうかを判定します。
   * @param {DateString} dateString - 日付文字列 (YYYY-MM-DD)
   * @returns {boolean} 当日の場合true
   */
  const _isToday = dateString => {
    const itemDate = new Date(dateString);
    const today = new Date();
    return itemDate.toDateString() === today.toDateString();
  };

  /**
   * 指定日が「今日もしくは過去」かどうかを判定します。
   * @param {DateString} dateString - 日付文字列 (YYYY-MM-DD)
   * @returns {boolean} 「今日もしくは過去」の場合true
   */
  const _isPastOrToday = dateString => {
    const itemDate = new Date(dateString);
    const today = new Date();
    // 時間を00:00:00にリセットして日付のみで比較
    itemDate.setHours(0, 0, 0, 0);
    today.setHours(0, 0, 0, 0);
    return itemDate <= today;
  };

  /**
   * 時刻選択用の<option>タグ群を生成します。
   * @param {number} startHour - 開始時刻（時）
   * @param {number} endHour - 終了時刻（時）
   * @param {number} step - 間隔（分）
   * @param {TimeString | null} selectedValue - 事前に選択する時刻 (HH:mm)
   * @returns {HTMLString} HTMLの<option>タグ文字列
   */
  const getTimeOptionsHtml = (startHour, endHour, step, selectedValue) => {
    let options = [];
    for (let h = startHour; h <= endHour; h++) {
      for (let m = 0; m < 60; m += step) {
        const time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        options.push(
          `<option value="${time}" ${time === selectedValue ? 'selected' : ''}>${time}</option>`,
        );
      }
    }
    return options.join('');
  };

  /**
   * 教室名に基づいてTailwindCSSのカラークラスを返します。
   * @param {ClassroomName} classroomName - 教室名
   * @returns {string} Tailwindカラークラス
   */
  const getClassroomColorClass = classroomName => {
    switch (classroomName) {
      //TODO: 内容が間違っています！！要修正！！！！
      case 'アトリエ':
        return 'bg-ui-atelier text-white';
      case 'はじめて':
        return 'bg-ui-hajimete text-white';
      case 'みんなの':
        return 'bg-ui-minnano text-white';
      case 'こども':
        return 'bg-ui-kodomo text-white';
      default:
        return 'bg-ui-surface text-brand-text';
    }
  };

  /**
   * 完了画面のUIを生成します。
   * @param {string} msg - 表示するメッセージ
   * @returns {string} HTML文字列
   */
  const getCompleteView = msg => {
    // 教室情報を取得（複数のソースから取得を試行）
    const state = stateManager.getState();
    const classroom =
      state.accountingReservation?.classroom ||
      state.selectedLesson?.schedule?.classroom ||
      state.currentReservationFormContext?.lessonInfo?.schedule?.classroom ||
      state.selectedClassroom;

    // 初回予約者かどうかを判定
    const wasFirstTimeBooking =
      stateManager.getState().wasFirstTimeBooking || false;
    const currentUser = stateManager.getState().currentUser;
    const studentHasEmail = currentUser && currentUser.email;
    const emailPreference = currentUser && currentUser.wantsEmail;

    // 予約完了か会計完了かを判定
    const isReservationComplete = msg !== '会計情報を記録しました。';

    // メール送信に関する案内メッセージ（予約完了時のみ表示）
    let emailNoticeHtml = '';
    if (wasFirstTimeBooking && isReservationComplete) {
      emailNoticeHtml = `
          <div class="bg-ui-info-bg border-2 border-ui-info-border rounded-lg p-4 mt-4">
            <div class="flex items-start">
              <svg class="flex-shrink-0 h-5 w-5 text-ui-info-text mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"/>
                <path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"/>
              </svg>
              <div class="ml-3">
                <h3 class="text-sm font-medium text-ui-info-text">予約受付完了のメールをお送りしました！</h3>
                <p class="mt-1 text-sm text-ui-info-text">
                  会場の住所や駐車場情報なども記載しています。メールが届かない場合は、迷惑メールフォルダもご確認ください。<br>
                  予約の確認やキャンセルは、このページ（Webアプリ上）でおこなえます<br>
                  <br>
                  送信元アドレス: shiawasenehito3000@gmail.com
                </p>
              </div>
            </div>
          </div>
        `;
    } else if (studentHasEmail && emailPreference && isReservationComplete) {
      emailNoticeHtml = `
          <div class="bg-ui-surface rounded-lg p-3 mt-4">
            <p class="text-sm text-brand-subtle text-center">
            予約受付完了のメールをお送りしました！<br>
            （会場の住所や駐車場情報なども記載）<br>
            <br>
            送信元アドレス: shiawasenehito3000@gmail.com
          </p>
          </div>
        `;
    }

    let nextBookingHtml = '';

    // 該当教室の未来の予約枠が存在する場合
    if (classroom && stateManager.getState().lessons) {
      // バックエンドで計算済みの空き情報を直接使用
      const relevantLessons = stateManager
        .getState()
        .lessons.filter(lesson => lesson.schedule.classroom === classroom);
      const bookingLessonsHtml = renderBookingLessons(relevantLessons);

      if (bookingLessonsHtml) {
        // 予約完了時と会計完了時で表記を変更
        const sectionTitle = isReservationComplete
          ? '▼ さらに よやく ▼'
          : '▼ つぎの よやく ▼';

        nextBookingHtml = `
            <div class="mt-0 pt-0">
                <h3 class="text-xl font-bold text-brand-text text-center mb-4">${sectionTitle}</h3>
                <div class="${DesignConfig.cards.container}">
                ${bookingLessonsHtml}
                </div>
            </div>`;
      }
    }

    // チェックマークの色を状況に応じて変更
    const checkmarkColorClass = isReservationComplete
      ? 'text-state-available-text' // 予約完了時: 緑系
      : 'text-yellow-500'; // 会計完了時: 黄色系

    return `
      <div class="text-center pt-6 pb-4">
          <div class="mb-6">
              <svg class="w-12 h-12 mx-auto ${checkmarkColorClass}" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
              </svg>
          </div>

          <h1 class="text-2xl font-bold ${DesignConfig.colors.text} mb-3">ありがとうございました</h1>
          <p class="${DesignConfig.colors.textSubtle} mb-6 text-lg">${msg}</p>

          ${emailNoticeHtml}

          <div class="max-w-xs mx-auto mt-6 mb-6">
               ${Components.button({
                 text: 'ホームへもどる',
                 action: 'goToDashboard',
                 style: 'secondary',
                 size: 'normal',
               })}
          </div>

          ${nextBookingHtml}

      </div>`;
  };


  // =================================================================
  // 14_WebApp_Handlers.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />
  /// <reference path="../../types/accounting.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 14_WebApp_Handlers.js
   * 【バージョン】: 2.0
   * 【役割】: WebAppのフロントエンドにおける、ユーザーの操作に応じた
   * アクションと、アプリケーション全体の制御フローを集約します。
   * 【構成】: 14ファイル構成のうちの14番目（機能別分割済み）
   * 【v2.0での変更点】:
   * - ファイル分割によるメンテナンス性向上
   * - 機能別アクションハンドラーの統合管理
   * - AI作業効率向上のための構造最適化
   * =================================================================
   */

  // =================================================================
  // --- 分割ファイル統合パターン ---
  // -----------------------------------------------------------------
  // 本ファイルは分割された機能別ファイルのハンドラーを統合します
  // ビルド時に各分割ファイルの内容が展開されます
  // =================================================================

  // =================================================================
  // --- Action Handlers Integration ---
  // -----------------------------------------------------------------
  // 各分割ファイルで定義されたアクションハンドラーを統合
  // =================================================================

  // actionHandlersの定義は他のハンドラーが全て定義された後に行う
  // （このファイルを最後に処理するため、その時点で他のハンドラーは利用可能）

  /** @type {ActionHandlers} */
  let actionHandlers;

  // =================================================================
  // --- Application Core Functions ---
  // -----------------------------------------------------------------
  // アプリケーションの起動、状態管理、画面描画など、
  // 全体を制御するコアとなる関数群です。
  // =================================================================

  /** @type {ClassifiedAccountingItems} */
  const EMPTY_CLASSIFIED_ITEMS = /** @type {ClassifiedAccountingItems} */ ({
    tuition: { baseItems: [], additionalItems: [] },
    sales: { materialItems: [], productItems: [] },
  });

  // Window型の拡張（型エラー回避のため）
  /** @type {Window & { tempPaymentData?: TempPaymentData; isProduction?: boolean; }} */
  const windowTyped = window;

  /**
   * 現在のアプリケーションの状態に基づいて、適切なビューを描画する
   * データ更新の必要性を判定し、必要に応じて最新データ取得後に再描画
   * stateManager.getState().viewの値に応じて対応するビュー関数を呼び出してUIを更新
   */
  function render() {
    // appStateの安全な参照確認
    const appState = window.stateManager?.getState();
    if (!appState) {
      console.warn('render(): stateManagerが未初期化のため処理をスキップします');
      return;
    }

    console.log('🎨 render実行:', appState.view);

    // 無限ループを避けるため、データ更新処理は削除
    // 単純にビューを描画するだけ

    let v = '';
    switch (appState.view) {
      case 'login':
        v = getLoginView();
        break;
      case 'register':
        v = getRegisterView(
          /** @type {string | undefined} */ (
            /** @type {any} */ (appState).registrationPhone
          ),
        );
        break;
      case 'registrationStep2':
        v = getRegistrationStep2View();
        break;
      case 'registrationStep3':
        v = getRegistrationStep3View();
        break;
      case 'registrationStep4':
        v = getRegistrationStep4View();
        break;
      case 'dashboard':
        v = getDashboardView();
        break;
      case 'editProfile':
        v = getEditProfileView();
        break;
      case 'bookingLessons':
        v = getBookingView(appState.selectedClassroom);
        break;
      case 'reservationForm':
        v = getReservationFormView();
        break;
      case 'accounting':
        // 会計画面用のデータを取得
        const reservationData = appState.accountingReservation;
        const classroom = reservationData?.classroom || '';

        // 事前初期化されたキャッシュを優先使用
        const accountingCache = /** @type {any} */ (window).accountingSystemCache;
        let classifiedItems = null;

        if (accountingCache && classroom && accountingCache[classroom]) {
          // キャッシュから高速取得
          classifiedItems = accountingCache[classroom];
          if (!window.isProduction) {
            console.log('✅ 会計システムキャッシュ使用:', classroom);
          }
        } else {
          // フォールバック: リアルタイム初期化
          const masterData = appState.accountingMaster || [];
          if (
            typeof initializeAccountingSystem === 'function' &&
            masterData.length > 0 &&
            classroom
          ) {
            v = initializeAccountingSystem(
              masterData,
              classroom,
              {},
              reservationData,
            );
            break;
          } else {
            classifiedItems = EMPTY_CLASSIFIED_ITEMS;
          }
        }

        // キャッシュされたデータでHTML生成
        if (classifiedItems) {
          // グローバル変数に設定（イベント処理で使用）
          window.currentClassifiedItems = classifiedItems;
          window.currentClassroom = classroom;

          // 会計画面HTML生成
          const formData = {};
          v = generateAccountingView(
            classifiedItems,
            classroom,
            formData,
            reservationData,
          );

          // キャッシュ使用時の初期化処理を予約
          setTimeout(() => {
            // 支払い方法UI初期化
            if (typeof initializePaymentMethodUI === 'function') {
              initializePaymentMethodUI('');
            }

            // イベントリスナー設定
            if (typeof setupAccountingEventListeners === 'function') {
              setupAccountingEventListeners(classifiedItems, classroom);
            }

            // 初期計算実行
            if (typeof updateAccountingCalculation === 'function') {
              updateAccountingCalculation(classifiedItems, classroom);
            }
          }, 100);
        }
        break;
      case 'complete':
        v = getCompleteView(
          /** @type {string | undefined} */ (
            /** @type {any} */ (appState).completionMessage
          ),
        );
        break;
    }
    document.getElementById('view-container').innerHTML =
      `<div class="fade-in">${v}</div>`;

    // もどるボタンを動的に更新
    const backButtonContainer = document.getElementById('back-button-container');
    if (backButtonContainer) {
      backButtonContainer.innerHTML = Components.createSmartBackButton(
        appState.view,
        appState,
      );
    }

    // 会計画面の場合、イベントリスナーを設定
    if (appState.view === 'accounting') {
      // DOM更新後にイベントリスナーを設定するため、次のフレームで実行
      requestAnimationFrame(() => {
        // 事前設定されたグローバル変数から取得（キャッシュ活用）
        const classifiedItems =
          window.currentClassifiedItems || EMPTY_CLASSIFIED_ITEMS;
        const classroom = window.currentClassroom || '';

        if (typeof setupAccountingEventListeners === 'function') {
          setupAccountingEventListeners(classifiedItems, classroom);
        }
        // 初期計算も実行
        if (typeof updateAccountingCalculation === 'function') {
          updateAccountingCalculation(classifiedItems, classroom);
        }
      });
    }

    window.scrollTo(0, 0);
  }

  /**
   * 会計画面での入力変更を処理します。
   * 合計金額の再計算と、入力内容のキャッシュ保存を行います。
   */
  function handleAccountingFormChange() {
    // リアルタイムで合計金額を再計算
    if (typeof updateAccountingCalculation === 'function') {
      // 会計画面用のデータを取得
      const classifiedItems =
        window.currentClassifiedItems || EMPTY_CLASSIFIED_ITEMS;
      const classroom = window.currentClassroom || '';
      updateAccountingCalculation(classifiedItems, classroom);
    }

    // フォーム内容が変更されたら、キャッシュに保存する
    const reservationId =
      stateManager.getState().accountingReservation?.reservationId;
    if (reservationId) {
      const accountingData =
        typeof collectAccountingFormData === 'function'
          ? collectAccountingFormData()
          : {};
      saveAccountingCache(accountingData);
    }
  }

  /**
   * アプリケーションの起動点です。
   * ページ読み込み完了時に実行され、イベントリスナーを設定します。
   */
  window.onload = function () {
    // 全てのハンドラーが定義された後でactionHandlersを構築

    // デバッグ：reservationActionHandlersの状態確認
    if (!window.isProduction) {
      console.log('🔧 reservationActionHandlers確認:', {
        defined: typeof reservationActionHandlers !== 'undefined',
        hasCancel: typeof reservationActionHandlers?.cancel === 'function',
        keys:
          typeof reservationActionHandlers !== 'undefined'
            ? Object.keys(reservationActionHandlers)
            : [],
      });
    }

    actionHandlers = {
      // =================================================================
      // --- Core Navigation Handlers ---
      // -----------------------------------------------------------------
      /** スマートナビゲーション: 前の画面にもどる */
      smartGoBack: () => {
        const backState = stateManager.goBack();
        stateManager.dispatch({
          type: 'SET_STATE',
          payload: backState,
        });
      },

      /** モーダルの確認ボタンを押したときの処理です */
      modalConfirm: () => {
        ModalManager.executeCallback();
        hideModal();
      },

      /** モーダルのキャンセルボタンを押したときの処理です */
      modalCancel: () => hideModal(),

      // =================================================================
      // --- Authentication Handlers (from 14_WebApp_Handlers_Auth.js) ---
      // -----------------------------------------------------------------
      ...(typeof authActionHandlers !== 'undefined' ? authActionHandlers : {}),

      // =================================================================
      // --- History Management Handlers (from 14_WebApp_Handlers_History.js) ---
      // -----------------------------------------------------------------
      ...(typeof historyActionHandlers !== 'undefined'
        ? historyActionHandlers
        : {}),

      // =================================================================
      // --- Reservation Handlers (from 14_WebApp_Handlers_Reservation.js) ---
      // -----------------------------------------------------------------
      ...(typeof reservationActionHandlers !== 'undefined'
        ? reservationActionHandlers
        : {}),

      // =================================================================
      // --- Accounting Handlers (整理済み) ---
      // -----------------------------------------------------------------

      /** 会計画面に遷移（新システム対応版） */
      goToAccounting: (/** @type {{ reservationId: string }} */ d) => {
        showLoading('accounting');
        const reservationId = d.reservationId;

        // 統一検索関数を使用して予約データを取得
        const reservationResult = findReservationById(reservationId);
        const reservationData = reservationResult
          ? {
              ...reservationResult,
              date: reservationResult.date
                ? String(reservationResult.date).split('T')[0]
                : '',
            }
          : null;

        if (reservationData) {
          // 会計マスタデータを取得
          const state = stateManager.getState();
          const accountingMaster = state.accountingMaster || [];

          // 予約データを状態に設定して会計画面に遷移
          stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              view: 'accounting',
              accountingReservation: reservationData,
              accountingMaster: accountingMaster,
            },
          });

          hideLoading();
        } else {
          hideLoading();
          showInfo('予約・記録情報が見つかりませんでした。');
        }
      },

      /** 履歴から会計処理（簡素版） */
      goToAccountingHistory: (/** @type {{ reservationId: string }} */ d) => {
        // 通常の会計画面遷移と同じ処理
        actionHandlers.goToAccounting(d);
      },

      /** 会計を修正（きろくカードの会計修正ボタン） */
      editAccountingRecord: (/** @type {{ reservationId: string }} */ d) => {
        // 会計画面遷移と同じ処理
        actionHandlers.goToAccounting(d);
      },

      /** 支払い確認モーダルを表示 */
      showPaymentModal: () => {
        // 会計画面から支払い確認モーダルを表示する
        const state = stateManager.getState();
        const classroom = state.accountingReservation?.classroom;
        const classifiedItems = window.currentClassifiedItems;

        if (classifiedItems && classroom) {
          // 12_WebApp_Core_Accounting.jsの関数を呼び出し
          if (typeof showPaymentConfirmModal === 'function') {
            showPaymentConfirmModal(classifiedItems, classroom);
          } else {
            console.error('showPaymentConfirmModal関数が見つかりません');
            showInfo('支払い確認モーダルの表示でエラーが発生しました。');
          }
        } else {
          showInfo('会計データが不足しています。');
        }
      },

      /** 支払い完了処理（ローディング→完了画面の流れ） */
      confirmAndPay: () => {
        // window.tempPaymentDataが存在する場合はそれを使用（支払い確認モーダルから呼び出された場合）
        if (windowTyped.tempPaymentData) {
          if (!windowTyped.isProduction) {
            console.log(
              '🔍 confirmAndPay: tempPaymentDataを使用',
              windowTyped.tempPaymentData,
            );
          }
          const { formData, result, classifiedItems, classroom } =
            windowTyped.tempPaymentData;

          // processAccountingPayment関数を直接呼び出し
          if (typeof processAccountingPayment === 'function') {
            processAccountingPayment(
              formData,
              result,
              classifiedItems,
              classroom,
            );
          } else {
            console.error('processAccountingPayment関数が見つかりません');
          }
          return;
        }

        // 従来の処理（tempPaymentDataがない場合のフォールバック）
        const state = stateManager.getState();
        const reservationId = state.accountingReservation?.reservationId;
        const classroom = state.accountingReservation?.classroom;
        const studentId = state.currentUser?.studentId;

        if (!reservationId || !classroom || !studentId) {
          showInfo('必要な情報が不足しています。');
          return;
        }

        // フォームデータを収集（統合会計ファイルの関数を使用）
        const formData =
          typeof collectAccountingFormData === 'function'
            ? collectAccountingFormData()
            : {};

        // 支払い方法が選択されていない場合はエラー
        if (!formData.paymentMethod) {
          showInfo('支払い方法を選択してください。');
          return;
        }

        // ペイロード準備
        const payload = {
          reservationId,
          classroom,
          studentId,
          userInput: formData,
        };

        // モーダルを閉じてローディング開始
        hideModal();
        showLoading('accounting');

        // バックエンド送信
        if (typeof google !== 'undefined' && google.script && google.script.run) {
          google.script.run['withSuccessHandler'](
            (/** @type {ServerResponse<any>} */ response) => {
              hideLoading();
              if (response.success) {
                // データを最新に更新
                if (response.data) {
                  stateManager.dispatch({
                    type: 'SET_STATE',
                    payload: response.data,
                  });
                }

                // 成功時：完了画面を表示
                const completionMessage = `会計情報を記録しました。`;
                const currentState = stateManager.getState();
                stateManager.dispatch({
                  type: 'SET_STATE',
                  payload: {
                    view: 'complete',
                    completionMessage: completionMessage,
                    selectedClassroom:
                      currentState.accountingReservation?.classroom,
                  },
                });
              } else {
                showInfo('会計処理に失敗しました: ' + (response.message || ''));
              }
            },
          )
            ['withFailureHandler']((/** @type {Error} */ error) => {
              hideLoading();
              console.error('会計処理エラー:', error);
              showInfo('会計処理でエラーが発生しました。');
            })
            .saveAccountingDetailsAndGetLatestData(payload);
        } else {
          hideLoading();
          showInfo('システムエラー：Google Apps Scriptとの通信ができません。');
        }
      },

      // --- モーダル関連アクション ---

      /** 支払い確認モーダルをキャンセル */
      cancelPaymentConfirm: () => {
        if (!window.isProduction) {
          console.log('🔵 cancelPaymentConfirm実行');
        }

        if (typeof closePaymentConfirmModal === 'function') {
          closePaymentConfirmModal();
        } else {
          console.warn('closePaymentConfirmModal関数が見つかりません');
        }
      },

      /** 支払い確定処理（confirmAndPayのエイリアス） */
      confirmPayment: () => {
        actionHandlers.confirmAndPay();
      },

      /** 会計確認画面表示 */
      showAccountingConfirmation: () => {
        if (!window.isProduction) {
          console.log('🔵 showAccountingConfirmation実行');
        }
        // 現在のconfirmAndPayと同じ動作
        actionHandlers.confirmAndPay();
      },

      /** 支払い処理を実行 */
      processPayment: () => {
        if (!window.isProduction) {
          console.log('🔵 processPayment実行（グローバルハンドラー）');
        }

        if (typeof handleProcessPayment === 'function') {
          handleProcessPayment();
        } else {
          console.warn('handleProcessPayment関数が見つかりません');
        }
      },
    };

    // アプリケーションの初期化が完了するまでローディング画面を表示
    showLoading('default');

    /** @type {HTMLElement | null} */
    const app = document.getElementById('app');

    if (!app) {
      console.error('アプリケーション要素が見つかりません');
      return;
    }

    // イベントハンドラー関数を定義
    /** @type {ClickEventHandler} */
    const handleClick = e => {
      // DOM要素の型安全性を確保
      if (!e.target || !(e.target instanceof Element)) {
        return;
      }

      // 【修正】buttonまたはdata-action属性を持つ要素を対象にする
      const targetElement = e.target.closest('button, [data-action]');
      if (targetElement?.dataset?.['action']) {
        const action = targetElement.dataset['action'];
        const { action: _, ...data } = targetElement.dataset;

        // デバッグ情報を追加
        if (!window.isProduction) {
          console.log('🔘 クリックイベント:', {
            action,
            data,
            element: targetElement,
            tagName: targetElement.tagName,
            modalContext: e.target.closest('[data-modal-content]')
              ? 'モーダル内'
              : '通常',
            timestamp: new Date().getTime(),
            eventPhase: e.eventPhase,
          });
        }

        // モーダル内の場合は、イベント伝播を継続する
        if (
          e.target.closest('[data-modal-content]') &&
          targetElement.dataset['action']
        ) {
          // イベント伝播を停止しない（モーダル内のボタンを有効にする）
        }

        if (typeof actionHandlers[action] === 'function') {
          // モーダル関連のアクションとスクロール防止が必要なアクションは重複実行を防ぐためイベント伝播を停止
          if (
            action === 'processPayment' ||
            action === 'cancelPaymentConfirm' ||
            action === 'expandHistoryCard' ||
            action === 'closeEditMode' ||
            action === 'saveAndCloseMemo' ||
            action === 'saveInlineMemo'
          ) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
          }

          // 特殊なハンドラー（copyToClipboard, copyGrandTotal）はtargetElementを渡す
          if (action === 'copyToClipboard' || action === 'copyGrandTotal') {
            /** @type {(data: any) => void} */ (actionHandlers[action])({
              ...data,
              targetElement,
            });
          } else {
            /** @type {(data: any) => void} */ (actionHandlers[action])(data);
          }
        } else {
          // ハンドラーが見つからない場合のデバッグ
          if (!window.isProduction) {
            console.warn('⚠️ アクションハンドラーが見つかりません:', action);
          }
        }
      }
    };

    // デバッグ：actionHandlers構築後の確認
    if (!window.isProduction) {
      console.log('🔧 actionHandlers構築完了:', {
        hasCancel: typeof actionHandlers['cancel'] === 'function',
        totalHandlers: Object.keys(actionHandlers).length,
        reservationHandlers: Object.keys(actionHandlers).filter(key =>
          ['cancel', 'confirmBooking', 'goToEditReservation'].includes(key),
        ),
      });
    }

    // アプリ要素とdocument両方でクリックイベントを捕捉（モーダル対応）
    // 重複を避けるため、documentレベルのみでイベントを処理
    document.addEventListener('click', handleClick);

    // アプリ全体の入力・変更イベントを捕捉
    /** @type {ChangeEventHandler} */
    const handleChange = e => {
      // DOM要素の型安全性を確保
      if (!e.target || !(e.target instanceof Element)) {
        return;
      }

      // 会計モーダルでの支払い方法選択
      if (
        e.target.matches('#modal-accounting-form input[name="payment-method"]')
      ) {
        /** @type {HTMLButtonElement | null} */
        const confirmButton = /** @type {HTMLButtonElement | null} */ (
          document.getElementById('confirm-payment-button')
        );
        confirmButton?.removeAttribute('disabled');

        // 選択された支払方法に応じて情報を動的に更新
        const selectedPaymentMethod = /** @type {HTMLInputElement} */ (e.target)
          .value;
        /** @type {HTMLElement | null} */
        const paymentInfoContainer = document.getElementById(
          'payment-info-container',
        );
        if (paymentInfoContainer) {
          paymentInfoContainer.innerHTML = getPaymentInfoHtml(
            selectedPaymentMethod,
          );
        }
      }

      // 会計画面での変更（主に select や checkbox）
      const accountingForm = e.target.closest('#accounting-form');
      if (stateManager.getState().view === 'accounting' && accountingForm) {
        handleAccountingFormChange();

        // デバッグログ
        if (!window.isProduction) {
          const target = /** @type {HTMLInputElement} */ (e.target);
          console.log('🔄 会計フォーム変更イベント:', {
            element: target.name || target.id,
            value: target.value,
            checked: target.checked,
          });
        }
      }

      // 新規登録Step3での経験有無による表示切り替え
      const inputTarget = /** @type {HTMLInputElement} */ (e.target);
      if (inputTarget.name === 'experience') {
        /** @type {HTMLElement | null} */
        const pastWorkContainer = document.getElementById('past-work-container');
        if (pastWorkContainer) {
          pastWorkContainer.classList.toggle(
            'hidden',
            inputTarget.value === 'はじめて！',
          );
        }
      }
    };

    app.addEventListener('change', handleChange);

    // アプリ全体の入力イベントを捕捉（主に text や textarea）
    /** @type {InputEventHandler} */
    const handleInput = e => {
      // DOM要素の型安全性を確保
      if (!e.target || !(e.target instanceof Element)) {
        return;
      }

      // 会計画面での変更
      const accountingForm = e.target.closest('#accounting-form');
      if (stateManager.getState().view === 'accounting' && accountingForm) {
        handleAccountingFormChange();
      }

      // 電話番号入力のリアルタイム整形（type="tel"のすべての入力フィールド）
      const target = /** @type {HTMLInputElement} */ (e.target);
      if (target.type === 'tel') {
        handlePhoneInputFormatting(target);
      }
    };

    app.addEventListener('input', handleInput);

    // 初期画面を描画
    render();

    // 初期画面の描画が完了したらローディング画面を非表示にする
    hideLoading();
  };


  // =================================================================
  // 14_WebApp_Handlers_Auth.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 14_WebApp_Handlers_Auth.js
   * 【バージョン】: 1.1
   * 【役割】: WebAppのフロントエンドにおける、認証・ユーザー管理関連の
   * アクションハンドラーを集約します。
   * 【構成】: 14ファイル構成から分割された認証管理ファイル
   * 【機能範囲】:
   * - ログイン・ログアウト処理
   * - 新規ユーザー登録（4ステップ）
   * - プロフィール管理（表示・編集・保存）
   * =================================================================
   */

  // =================================================================
  // --- Authentication Action Handlers ---
  // -----------------------------------------------------------------
  // 認証・ユーザー管理関連のアクションハンドラー群
  // =================================================================

  /** 認証関連のアクションハンドラー群 */
  const authActionHandlers = {
    /** ログインまたは新規登録を開始します（キャッシュ活用版） */
    login: () => {
      const phoneInput = getInputElementSafely('phone');
      const p = phoneInput?.value || '';
      // 入力値をsetState経由で保存
      window.stateManager.dispatch({
        type: 'UPDATE_STATE',
        payload: { loginPhone: p },
      });
      if (!p) return showInfo('電話番号を入力してください。');

      // 【最適化済み】 フロントエンドでリアルタイム検証（UX向上）
      // バックエンドでは軽量チェックのみ実行（重複処理削減）
      const normalizeResult = window.normalizePhoneNumberFrontend(p);

      if (!normalizeResult.isValid) {
        showInfo(normalizeResult.error || '電話番号の形式が正しくありません。');
        return;
      }

      showLoading('login');
      // 正規化に成功した場合は直接ログイン処理を実行（1回のAPI呼び出し）
      authActionHandlers.processLoginWithValidatedPhone(
        normalizeResult.normalized,
      );
    },

    /** 統合ログイン処理：1回のAPI呼び出しで認証とデータ取得を完了
     * @param {string} normalizedPhone */
    processLoginWithValidatedPhone: normalizedPhone => {
      debugLog('🚀 統合ログイン開始 - 認証+データ一括取得');

      // 統合エンドポイントで認証とすべてのデータを一括取得
      google.script.run['withSuccessHandler']((/** @type {any} */ response) => {
        if (response.success && response.userFound) {
          debugLog(
            '✅ 統合ログイン成功 - ユーザー: ' + response.user.displayName,
          );
          debugLog(
            `📦 データ一括取得完了: 予約${response.data.myReservations?.length || 0}件, レッスン${response.data.lessons?.length || 0}件`,
          );

          // 完全なアプリ状態を一度に構築
          const newAppState = {
            view: 'dashboard',
            currentUser: response.user,
            myReservations: response.data.myReservations || [],
            //          lessons: response.data.lessons || [],
            classrooms: CONSTANTS.CLASSROOMS
              ? Object.values(CONSTANTS.CLASSROOMS)
              : [],
            accountingMaster: response.data.accountingMaster || [],
            today: new Date().toISOString().split('T')[0],
          };

          hideLoading();
          debugLog('✅ 統合ログイン完了 - 完全なダッシュボード表示');

          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              ...newAppState,
              recordsToShow: CONSTANTS.UI.HISTORY_INITIAL_RECORDS,
              isDataFresh: true,
            },
          });
        } else {
          // 認証失敗 - 新規登録に誘導
          hideLoading();
          debugLog('❌ ユーザー未登録 - 新規登録画面へ');
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              view: 'register',
              registrationPhone: normalizedPhone,
            },
          });
        }
      })
        .withFailureHandler((/** @type {Error} */ err) => {
          debugLog('❌ 統合ログインエラー: ' + err.message);
          hideLoading();
          if (window.FrontendErrorHandler) {
            window.FrontendErrorHandler.handle(
              err,
              'processLoginWithValidatedPhone_integrated',
            );
          }
          handleServerError(err);
        })
        .getLoginData(normalizedPhone);
    },

    /** 新規ユーザー登録：Step1からStep2へ */
    goToStep2: () => {
      const realNameInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('reg-realname')
      );
      const nicknameInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('reg-nickname')
      );
      const phoneInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('reg-phone')
      );

      const realName = realNameInput?.value;
      const nickname = nicknameInput?.value.trim();
      const phone = phoneInput?.value;

      if (!realName) return showInfo('お名前（本名）は必須です。');

      // フロントエンドで電話番号を正規化・バリデーション
      if (phone) {
        const normalizeResult = window.normalizePhoneNumberFrontend(phone);
        if (!normalizeResult.isValid) {
          showInfo(normalizeResult.error || '電話番号の形式が正しくありません。');
          return;
        }
      }

      // 入力値をsetState経由で保存
      const updatedRegistrationData = {
        .../** @type {any} */ (stateManager.getState())?.['registrationData'],
        phone,
        realName,
        nickname: nickname || realName,
      };
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: {
          registrationData: updatedRegistrationData,
          registrationStep: 2,
          view: 'registrationStep2',
        },
      });
    },

    /** 新規ユーザー登録：Step2からStep1へもどる */
    backToStep1: () => {
      const emailInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('q-email')
      );
      const wantsEmailInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('q-wants-email')
      );
      const ageGroupInput = /** @type {HTMLSelectElement | null} */ (
        document.getElementById('q-age-group')
      );
      const genderInput = /** @type {HTMLInputElement | null} */ (
        document.querySelector('input[name="gender"]:checked')
      );
      const dominantHandInput = /** @type {HTMLInputElement | null} */ (
        document.querySelector('input[name="dominantHand"]:checked')
      );
      const addressInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('q-address')
      );

      const step2Data = {
        email: emailInput?.value || '',
        wantsEmail: wantsEmailInput?.checked || false,
        ageGroup: ageGroupInput?.value || '',
        gender: genderInput?.value || '',
        dominantHand: dominantHandInput?.value || '',
        address: addressInput?.value || '',
      };

      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: {
          registrationData: {
            .../** @type {any} */ (stateManager.getState())?.['registrationData'],
            ...step2Data,
          },
          registrationStep: 1,
          view: 'register',
        },
      });
    },

    /** 新規ユーザー登録：Step2からStep3へ進む */
    goToStep3: () => {
      const emailInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('q-email')
      );
      const email = emailInput?.value;
      if (!email || !email.includes('@')) {
        return showInfo('有効なメールアドレスを入力してください。');
      }

      const wantsEmailInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('q-wants-email')
      );
      const ageGroupInput = /** @type {HTMLSelectElement | null} */ (
        document.getElementById('q-age-group')
      );
      const genderInput = /** @type {HTMLInputElement | null} */ (
        document.querySelector('input[name="gender"]:checked')
      );
      const dominantHandInput = /** @type {HTMLInputElement | null} */ (
        document.querySelector('input[name="dominantHand"]:checked')
      );
      const addressInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('q-address')
      );

      const step2Data = {
        email: email,
        wantsEmail: wantsEmailInput?.checked || false,
        ageGroup: ageGroupInput?.value || '',
        gender: genderInput?.value || '',
        dominantHand: dominantHandInput?.value || '',
        address: addressInput?.value || '',
      };

      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: {
          registrationData: {
            .../** @type {any} */ (stateManager.getState())?.['registrationData'],
            ...step2Data,
          },
          registrationStep: 3,
          view: 'registrationStep3',
        },
      });
    },

    /** 新規ユーザー登録：Step3からStep2へもどる */
    backToStep2: () =>
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: {
          view: 'registrationStep2',
          registrationStep: 2,
        },
      }),

    /** 新規ユーザー登録：Step3からStep4へ進む */
    proceedToStep4: () => {
      /** @type {HTMLInputElement | null} */
      const experienceInput = document.querySelector(
        'input[name="experience"]:checked',
      );
      const pastWorkInput = /** @type {HTMLTextAreaElement | null} */ (
        document.getElementById('q-past-work')
      );
      const futureGoalInput = /** @type {HTMLTextAreaElement | null} */ (
        document.getElementById('q-future-goal')
      );

      const step3Data = {
        experience: experienceInput?.value || '',
        pastWork: pastWorkInput?.value || '',
        futureGoal: futureGoalInput?.value || '',
      };
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: {
          registrationData: {
            .../** @type {any} */ (
              stateManager.getState()['registrationData'] || {}
            ),
            ...step3Data,
          },
          registrationStep: 4,
          view: 'registrationStep4',
        },
      });
    },

    /** 新規ユーザー登録：Step4からStep3へもどる */
    backToStep3: () =>
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: {
          view: 'registrationStep3',
          registrationStep: 3,
        },
      }),

    /** 新規ユーザー登録：最終データをサーバーに送信（簡素化版） */
    submitRegistration: () => {
      /** @type {HTMLInputElement | null} */
      const futureParticipationInput = document.querySelector(
        'input[name="futureParticipation"]:checked',
      );
      const triggerInput = /** @type {HTMLSelectElement | null} */ (
        document.getElementById('q-trigger')
      );
      const firstMessageInput = /** @type {HTMLTextAreaElement | null} */ (
        document.getElementById('q-first-message')
      );

      const step4Data = {
        futureParticipation: futureParticipationInput?.value || '',
        trigger: triggerInput?.value || '',
        firstMessage: firstMessageInput?.value || '',
      };

      const finalUserData = {
        .../** @type {any} */ (stateManager.getState()['registrationData'] || {}),
        ...step4Data,
      };

      showLoading('booking');
      google.script.run['withSuccessHandler'](
        (
          /** @type {ServerResponse<{ user: UserData; message: string }>} */ res,
        ) => {
          if (!window.isProduction) {
            console.log('🔍 registerNewUser レスポンス:', res);
          }
          hideLoading();
          if (res.success && res.data) {
            // 登録成功時は直接ダッシュボードに遷移（データは後からロード）
            showInfo('新規ユーザー登録が完了しました');

            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                currentUser: res.data.user,
                view: 'dashboard',
                myReservations: [], // 新規ユーザーは予約がない
                lessons: [], // データは必要に応じて後からロード
                isDataFresh: false, // データを後でリフレッシュする必要があることを示す
              },
            });
          } else {
            showInfo(res.message || '登録に失敗しました');
          }
        },
      )
        ['withFailureHandler']((/** @type {Error} */ error) => {
          hideLoading();
          if (window.FrontendErrorHandler) {
            window.FrontendErrorHandler.handle(
              error,
              'submitRegistration:registerNewUser',
              { finalUserData },
            );
          }
          handleServerError(error);
        })
        .registerNewUser(finalUserData);
    },

    /** プロフィール情報を保存します（キャッシュ活用版） */
    saveProfile: () => {
      const realNameInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('edit-realname')
      );
      const nicknameInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('edit-nickname')
      );

      const r = realNameInput?.value;
      let n = nicknameInput?.value.trim();
      if (!r) return showInfo('お名前（本名）は必須です。');
      if (!n) n = r;

      // NF-01: 電話番号入力欄があればその値も取得
      const phoneInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('edit-phone')
      );
      const phone =
        phoneInput?.value || stateManager.getState().currentUser.phone; // 電話番号入力欄がなければ既存の電話番号を使用

      // 電話番号が入力されている場合のみバリデーション
      if (phoneInput?.value) {
        const normalizeResult = window.normalizePhoneNumberFrontend(
          phoneInput.value,
        );
        if (!normalizeResult.isValid) {
          showInfo(normalizeResult.error || '電話番号の形式が正しくありません。');
          return;
        }
      }

      // メール情報の取得とバリデーション
      const emailInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('edit-email')
      );
      const wantsEmailInput = /** @type {HTMLInputElement | null} */ (
        document.getElementById('edit-wants-email')
      );
      const email = emailInput?.value?.trim() || '';
      const wantsEmail =
        wantsEmailInput?.checked ||
        stateManager.getState().currentUser.wantsEmail;

      // メールアドレスの必須バリデーション
      if (!email || !email.includes('@')) {
        return showInfo('有効なメールアドレスを入力してください。');
      }

      const u = {
        ...stateManager.getState().currentUser,
        realName: r,
        displayName: n,
        phone: phone,
        email: email || '',
        wantsEmail: wantsEmail || false,
      };
      showLoading('booking');
      google.script.run['withSuccessHandler']((/** @type {any} */ res) => {
        hideLoading();
        if (res.success) {
          // プロフィール更新後、キャッシュも更新されているのでそのまま状態更新
          showInfo('プロフィールを更新しました');
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              currentUser: res.updatedUser,
              view: 'dashboard',
            },
          });
        } else {
          showInfo(res.message || '更新に失敗しました');
        }
      })
        ['withFailureHandler'](handleServerError)
        .updateUserProfile(u);
    },

    /** プロフィール編集画面に遷移します */
    goToEditProfile: () => {
      // データが古く、かつ更新中でなければデータを更新
      if (
        !stateManager.getState().isDataFresh &&
        !stateManager.getState()._dataUpdateInProgress
      ) {
        updateAppStateFromCache('editProfile');
      } else {
        // 新しいdispatchパターンを使用
        if (window.stateManager) {
          window.stateManager.dispatch({
            type: 'CHANGE_VIEW',
            payload: { view: 'editProfile' },
          });
        } else {
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: { view: 'editProfile' },
          });
        }
      }
    },

    /** ログイン画面に戻ります（電話番号入力値を保存） */
    goBackToLogin: () => {
      const phoneInput = document.getElementById('phone');
      const loginPhone = phoneInput
        ? phoneInput.value
        : stateManager.getState()['loginPhone'];
      window.stateManager.dispatch({
        type: 'NAVIGATE',
        payload: { to: 'login', context: { loginPhone: loginPhone } },
      });
    },
  };


  // =================================================================
  // 14_WebApp_Handlers_History.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 14_WebApp_Handlers_History.js
   * 【バージョン】: 1.0
   * 【役割】: WebAppのフロントエンドにおける、履歴管理関連の
   * アクションハンドラーを集約します。
   * 【構成】: 14ファイル構成から分割された履歴管理ファイル
   * 【機能範囲】:
   * - 履歴カード操作（展開・折りたたみ）
   * - インライン編集（メモ保存）
   * - 履歴表示制御（追加読み込み）
   * =================================================================
   */

  // =================================================================
  // --- History Management Action Handlers ---
  // -----------------------------------------------------------------
  // 履歴管理関連のアクションハンドラー群
  // =================================================================

  /** 履歴管理関連のアクションハンドラー群 */
  const historyActionHandlers = {
    /** きろくカードの確認/編集ボタン
     * @param {ActionHandlerData} d */
    expandHistoryCard: d => {
      // スクロール位置を保存
      const scrollY = window.scrollY;

      // 履歴データを取得
      const item = stateManager
        .getState()
        .myReservations.find(h => h.reservationId === d.reservationId);
      if (!item) return;

      // 編集モード開始（メモの初期値を設定）
      const currentMemo = item.workInProgress || '';
      stateManager.startEditMode(d.reservationId, currentMemo);

      // 該当カードのみを部分更新（ちらつき防止）
      updateSingleHistoryCard(d.reservationId);

      // スクロール位置を復元
      requestAnimationFrame(() => {
        window.scrollTo(0, scrollY);
      });
    },

    /** 編集モードを編集せずに閉じる
     * @param {ActionHandlerData} d */
    closeEditMode: d => {
      // スクロール位置を保存
      const scrollY = window.scrollY;

      // 編集モードを解除（変更を破棄）
      stateManager.endEditMode(d.reservationId);

      // 該当カードのみを部分更新（ちらつき防止）
      updateSingleHistoryCard(d.reservationId);

      // スクロール位置を復元
      requestAnimationFrame(() => {
        window.scrollTo(0, scrollY);
      });
    },

    /** インライン編集のメモを保存
     * @param {ActionHandlerData} d */
    saveInlineMemo: d => {
      // textarea要素から直接値を取得
      /** @type {HTMLTextAreaElement | null} */
      const textarea = document.querySelector(
        `[data-reservation-id="${d.reservationId}"] .memo-edit-textarea`,
      );
      if (!textarea) return;

      const newMemo = textarea.value;

      // 楽観的UI: まずフロントの表示を更新
      const state = window.stateManager.getState();
      const newReservations = state.myReservations.map(h => {
        if (h.reservationId === d.reservationId) {
          return { ...h, workInProgress: newMemo };
        }
        return h;
      });
      window.stateManager.dispatch({
        type: 'UPDATE_STATE',
        payload: { myReservations: newReservations },
      });

      // 編集モードを解除
      stateManager.endEditMode(d.reservationId);

      showInfo('メモを保存しました');

      // 該当カードのみを部分更新（ちらつき防止）
      updateSingleHistoryCard(d.reservationId);

      // サーバーに送信
      showLoading('booking');
      google.script.run['withSuccessHandler']((/** @type {any} */ r) => {
        hideLoading();
        if (!r.success) {
          showInfo(r.message || 'メモの保存に失敗しました');
          // フロント表示を元に戻す
          updateSingleHistoryCard(d.reservationId);
        }
      })
        ['withFailureHandler'](handleServerError)
        .updateReservationMemoAndGetLatestData(
          d.reservationId,
          stateManager.getState().currentUser.studentId,
          newMemo,
        );
    },

    // 新しいアクション：保存と同時に編集モードを終了
    saveAndCloseMemo: function (/** @type {any} */ d) {
      // ボタンからreservationIdが渡された場合
      if (d && d.reservationId) {
        // thisを使って同じオブジェクト内のsaveInlineMemoを呼び出し
        this.saveInlineMemo(d);
      } else {
        console.warn('保存対象のreservationIdが見つかりません');
      }
    },

    /** 参加記録を追加で読み込みます（統合ホーム用） */
    loadMoreHistory: () => {
      const currentCount = stateManager.getState()['recordsToShow'] || 10;
      const newCount =
        Number(currentCount) + (CONSTANTS.UI.HISTORY_LOAD_MORE_RECORDS || 10);

      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: { recordsToShow: newCount },
      });
    },

    /** 会計記録を表示するモーダル
     * @param {ActionHandlerData} d */
    showHistoryAccounting: d => {
      // 予約データを取得
      const state = stateManager.getState();
      const reservation = state.myReservations.find(
        r => r.reservationId === d.reservationId,
      );

      if (!reservation) {
        showInfo('予約データが見つかりません');
        return;
      }

      // 会計詳細データを予約シートから取得
      showLoading('会計記録を読み込み中...');
      google.script.run['withSuccessHandler']((/** @type {any} */ response) => {
        hideLoading();
        if (response.success) {
          // 会計詳細をモーダルで表示
          let details = response.data.accountingDetails || '';

          // JSONオブジェクトの場合は整形してHTML表示
          if (typeof details === 'object' && details !== null) {
            const accounting = details;
            let formattedHtml = '';

            // 授業料情報
            if (accounting.tuition && accounting.tuition.items) {
              formattedHtml += '<div class="mb-4">';
              formattedHtml +=
                '<h4 class="font-medium text-brand-text mb-2">【授業料】</h4>';
              formattedHtml += '<div class="text-sm space-y-1">';
              accounting.tuition.items.forEach((/** @type {any} */ item) => {
                formattedHtml += `<div>・${item.name}: ¥${item.price?.toLocaleString() || 0}</div>`;
              });
              formattedHtml += `<div class="font-medium">小計: ¥${accounting.tuition.subtotal?.toLocaleString() || 0}</div>`;
              formattedHtml += '</div></div>';
            }

            // 販売情報
            if (
              accounting.sales &&
              accounting.sales.items &&
              accounting.sales.items.length > 0
            ) {
              formattedHtml += '<div class="mb-4">';
              formattedHtml +=
                '<h4 class="font-medium text-brand-text mb-2">【販売】</h4>';
              formattedHtml += '<div class="text-sm space-y-1">';
              accounting.sales.items.forEach((/** @type {any} */ item) => {
                formattedHtml += `<div>・${item.name}: ¥${item.price?.toLocaleString() || 0}</div>`;
              });
              formattedHtml += `<div class="font-medium">小計: ¥${accounting.sales.subtotal?.toLocaleString() || 0}</div>`;
              formattedHtml += '</div></div>';
            }

            // 合計と支払方法
            formattedHtml += '<div class="border-t pt-3 mt-3">';
            if (accounting.grandTotal !== undefined) {
              formattedHtml += `<div class="text-lg font-bold text-brand-text">【合計】¥${accounting.grandTotal?.toLocaleString() || 0}</div>`;
            }
            if (accounting.paymentMethod) {
              formattedHtml += `<div class="text-sm text-brand-subtle mt-2">【支払方法】${accounting.paymentMethod}</div>`;
            }
            formattedHtml += '</div>';

            details =
              formattedHtml ||
              '<div class="text-gray-500">会計記録の詳細情報がありません</div>';
          } else if (typeof details === 'string' && details.trim() === '') {
            details = '<div class="text-gray-500">会計記録がありません</div>';
          } else {
            // 文字列の場合は改行をHTMLの<br>に変換
            details = `<div class="whitespace-pre-wrap text-sm">${details.replace(/\n/g, '<br>')}</div>`;
          }

          const headerInfo = `<div class="text-sm text-brand-subtle mb-4">
              <div><strong>日付:</strong> ${formatDate(String(reservation.date))}</div>
              <div><strong>教室:</strong> ${reservation.classroom}</div>
            </div>`;

          // モーダルを動的に作成して表示
          const modalId = 'accounting-details-modal';
          const modalHtml = Components.modal({
            id: modalId,
            title: '会計記録',
            content: headerInfo + details,
            maxWidth: 'max-w-lg',
          });

          // 既存のモーダルがあれば削除
          const existingModal = document.getElementById(modalId);
          if (existingModal) {
            existingModal.remove();
          }

          // モーダルをDOMに追加
          document.body.insertAdjacentHTML('beforeend', modalHtml);

          // モーダルを表示
          Components.showModal(modalId);
        } else {
          showInfo(response.message || '会計記録の取得に失敗しました');
        }
      })
        ['withFailureHandler']((/** @type {Error} */ error) => {
          hideLoading();
          handleServerError(error);
        })
        .getAccountingDetailsFromSheet(d.reservationId);
    },
  };


  // =================================================================
  // 14_WebApp_Handlers_Reservation.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 14_WebApp_Handlers_Reservation.js
   * 【バージョン】: 1.1
   * 【役割】: WebAppのフロントエンドにおける、予約管理関連の
   * アクションハンドラーを集約します。
   * 【構成】: 14ファイル構成から分割された予約管理ファイル
   * 【v1.1での変更点】: JSDocの型定義を更新。予約フォームのコンテキスト生成ロジックを導入。
   * =================================================================
   */

  /** 予約管理関連のアクションハンドラー群 */
  const reservationActionHandlers = {
    /**
     * 予約をキャンセルします。
     * @param {ActionHandlerData} d - キャンセル対象の予約情報を含むデータ
     */
    cancel: d => {
      const message = `
          <div class="text-left space-y-4">
            <p class="text-center"><b>${formatDate(d.date)}</b><br>${d.classroom}<br>この予約を取り消しますか？</p>
            <div class="pt-4 border-t">
              <label class="block text-sm font-bold mb-2">先生へのメッセージ（任意）</label>
              <textarea id="cancel-message" class="w-full p-2 border-2 border-ui-border rounded" rows="3" placeholder=""></textarea>
            </div>
          </div>
        `;
      showConfirm({
          title: '予約の取り消し',
          message: message,
          confirmText: '取り消す',
          cancelText: 'やめる',
          onConfirm: () => {
            // 重複キャンセル防止
            if (stateManager.isDataFetchInProgress('reservation-cancel')) {
              console.log('予約取り消し処理中のためキャンセルをスキップ');
              return;
            }

            showLoading('cancel');
            // 予約取り消し処理中フラグを設定
            stateManager.setDataFetchProgress('reservation-cancel', true);

            const cancelMessageInput = /** @type {HTMLTextAreaElement | null} */ (
              document.getElementById('cancel-message')
            );
            const cancelMessage = cancelMessageInput?.value || '';
            const p = {
              ...d,
              studentId: stateManager.getState().currentUser.studentId,
              cancelMessage: cancelMessage,
            };
            google.script.run['withSuccessHandler']((/** @type {any} */ r) => {
              hideLoading();
              // 予約取り消し処理中フラグをクリア
              stateManager.setDataFetchProgress('reservation-cancel', false);

              if (r.success) {
                if (r.data) {
                  // 予約取り消し後は個人予約データのみ更新（講座データは既存のキャッシュを利用）
                  const currentState = stateManager.getState();
                  const updatedPayload = {
                    myReservations: r.data.myReservations || [],
                    view: 'dashboard',
                    isDataFresh: true,
                  };

                  // 講座データが提供された場合のみ更新
                  if (r.data.lessons && r.data.lessons.length > 0) {
                    updatedPayload.lessons = r.data.lessons;
                    stateManager.setDataFetchProgress('lessons', false);
                  } else {
                    // 講座データが不要な場合は既存データを保持
                    updatedPayload.lessons = currentState.lessons;
                  }

                  window.stateManager.dispatch({
                    type: 'SET_STATE',
                    payload: updatedPayload,
                  });
                } else {
                  window.stateManager.dispatch({
                    type: 'SET_STATE',
                    payload: {
                      view: 'dashboard',
                      isDataFresh: false,
                    },
                  });
                }
                showInfo(r.message || '予約を取り消しました。');
              } else {
                showInfo(r.message || 'キャンセル処理に失敗しました。');
              }
            })
              .withFailureHandler((/** @type {Error} */ err) => {
                hideLoading();
                // エラー時も予約取り消し処理中フラグをクリア
                stateManager.setDataFetchProgress('reservation-cancel', false);
                handleServerError(err);
              })
              .cancelReservationAndGetLatestData(p);
          },
      });
    },

    /**
     * 予約フォームの内容を元に予約を確定します。
     * state.currentReservationFormContext を使用します。
     */
    confirmBooking: () => {
      // 重複予約防止
      if (stateManager.isDataFetchInProgress('reservation-booking')) {
        console.log('予約処理中のため予約確定をスキップ');
        return;
      }

      const { currentUser, currentReservationFormContext } =
        stateManager.getState();
      if (!currentReservationFormContext) {
        showInfo('エラー: 予約コンテキストが見つかりません。');
        return;
      }

      const { lessonInfo } = currentReservationFormContext;
      const isFirstTimeBooking = stateManager.getState().isFirstTimeBooking;

      const startTime = getTimeValue('res-start-time', null, 'startTime');
      const endTime = getTimeValue('res-end-time', null, 'endTime');

      const bookingOptions = {
        chiselRental:
          /** @type {HTMLInputElement} */ (
            document.getElementById('option-rental')
          )?.checked || false,
        firstLecture:
          /** @type {HTMLInputElement} */ (
            document.getElementById('option-first-lecture')
          )?.checked || isFirstTimeBooking,
        workInProgress:
          /** @type {HTMLInputElement} */ (document.getElementById('wip-input'))
            ?.value || '',
        order:
          /** @type {HTMLInputElement} */ (document.getElementById('order-input'))
            ?.value || '',
        messageToTeacher:
          /** @type {HTMLInputElement} */ (
            document.getElementById('message-input')
          )?.value || '',
        materialInfo:
          /** @type {HTMLInputElement} */ (
            document.getElementById('material-input')
          )?.value || '',
      };

      showLoading('booking');
      // 予約処理中フラグを設定
      stateManager.setDataFetchProgress('reservation-booking', true);

      const p = {
        classroom: lessonInfo.schedule.classroom,
        date: lessonInfo.schedule.date,
        venue: lessonInfo.schedule.venue,
        startTime: startTime,
        endTime: endTime,
        user: currentUser,
        studentId: currentUser.studentId,
        options: bookingOptions,
        schedule: lessonInfo.schedule,
        status: lessonInfo.status,
        isFull: lessonInfo.status.isFull,
      };

      google.script.run['withSuccessHandler']((/** @type {any} */ r) => {
        hideLoading();
        // 予約処理中フラグをクリア
        stateManager.setDataFetchProgress('reservation-booking', false);

        if (r.success) {
          if (r.data) {
            // 新規予約後は個人予約データと必要に応じて講座データを更新
            const currentState = stateManager.getState();
                      const updatedPayload = {
              myReservations: r.data.myReservations || [],
              view: 'complete',
              completionMessage: r.message,
              selectedClassroom: lessonInfo.schedule.classroom,
              isDataFresh: true,
            };

            // 講座データの選択的更新
            if (r.data.lessons && r.data.lessons.length > 0) {
              updatedPayload.lessons = r.data.lessons;
              stateManager.setDataFetchProgress('lessons', false);
            } else if (currentState.lessons && currentState.lessons.length > 0) {
              // サーバーが講座データを返さない場合は既存データを保持
              updatedPayload.lessons = currentState.lessons;
            }

            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: updatedPayload,
            });
          } else {
            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                view: 'complete',
                completionMessage: r.message,
                selectedClassroom: lessonInfo.schedule.classroom,
                isDataFresh: false,
              },
            });
          }
        } else {
          showInfo(r.message || '予約に失敗しました。');
        }
      })
        .withFailureHandler((/** @type {Error} */ error) => {
          hideLoading();
          // エラー時も予約処理中フラグをクリア
          stateManager.setDataFetchProgress('reservation-booking', false);
          handleServerError(error);
        })
        .makeReservationAndGetLatestData(p);
    },

    /**
     * 予約編集画面に遷移します。
     * @param {ActionHandlerData} d - 編集対象の予約情報を含むデータ
     */
    goToEditReservation: d => {
      showLoading('booking');
      const reservation = stateManager
        .getState()
        .myReservations.find(
          booking =>
            booking.reservationId === d.reservationId &&
            booking.classroom === d.classroom,
        );

      if (reservation) {
        getScheduleInfoFromCache(
          String(reservation.date),
          reservation.classroom,
        ).then(scheduleInfo => {
          const currentState = stateManager.getState();
          const lesson =
            currentState.lessons && Array.isArray(currentState.lessons)
              ? currentState.lessons.find(
                  l =>
                    l.schedule.date === String(reservation.date) &&
                    l.schedule.classroom === reservation.classroom,
                )
              : null;

          const lessonInfo = lesson || {
            schedule: scheduleInfo || {},
            status: {},
          };

          const formContext = {
            lessonInfo: lessonInfo,
            reservationInfo: reservation,
          };

          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              view: 'reservationForm',
              currentReservationFormContext: formContext,
            },
          });

          hideLoading();
        });
      } else {
        showInfo('予約情報が見つかりませんでした。');
        hideLoading();
      }
    },

    /**
     * 予約情報を更新します。
     * state.currentReservationFormContext を使用します。
     */
    updateReservation: () => {
      // 重複更新防止
      if (stateManager.isDataFetchInProgress('reservation-update')) {
        console.log('予約更新処理中のため更新をスキップ');
        return;
      }

      const { currentReservationFormContext, currentUser } =
        stateManager.getState();
      if (!currentReservationFormContext) {
        showInfo('エラー: 予約コンテキストが見つかりません。');
        return;
      }

      const { reservationInfo } = currentReservationFormContext;
      // 予約編集ではreservationIdは必須
      if (!reservationInfo.reservationId) {
        showInfo('エラー: 予約IDが見つかりません。');
        return;
      }
      const validReservationInfo = /** @type {ReservationData} */ (
        reservationInfo
      );
      const startTime = getTimeValue(
        'res-start-time',
        validReservationInfo,
        'startTime',
      );
      const endTime = getTimeValue(
        'res-end-time',
        validReservationInfo,
        'endTime',
      );

      const p = {
        reservationId: validReservationInfo.reservationId,
        classroom: validReservationInfo.classroom,
        studentId: currentUser.studentId,
        chiselRental:
          /** @type {HTMLInputElement} */ (
            document.getElementById('option-rental')
          )?.checked || false,
        firstLecture:
          /** @type {HTMLInputElement} */ (
            document.getElementById('option-first-lecture')
          )?.checked || false,
        startTime: startTime,
        endTime: endTime,
        workInProgress: /** @type {HTMLInputElement} */ (
          document.getElementById('wip-input')
        ).value,
        order: /** @type {HTMLInputElement} */ (
          document.getElementById('order-input')
        ).value,
        messageToTeacher: /** @type {HTMLInputElement} */ (
          document.getElementById('message-input')
        ).value,
        materialInfo:
          /** @type {HTMLInputElement} */ (
            document.getElementById('material-input')
          )?.value || '',
      };
      showLoading('booking');
      // 予約更新処理中フラグを設定
      stateManager.setDataFetchProgress('reservation-update', true);

      google.script.run['withSuccessHandler'](
        (/** @type {BatchDataResponse} */ r) => {
          hideLoading();
          // 予約更新処理中フラグをクリア
          stateManager.setDataFetchProgress('reservation-update', false);

          if (r.success) {
            if (r.data) {
              // 予約更新後は個人予約データを優先的に更新
              const currentState = stateManager.getState();
                          const updatedPayload = {
                myReservations: r.data.myReservations || [],
                view: 'dashboard',
                isDataFresh: true,
              };

              // initialデータがある場合は追加
              if (r.data.initial) {
                Object.assign(updatedPayload, r.data.initial);
              }

              // 講座データの選択的更新
              if (r.data.lessons && r.data.lessons.length > 0) {
                updatedPayload.lessons = r.data.lessons;
                stateManager.setDataFetchProgress('lessons', false);
              } else if (
                currentState.lessons &&
                currentState.lessons.length > 0
              ) {
                // 既存の講座データを保持
                updatedPayload.lessons = currentState.lessons;
              }

              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: updatedPayload,
              });
            } else {
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  view: 'dashboard',
                  isDataFresh: false,
                },
              });
            }
            showInfo(
              `<h3 class="font-bold mb-3">更新完了</h3>${r.message || '予約内容を更新しました。'}`,
            );
          } else {
            showInfo(r.message || '更新に失敗しました。');
          }
        },
      )
        .withFailureHandler((/** @type {Error} */ error) => {
          hideLoading();
          // エラー時も予約更新処理中フラグをクリア
          stateManager.setDataFetchProgress('reservation-update', false);

          if (window.FrontendErrorHandler) {
            window.FrontendErrorHandler.handle(error, 'updateReservation', {
              reservationId: p.reservationId,
              classroom: p.classroom,
            });
          }
          handleServerError(error);
        })
        .updateReservationDetailsAndGetLatestData(p);
    },

    /** 新規予約のための教室選択モーダルを表示します */
    showClassroomModal: () => {
      if (CONSTANTS.CLASSROOMS && Object.keys(CONSTANTS.CLASSROOMS).length > 0) {
        const existingModal = document.getElementById(
          'classroom-selection-modal',
        );
        if (existingModal) existingModal.remove();
        const modalHtml = getClassroomSelectionModal();
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        Components.showModal('classroom-selection-modal');
      } else {
        showInfo('教室情報の取得に失敗しました。ホームに戻ります。');
        reservationActionHandlers.goBackToDashboard();
      }
    },

    /** 教室選択モーダルを閉じます */
    closeClassroomModal: () => {
      Components.closeModal('classroom-selection-modal');
    },

    /**
     * 教室を選択し、予約枠一覧画面に遷移します。
     * @param {ActionHandlerData} d - 選択した教室情報を含むデータ
     */
    selectClassroom: d => {
      // 教室選択は初回データ取得のため、重複チェックを一時的に無効化
      // if (stateManager.isDataFetchInProgress('lessons')) {
      //   console.log('講座データ取得中のため教室選択をスキップ');
      //   return;
      // }

      let classroomName =
        d?.classroomName || d?.classroom || d?.['classroom-name'];
      if (classroomName) {
        reservationActionHandlers.closeClassroomModal();
        reservationActionHandlers.updateLessonsAndGoToBooking(classroomName);
      } else {
        showInfo('予約枠の取得に失敗しました。時間をおいて再度お試しください。');
      }
    },

    /**
     * スロット情報を更新してから予約枠画面に遷移します。
     * @param {string} classroomName - 対象の教室名
     */
    updateLessonsAndGoToBooking: classroomName => {
      if (stateManager.getState()._dataUpdateInProgress) return;

      // 講座データの初期状態チェック - 初回アクセス時は必ず取得
      const currentState = stateManager.getState();
      const hasValidLessonsData =
        currentState.lessons &&
        Array.isArray(currentState.lessons) &&
        currentState.lessons.length > 0;

      // 講座データが存在し、キャッシュが有効な場合のみ即座に画面遷移
      // 初回アクセス時はhasValidLessonsDataがfalseになるため、この分岐は通らない
      if (hasValidLessonsData) {
        try {
          const needsUpdate = stateManager.needsLessonsUpdate();
          if (!needsUpdate) {
            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                selectedClassroom: classroomName,
                view: 'bookingLessons',
                isDataFresh: true,
              },
            });
            return;
          }
        } catch (error) {
          console.warn('needsLessonsUpdate()でエラー発生:', error);
          // エラー発生時は通常の取得処理を続行
        }
      }

      // 初回アクセスまたはデータ更新が必要な場合のみローディング表示とサーバー確認
      showLoading('booking');
      google.script.run['withSuccessHandler'](
        (
          /** @type {ServerResponse<Record<string, string>>} */ versionResponse,
        ) => {
          if (versionResponse.success && versionResponse.data) {
            const currentLessonsVersion = stateManager.getState()._lessonsVersion;
            const serverLessonsVersion = versionResponse.data['lessonsComposite'];
            const currentLessonsState = stateManager.getState().lessons;
            if (
              currentLessonsVersion === serverLessonsVersion &&
              currentLessonsState &&
              Array.isArray(currentLessonsState) &&
              currentLessonsState.length > 0
            ) {
              hideLoading();
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  selectedClassroom: classroomName,
                  view: 'bookingLessons',
                  isDataFresh: true,
                },
              });
              return;
            }
            reservationActionHandlers.fetchLatestLessonsData(
              classroomName,
              serverLessonsVersion,
            );
          } else {
            reservationActionHandlers.fetchLatestLessonsData(classroomName, null);
          }
        },
      )
        .withFailureHandler(() => {
          reservationActionHandlers.fetchLatestLessonsData(classroomName, null);
        })
        .getCacheVersions();
    },

    /**
     * 最新の講座データを取得します（内部処理）。
     * @param {string} classroomName - 対象の教室名
     * @param {string | null} newLessonsVersion - 新しいバージョン情報
     */
    fetchLatestLessonsData: (classroomName, newLessonsVersion) => {
      // 取得中フラグを設定してダブルクリック防止
      stateManager.setDataFetchProgress('lessons', true);

      google.script.run['withSuccessHandler']((/** @type {any} */ response) => {
        hideLoading();
        // 取得完了をマーク
        stateManager.setDataFetchProgress('lessons', false);

        if (response.success && response.data && response.data.lessons) {
          // バージョンを更新
          if (newLessonsVersion) {
            stateManager.updateLessonsVersion(newLessonsVersion);
          }

          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              lessons: response.data.lessons,
              selectedClassroom: classroomName,
              view: 'bookingLessons',
              isDataFresh: true,
              _lessonsVersion: newLessonsVersion,
            },
          });
        } else {
          showInfo(
            '予約枠の取得に失敗しました。時間をおいて再度お試しください。',
          );
        }
      })
        .withFailureHandler((/** @type {Error} */ error) => {
          hideLoading();
          // エラー時も取得中フラグをクリア
          stateManager.setDataFetchProgress('lessons', false);
          showInfo(
            '予約枠の取得に失敗しました。時間をおいて再度お試しください。',
          );
          Logger.log(`fetchLatestLessonsDataエラー: ${error}`);
        })
        .getBatchData(['lessons'], stateManager.getState().currentUser.phone);
    },

    /**
     * 予約枠を選択し、予約フォーム画面に遷移します。
     * @param {ActionHandlerData} d - 選択した予約枠の情報を含むデータ
     */
    bookLesson: d => {
      const currentState = stateManager.getState();
      const foundLesson =
        currentState.lessons && Array.isArray(currentState.lessons)
          ? currentState.lessons.find(
              lesson =>
                lesson.schedule.classroom === d.classroom &&
                lesson.schedule.date === d.date,
            )
          : null;
      if (foundLesson) {
        const isFirstTime = stateManager.getState().isFirstTimeBooking;
        const formContext = {
          lessonInfo: foundLesson,
          reservationInfo: {
            firstLecture: isFirstTime,
            chiselRental: false,
          },
        };

        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: {
            currentReservationFormContext: formContext,
            view: 'reservationForm',
          },
        });
      } else {
        showInfo('エラーが発生しました。選択した予約枠が見つかりません。');
      }
    },

    /** ホーム（メイン画面）に遷移（別名） */
    goBackToDashboard: () => reservationActionHandlers.goToDashboard(),

    /** ホーム（メイン画面）に遷移 */
    goToDashboard: () => {
      if (
        !stateManager.getState().isDataFresh &&
        !stateManager.getState()._dataUpdateInProgress
      ) {
        updateAppStateFromCache('dashboard');
      } else {
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: { view: 'dashboard' },
        });
      }
    },

    /** 予約枠一覧画面に戻ります */
    goBackToBooking: () => {
      const targetClassroom =
        stateManager.getState().currentReservationFormContext?.lessonInfo.schedule
          .classroom || stateManager.getState().selectedClassroom;

      // StateManagerのキャッシュ判定を優先
      const currentState = stateManager.getState();
      if (
        !stateManager.needsLessonsUpdate() &&
        currentState.lessons &&
        Array.isArray(currentState.lessons) &&
        currentState.lessons.length > 0
      ) {
        // キャッシュが有効で講座データが存在する場合は即座に画面遷移
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: { view: 'bookingLessons', selectedClassroom: targetClassroom },
        });
      } else if (
        !stateManager.getState().isDataFresh &&
        !stateManager.getState()._dataUpdateInProgress
      ) {
        // データが古い場合のみ更新
        reservationActionHandlers.updateLessonsAndGoToBooking(targetClassroom);
      } else {
        // データが新鮮な場合は画面遷移のみ
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: { view: 'bookingLessons', selectedClassroom: targetClassroom },
        });
      }
    },
  };


  // =================================================================
  // 14_WebApp_Handlers_Utils.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../../types/dev-environment.d.ts" />
  /// <reference path="../../types/html-environment.d.ts" />
  /// <reference path="../../types/api-types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 14_WebApp_Handlers_Utils.js
   * 【バージョン】: 1.0
   * 【役割】: WebAppのフロントエンドにおける、ユーティリティ関数と
   * ヘルパー関数を集約します。
   * 【構成】: 14ファイル構成から分割されたユーティリティファイル
   * 【新規作成理由】:
   * - メインハンドラーファイルの肥大化対策
   * - ユーティリティ関数の再利用性向上
   * - AIの作業効率向上のためのファイル分割
   * =================================================================
   */

  // =================================================================
  // --- DOM Type Safety Helper Functions ---
  // -----------------------------------------------------------------
  // DOM要素アクセスの型安全性を確保するヘルパー関数群
  // =================================================================

  /**
   * 型安全なHTMLElement取得ヘルパー
   * @param {string} id - 要素のID
   * @returns {HTMLElement | null}
   */
  function getElementSafely(id) {
    return document.getElementById(id);
  }

  /**
   * 型安全なHTMLInputElement取得ヘルパー
   * @param {string} id - 要素のID
   * @returns {HTMLInputElement | null}
   */
  function getInputElementSafely(id) {
    const element = document.getElementById(id);
    return element instanceof HTMLInputElement ? element : null;
  }

  /**
   * 型安全なHTMLSelectElement取得ヘルパー
   * @param {string} id - 要素のID
   * @returns {HTMLSelectElement | null}
   */
  function getSelectElementSafely(id) {
    const element = document.getElementById(id);
    return element instanceof HTMLSelectElement ? element : null;
  }

  /**
   * 型安全なHTMLFormElement取得ヘルパー
   * @param {string} id - 要素のID
   * @returns {HTMLFormElement | null}
   */
  function getFormElementSafely(id) {
    const element = document.getElementById(id);
    return element instanceof HTMLFormElement ? element : null;
  }

  // =================================================================
  // --- Data Conversion Helper Functions ---
  // -----------------------------------------------------------------
  // データ型変換とバリデーションを行うヘルパー関数群
  // =================================================================

  /**
   * 日付データの型安全性を確保するヘルパー関数
   * @param {string | Date} date - 日付データ
   * @returns {string} 文字列形式の日付
   */
  function ensureDateString(date) {
    if (typeof date === 'string') {
      return date;
    }
    if (date instanceof Date) {
      return date.toISOString().split('T')[0]; // YYYY-MM-DD形式
    }
    return '';
  }

  /**
   * ReservationObjectをReservationDataに安全に変換する
   * @param {ReservationObject} reservationObj - 予約オブジェクト
   * @returns {ReservationData} 変換された予約データ
   */
  function convertToReservationData(reservationObj) {
    return {
      ...reservationObj,
      date: ensureDateString(reservationObj.date),
      startTime:
        typeof reservationObj.startTime === 'string'
          ? reservationObj.startTime
          : '',
      endTime:
        typeof reservationObj.endTime === 'string' ? reservationObj.endTime : '',
    };
  }

  // =================================================================
  // --- Time Data Helper Functions ---
  // -----------------------------------------------------------------
  // 時刻データの取得・処理を行うヘルパー関数群
  // =================================================================

  /**
   * 時刻データを適切に取得するヘルパー関数
   * @param {string} elementId - 時刻入力要素のID
   * @param {ReservationData | null} reservationData - 予約データ（フォールバック用）
   * @param {string} timeField - 時刻フィールド名（'startTime' or 'endTime'）
   * @returns {string} 時刻文字列（HH:mm形式）
   */
  function getTimeValue(elementId, reservationData, timeField) {
    // 1. HTML要素から取得を試行
    const inputElement = getInputElementSafely(elementId);
    const selectElement = getSelectElementSafely(elementId);
    const element = inputElement || selectElement;

    const elementValue = element?.value;
    if (elementValue && elementValue !== '') {
      return elementValue;
    }

    // 2. 予約データから取得を試行（編集時）
    if (reservationData) {
      const headerField =
        /** @type {any} */ (CONSTANTS.HEADERS.RESERVATIONS)?.[
          timeField.toUpperCase()
        ] || timeField;
      const timeValue =
        /** @type {any} */ (reservationData)[headerField] ||
        /** @type {any} */ (reservationData)[timeField];
      if (timeValue && timeValue !== '') {
        return /** @type {string} */ (timeValue);
      }
    }

    // 3. selectedLessonから取得を試行（新規作成時）
    const selectedLesson = stateManager.getState().selectedLesson;
    if (selectedLesson) {
      const headerField =
        /** @type {any} */ (CONSTANTS.HEADERS.RESERVATIONS)?.[
          timeField.toUpperCase()
        ] || timeField;

      // セッション制教室の場合、スケジュール情報から取得
      const classroomType =
        /** @type {any} */ (selectedLesson).schedule?.classroomType ||
        /** @type {any} */ (selectedLesson).classroomType;
      if (classroomType === CONSTANTS.CLASSROOM_TYPES.SESSION_BASED) {
        if (timeField === 'startTime') {
          return (
            selectedLesson.schedule?.firstStart ||
            selectedLesson.schedule?.secondStart ||
            /** @type {any} */ (selectedLesson).firstStart ||
            /** @type {any} */ (selectedLesson).secondStart ||
            ''
          );
        } else if (timeField === 'endTime') {
          return (
            selectedLesson.schedule?.firstEnd ||
            selectedLesson.schedule?.secondEnd ||
            /** @type {any} */ (selectedLesson).firstEnd ||
            /** @type {any} */ (selectedLesson).secondEnd ||
            ''
          );
        }
      }

      // 時間制教室の場合、selectedLessonから取得
      const lessonValue =
        /** @type {any} */ (selectedLesson)[headerField] ||
        /** @type {any} */ (selectedLesson)[timeField];
      if (lessonValue && lessonValue !== '') {
        return lessonValue;
      }
    }

    return '';
  }

  // =================================================================
  // --- Accounting Cache Helper Functions ---
  // -----------------------------------------------------------------
  // 会計フォームのデータを操作するためのヘルパー関数群
  // =================================================================

  // =================================================================
  // --- Phone Number Formatting Helper Functions ---
  // -----------------------------------------------------------------
  // 電話番号入力のリアルタイム整形処理
  // =================================================================

  /**
   * 電話番号入力フィールドのリアルタイム整形処理
   * @param {HTMLInputElement} inputElement - 電話番号入力フィールド
   */
  function handlePhoneInputFormatting(inputElement) {
    if (!inputElement) return;

    const originalValue = inputElement.value;
    const cursorPosition = inputElement.selectionStart;

    // 全角数字を半角に変換
    let formattedValue = originalValue.replace(/[０-９]/g, s =>
      String.fromCharCode(s.charCodeAt(0) - 65248),
    );

    // 数字以外を削除（ハイフンは一時的に残す）
    const digitsOnly = formattedValue.replace(/[^\d]/g, '');

    // フォーマット適用
    let formatted = '';
    if (digitsOnly.length > 0) {
      if (digitsOnly.length <= 3) {
        formatted = digitsOnly;
      } else if (digitsOnly.length <= 7) {
        formatted = `${digitsOnly.slice(0, 3)} ${digitsOnly.slice(3)}`;
      } else if (digitsOnly.length <= 11) {
        // 11桁の場合: 090-1234-5678
        formatted = `${digitsOnly.slice(0, 3)} ${digitsOnly.slice(3, 7)} ${digitsOnly.slice(7)}`;
      } else {
        // 11桁を超える場合は11桁までに制限
        const truncated = digitsOnly.slice(0, 11);
        formatted = `${truncated.slice(0, 3)} ${truncated.slice(3, 7)} ${truncated.slice(7)}`;
      }
    }

    // 値が変更された場合のみ更新
    if (formatted !== originalValue) {
      inputElement.value = formatted;

      // カーソル位置を調整（ハイフンの追加を考慮）
      const newCursorPosition = Math.min(
        cursorPosition + (formatted.length - originalValue.length),
        formatted.length,
      );
      inputElement.setSelectionRange(newCursorPosition, newCursorPosition);
    }
  }

  /**
   * 電話番号を表示用にフォーマットする（090 1234 5678 形式）
   * @param {string} phoneNumber - フォーマットする電話番号
   * @returns {string} フォーマットされた電話番号
   */
  function formatPhoneNumberForDisplay(phoneNumber) {
    if (!phoneNumber) return '';

    // アポストロフィや記号を除去して数字のみにする
    const digitsOnly = phoneNumber.replace(/[^\d]/g, '');

    if (digitsOnly.length === 11) {
      // 11桁の場合: 090 1234 5678
      return `${digitsOnly.slice(0, 3)} ${digitsOnly.slice(3, 7)} ${digitsOnly.slice(7)}`;
    } else if (digitsOnly.length === 10) {
      // 10桁の場合: 03 1234 5678
      return `${digitsOnly.slice(0, 2)} ${digitsOnly.slice(2, 6)} ${digitsOnly.slice(6)}`;
    }

    // その他の場合はそのまま返す
    return phoneNumber;
  }

  // =================================================================
  // --- Application State Management Helper Functions ---
  // -----------------------------------------------------------------
  // アプリケーション状態管理関連のヘルパー関数群
  // =================================================================

  /**
   * バッチ処理でキャッシュから最新データを取得してappStateを更新
   * ユーザーの予約・履歴・スロット情報を一括取得し、指定されたビューに遷移
   * @param {string} targetView - データ取得後に遷移したいビュー名
   */
  function updateAppStateFromCache(targetView) {
    if (
      !stateManager.getState().currentUser ||
      !stateManager.getState().currentUser.phone
    ) {
      if (targetView) {
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: { view: /** @type {ViewType} */ (targetView) },
        });
      }
      return;
    }

    // 更新中フラグを設定
    window.stateManager.dispatch({
      type: 'SET_STATE',
      payload: { _dataUpdateInProgress: true },
    });

    showLoading('dataFetch');
    google.script.run['withSuccessHandler'](
      /** @param {any} response */ response => {
        hideLoading();
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: { _dataUpdateInProgress: false },
        }); // フラグをクリア

        if (response.success && response.userFound) {
          // バッチ処理結果からappStateを更新（initialDataなしでlessons、myReservationsのみ）
          const existingState = stateManager.getState();
          const newAppState = {
            ...existingState,
            lessons: response.data.lessons || [],
            myReservations: response.data.myReservations || [],
          };
          // 現在のビューと重要な状態は保持、ただしtargetViewが指定されていればそちらを優先
          const preservedState = {
            view: /** @type {ViewType} */ (
              targetView || stateManager.getState().view
            ),
            selectedClassroom: stateManager.getState().selectedClassroom,
            selectedLesson: stateManager.getState().selectedLesson,
            editingReservationDetails:
              stateManager.getState().editingReservationDetails,
            accountingReservation: stateManager.getState().accountingReservation,
            isDataFresh: true, // 新鮮なデータが読み込まれたことを記録
          };
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: { ...newAppState, ...preservedState },
          }); // setStateに統合し、状態更新と再描画を一元化
        } else {
          // 失敗時もsetStateを介して状態を更新し、再描画をトリガーする
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              _dataUpdateInProgress: false,
              view: /** @type {ViewType} */ (
                targetView || stateManager.getState().view
              ),
            },
          });
          showInfo(response.message || 'データの取得に失敗しました。');
        }
      },
    )
      ['withFailureHandler'](
        /** @param {any} err */ err => {
          hideLoading();
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              _dataUpdateInProgress: false,
              view: /** @type {ViewType} */ (
                targetView || stateManager.getState().view
              ),
            },
          }); // フラグをクリア
          handleServerError(err);
          // setStateがrenderを呼び出すので、ここでのrender()は不要
        },
      )
      .getBatchData(['lessons'], stateManager.getState().currentUser.phone);
  }

  // =================================================================
  // --- Date Helper Functions ---
  // -----------------------------------------------------------------
  // 日付関連のヘルパー関数群
  // =================================================================

  /**
   * 今日かどうかを判定するヘルパー関数
   * @param {string} dateString - 日付文字列（YYYY-MM-DD形式）
   * @returns {boolean}
   */
  function isDateToday(dateString) {
    const today = new Date();
    const targetDate = new Date(dateString);

    return (
      today.getFullYear() === targetDate.getFullYear() &&
      today.getMonth() === targetDate.getMonth() &&
      today.getDate() === targetDate.getDate()
    );
  }

  // =================================================================
  // --- Phone Number Validation ---
  // -----------------------------------------------------------------
  // 電話番号の正規化とバリデーション処理
  // =================================================================

  /**
   * 電話番号を正規化します（全角→半角、ハイフン削除、バリデーション）
   * サーバーサイドのnormalizePhoneNumber関数と同等の処理をフロントエンドで実行
   * @param {string} phoneInput - 入力された電話番号
   * @returns {PhoneNumberNormalizationResult} 正規化結果
   */
  window.normalizePhoneNumberFrontend = function (phoneInput) {
    if (!phoneInput || typeof phoneInput !== 'string') {
      return {
        normalized: '',
        isValid: false,
        error: '電話番号を入力してください',
      };
    }

    // 全角数字を半角に変換
    let normalized = phoneInput.replace(/[０-９]/g, s =>
      String.fromCharCode(s.charCodeAt(0) - 65248),
    );

    // 各種区切り文字と+記号を削除（ハイフン、スペース、括弧、ピリオド、+など）
    normalized = normalized.replace(/[-‐－—–\s\(\)\[\]\.\+]/g, '');

    // 国番号の自動修正処理（桁数チェック前に実行）
    // 行頭の81を0に置き換え（日本の国番号81 → 0）
    if (normalized.startsWith('81') && normalized.length >= 12) {
      normalized = '0' + normalized.substring(2);
    }

    // 数字以外の文字をチェック（空白文字は既に削除済み）
    if (!/^\d+$/.test(normalized)) {
      return {
        normalized: '',
        isValid: false,
        error: '電話番号は数字のみ入力してください',
      };
    }

    // 桁数チェック（携帯電話番号は11桁のみ）
    if (normalized.length !== 11) {
      return {
        normalized: '',
        isValid: false,
        error: '携帯電話番号は11桁で入力してください',
      };
    }

    // 先頭番号チェック（携帯電話番号は0から始まる）
    if (!normalized.startsWith('0')) {
      return {
        normalized: '',
        isValid: false,
        error: '携帯電話番号は0から始まる必要があります',
      };
    }

    return { normalized, isValid: true };
  };

  // =================================================================
  // --- General UI Utilities ---
  // -----------------------------------------------------------------
  // 汎用的なUI関連ユーティリティ関数群
  // =================================================================

  /**
   * 販売品マスタから物販チェックリスト（折り畳み可能）を生成する関数
   * @param {AccountingMasterData[]} accountingMaster - 販売品マスタ
   * @param {string[]} checkedValues - チェック済み項目名配列（任意）
   * @param {string} [title='販売品リスト'] - 見出しタイトル
   * @returns {string} HTML文字列
   */
  function buildSalesChecklist(
    accountingMaster,
    checkedValues = [],
    title = '販売品リスト',
  ) {
    const salesList = (accountingMaster || []).filter(
      item =>
        item[CONSTANTS.HEADERS.ACCOUNTING.TYPE] === CONSTANTS.ITEM_TYPES.SALES,
    );
    if (!salesList.length) return '';
    const checklistHtml = getSalesCheckboxListHtml(salesList, checkedValues);
    return `
      <details class="mt-4">
        <summary class="cursor-pointer font-bold text-base py-2 px-3 bg-ui-surface border-2 border-ui-border rounded hover:bg-ui-hover">${title} <span class="ml-2 text-sm text-brand-subtle">（クリックで展開）</span></summary>
        <div class="pt-2">${checklistHtml}</div>
      </details>
    `;
  }

  /**
   * 物販リストをチェックボックスで表示するHTMLを返す（再利用可能）
   * @param {AccountingMasterData[]} salesList - 物販アイテム配列
   * @param {string[]} checkedValues - チェック済み項目名配列（任意）
   * @returns {string} HTML文字列
   */
  function getSalesCheckboxListHtml(salesList, checkedValues = []) {
    if (!salesList || salesList.length === 0) return '';
    return `
      <div class="mt-4 pt-4 border-t">
        <label class="font-bold mb-2 block">購入希望（チェック可）</label>
        <div class="grid grid-cols-1 gap-2">
          ${salesList
            .map(
              item => `
            <label class="flex items-center space-x-2">
              <input type="checkbox" name="orderSales" value="${item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME]}" class="accent-action-primary-bg" ${checkedValues.includes(item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME]) ? 'checked' : ''}>
              <span>${item[CONSTANTS.HEADERS.ACCOUNTING.ITEM_NAME]}${item[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE] ? `（¥${item[CONSTANTS.HEADERS.ACCOUNTING.UNIT_PRICE]}）` : ''}</span>
            </label>
          `,
            )
            .join('')}
        </div>
      </div>`;
  }

  // =================================================================
  // --- Date & Time Utilities ---
  // -----------------------------------------------------------------
  // 日付・時刻関連のユーティリティ関数群
  // =================================================================

  /**
   * 日付文字列を「M/D 曜日」形式にフォーマット
   * @param {DateString} dStr - 日付文字列
   * @returns {string} フォーマット済み日付
   */
  window.formatDate =
    window.formatDate ||
    /** @type {(dStr: DateString) => string} */ (
      dStr => {
        if (!dStr) return '';
        const d = new Date(dStr);
        if (isNaN(d.getTime())) return '';
        d.setMinutes(d.getMinutes() + d.getTimezoneOffset());
        const day = d.getDay();
        const wd = ['日', '月', '火', '水', '木', '金', '土'];
        return `<span class="font-mono-numbers">${d.getMonth() + 1}/${d.getDate()}</span><span class="font-bold ${day === 0 ? 'text-ui-weekend-sunday' : day === 6 ? 'text-ui-weekend-saturday' : ''}">${wd[day] || ''}</span>`;
      }
    );

</script>

    <script>
      // 環境判定：本番環境かテスト環境かを確認
      const isProduction =
        window.location.href.includes('/exec?') ||
        (window.location.href.includes('/macros/s/') &&
          !window.location.href.includes('/dev'));

      // デバッグ制御（フロントエンド専用）
      const DEBUG_ENABLED = false; // 本番環境では false

      // デバッグ情報をコンソールに出力する関数（本番環境では無効化）
      function debugLog(message) {
        if (isProduction || !DEBUG_ENABLED) return; // 本番環境では何も表示しない
        console.log(
          '🔍 [DEBUG]',
          new Date().toLocaleTimeString() + ':',
          message,
        );
      }

      // 最初のテスト - これが表示されなければHTMLファイル自体が読み込まれていない
      debugLog('HTMLファイル読み込み確認テスト完了');
      debugLog('ページURL: ' + window.location.href);

      // GAS環境かどうかを判定
      const isGAS =
        typeof google !== 'undefined' && typeof google.script !== 'undefined';
      debugLog('GAS環境判定: ' + isGAS);

      // 事前取得システムを削除しました
      // シンプルなログインフローに変更したため不要

      // startPreloadInitialData関数を削除しました

      // updatePreloadStatus関数を削除しました

      function isPreloadedDataValid() {
        if (!window.appCache.initialData || !window.appCache.timestamp) {
          return false;
        }

        var age = Date.now() - window.appCache.timestamp;
        return age < window.appCache.maxAge;
      }

      function initializeApp() {
        debugLog('initializeApp実行開始');
        debugLog('isGAS: ' + isGAS);

        // 最適化された初期化チェック（アプローチ2改良版）
        function safeInitializeApp() {
          // 必要なコンポーネントの確認
          var allReady = true;
          var missingComponents = [];

          if (typeof DesignConfig === 'undefined') {
            allReady = false;
            missingComponents.push('DesignConfig');
          }
          if (typeof window.stateManager === 'undefined') {
            allReady = false;
            missingComponents.push('stateManager');
          }
          if (
            typeof window.stateManager !== 'undefined' &&
            typeof window.stateManager.dispatch !== 'function'
          ) {
            allReady = false;
            missingComponents.push('stateManager.dispatch');
          }
          if (typeof hideLoading !== 'function') {
            allReady = false;
            missingComponents.push('hideLoading');
          }

          debugLog(
            '初期化条件チェック - 不足: ' + missingComponents.join(', '),
          );

          if (allReady) {
            // 全て準備完了 - 即座に初期化実行
            debugLog('⚡ 高速初期化実行 - 全コンポーネント準備完了！');
            debugLog(
              'stateManager.getState().lessons: ' +
                (window.stateManager.getState().lessons
                  ? window.stateManager.getState().lessons.length + '件'
                  : 'null'),
            );
            debugLog(
              'CONSTANTS.CLASSROOMS: ' + JSON.stringify(CONSTANTS.CLASSROOMS),
            );

            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: { view: 'login' },
            });
            hideLoading();

            // 事前取得システムを削除しました
            // シンプルなログインフローに変更
          } else {
            // 一部未準備 - 100ms間隔でリトライ（300ms → 100ms に短縮）
            setTimeout(safeInitializeApp, 100);
          }
        }

        // 最適化された初期化開始
        safeInitializeApp();
      }

      if (isGAS) {
        // GAS本番環境のみ初期化
        window.addEventListener('DOMContentLoaded', () => {
          initializeApp();
        });
      }
    </script>
  </body>
</html>
