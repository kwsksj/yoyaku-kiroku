<script>
  /**
   * =================================================================
   * 【ファイル名】: 12_WebApp_StateManager.html
   * 【バージョン】: 2.0 (シンプル版)
   * 【役割】: シンプルで確実な状態管理システム
   * - 無限ループの完全回避
   * - 既存互換性は無視、新しい設計
   * - テスト環境特化
   * =================================================================
   */

  /**
   * シンプルな状態管理システム
   */
  class SimpleStateManager {
    constructor() {
      this.state = {
        // --- User & Session Data ---
        /** @type {{studentId: string, realName: string, displayName: string, phone: string} | null} */
        currentUser: null,
        /** @type {string} */
        loginPhone: '',
        /** @type {boolean} */
        isFirstTimeBooking: false,
        /** @type {Object} */
        registrationData: {},
        /** @type {string | null} */
        registrationPhone: null,

        // --- Core Application Data ---
        /** @type {Array<Object>} */
        slots: [],
        /** @type {Array<Object>} */
        myBookings: [],
        /** @type {Array<Object>} */
        history: [],
        /** @type {Array<Object>} */
        accountingMaster: [],
        /** @type {Array<string>} */
        classrooms: [],
        /** @type {Object | null} */
        constants: null,

        // --- UI State ---
        /** @type {string} */
        view: 'login',
        /** @type {string | null} */
        selectedClassroom: null,
        /** @type {Object | null} */
        selectedSlot: null,
        /** @type {Object | null} */
        editingReservationDetails: null,
        /** @type {Object | null} */
        accountingReservation: null,
        /** @type {Object} */
        accountingInitialValues: {},
        /** @type {string} */ completionMessage: '',
        /** @type {number} */ recordsToShow: 10,
        /** @type {Array<Object>} */
        searchedUsers: [],
        /** @type {boolean} */
        searchAttempted: false,

        // --- System State ---
        /** @type {boolean} */
        isDataFresh: false,
        /** @type {boolean} */
        _dataUpdateInProgress: false,

        // --- Computed Data ---
        computed: {
          /** @type {Array<Object>} */ sortedBookings: [],
          /** @type {Array<Object>} */ sortedHistory: [],
          /** @type {Array<Object>} */ displayHistory: [],
        },
      };

      this.isUpdating = false; // 無限ループ防止フラグ
      this.subscribers = []; // 状態変更の購読者リスト

      // フォールバック統一定数を即座に設定（エラー回避）
      this.initializeFallbackConstants();
    }

    /**
     * アクションをディスパッチして状態を更新し、UIを自動再描画
     * @param {Object} action - アクションオブジェクト { type: 'ACTION_NAME', payload: { ... } }
     */
    dispatch(action) {
      if (this.isUpdating) {
        console.warn('状態更新中のため処理をスキップ');
        return;
      }

      console.log('🎯 Action dispatched:', action.type, action.payload ? Object.keys(action.payload) : 'no payload');

      // アクションに基づいて状態更新
      let newState = {};
      switch (action.type) {
        case 'SET_STATE':
          newState = action.payload || {};
          break;
        case 'CHANGE_VIEW':
          newState = { view: action.payload.view };
          break;
        default:
          console.warn('未知のアクションタイプ:', action.type);
          return;
      }

      // 内部の状態更新メソッドを呼び出し
      this._updateState(newState);

      // UI を自動で再描画
      this._scheduleRender();
    }

    /**
     * 状態を更新（内部メソッド）
     * @param {Object} newState - 新しい状態
     */
    _updateState(newState) {
      if (this.isUpdating) {
        console.warn('状態更新中のため処理をスキップ');
        return;
      }

      this.isUpdating = true;

      try {
        // 変更前の状態を保存（subscriber用）
        const oldState = { ...this.state };

        // 状態を直接更新
        Object.assign(this.state, newState);

        // 統一定数が設定された場合、グローバル短縮参照を初期化
        // window.Cがフォールバックで空オブジェクト{}で初期化されるため、
        // !window.Cでは正しく判定できない。
        // オブジェクトが空かどうかもチェックする。
        if (newState.constants && (!window.C || Object.keys(window.C).length === 0)) {
          this.initializeGlobalConstants();
        }

        // 基本的な計算済みデータ更新
        this.updateComputed();

        // subscriberに変更を通知
        this._notifySubscribers(this.state, oldState);

        console.log('✅ 状態更新完了:', Object.keys(newState));
      } catch (error) {
        console.error('❌ 状態更新エラー:', error);
      } finally {
        this.isUpdating = false;
      }
    }

    /**
     * グローバル統一定数の短縮参照を初期化
     */
    initializeGlobalConstants() {
      if (!this.state.constants) return;

      const constants = this.state.constants;

      // グローバル短縮参照を設定
      window.C = constants;
      window.STATUS = constants.status || {};
      window.UI = constants.ui || {};
      window.BANK = constants.bankInfo || {};
      window.PAYMENT = constants.paymentDisplay || {};

      console.log('📋 統一定数グローバル参照を初期化:', Object.keys(constants));
    }

    /**
     * 計算済みデータの基本更新
     */
    updateComputed() {
      if (!this.state.myBookings || !this.state.history) return;

      // 基本的なソート処理
      this.state.computed.sortedBookings = [...this.state.myBookings].sort(
        (a, b) => new Date(b.date) - new Date(a.date),
      );

      this.state.computed.sortedHistory = [...this.state.history].sort((a, b) => new Date(b.date) - new Date(a.date));

      // 表示する履歴の数を recordsToShow に基づいて動的に計算
      this.state.computed.displayHistory = this.state.computed.sortedHistory.slice(0, this.state.recordsToShow);
    }

    /**
     * フォールバック用のグローバル定数を初期化する
     * サーバーから本物の定数が読み込まれるまでの間のエラーを回避する
     */
    initializeFallbackConstants() {
      if (window.C && Object.keys(window.C).length > 0) return; // 既に設定済みなら何もしない

      window.C = {};
      window.STATUS = {
        CANCEL: 'cancel',
        WAITING: 'waiting',
      };
      window.UI = {
        HISTORY_INITIAL_RECORDS: 10,
        HISTORY_LOAD_MORE_RECORDS: 10,
        LOADING_MESSAGE_INTERVAL: 3000,
      };
      window.BANK = {};
      window.PAYMENT = { CASH: '現金' };
      console.log('📋 フォールバック定数を初期化しました');
    }

    /**
     * requestAnimationFrameを使ったレンダリングスケジューリング
     */
    _scheduleRender() {
      if (this._renderScheduled) {
        return; // 既にスケジュール済み
      }

      this._renderScheduled = true;
      requestAnimationFrame(() => {
        this._renderScheduled = false;
        if (typeof window.render === 'function') {
          console.log('🎨 Auto-rendering UI...');
          window.render();
        } else {
          console.warn('render関数が見つかりません');
        }
      });
    }

    /**
     * 現在の状態を取得
     */
    getState() {
      return this.state;
    }

    /**
     * 状態変更を購読する
     * @param {Function} callback - 状態変更時に呼び出される関数 (newState, oldState) => void
     * @returns {Function} unsubscribe関数
     */
    subscribe(callback) {
      this.subscribers.push(callback);
      
      // unsubscribe関数を返す
      return () => {
        const index = this.subscribers.indexOf(callback);
        if (index > -1) {
          this.subscribers.splice(index, 1);
        }
      };
    }

    /**
     * subscriberに状態変更を通知する
     * @param {Object} newState - 新しい状態
     * @param {Object} oldState - 古い状態
     */
    _notifySubscribers(newState, oldState) {
      this.subscribers.forEach(callback => {
        try {
          callback(newState, oldState);
        } catch (error) {
          console.error('subscriber callback error:', error);
        }
      });
    }
  }

  // グローバルインスタンスを作成
  window.stateManager = new SimpleStateManager();

  // シンプルなappState（プロキシなし）
  window.appState = window.stateManager.state;

  // setState関数をdispatch呼び出しのラッパーに変更
  window.setState = function (newState) {
    console.log('🔄 setState:', Object.keys(newState));
    window.stateManager.dispatch({ type: 'SET_STATE', payload: newState });
  };
</script>
