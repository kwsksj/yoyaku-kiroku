<script>
  /**
   * =================================================================
   * 【ファイル名】: 14_WebApp_Handlers.html
   * 【バージョン】: 1.6
   * 【役割】: WebAppのフロントエンドにおける、ユーザーの操作に応じた
   * アクションと、アプリケーション全体の制御フローを集約します。
   * 【構成】: 14ファイル構成のうちの14番目
   * 【v1.6での変更点】:
   * - FE-14: 会計入力のキャッシュ機能を追加。
   *   - localStorageへの保存、読み込み、削除処理を実装。
   *   - 画面遷移、保存、キャンセル時にキャッシュを適切に操作するよう修正。
   * =================================================================
   */

  // =================================================================
  // --- Accounting Cache Helper Functions (FE-14) ---
  // -----------------------------------------------------------------
  // 会計フォームのデータを操作するためのヘルパー関数群
  // =================================================================

  /**
   * 会計フォームから現在の入力内容をオブジェクトとして取得します。
   * @returns {object} フォームデータ
   */
  function getAccountingFormData() {
    const form = document.getElementById('accounting-form');
    if (!form) return {};

    const data = {};
    const elements = form.elements;

    for (let i = 0; i < elements.length; i++) {
      const item = elements[i];
      if (item.name) {
        if (item.type === 'checkbox') {
          data[item.name] = item.checked;
        } else if (item.type === 'radio') {
          if (item.checked) {
            data[item.name] = item.value;
          }
        } else {
          data[item.name] = item.value;
        }
      }
    }
    return data;
  }

  /**
   * 会計画面の入力イベントを監視するリスナーを設定します。
   * @param {string} reservationId - 予約ID
   */
  function setupAccountingFormListeners(reservationId) {
    const form = document.getElementById('accounting-form');
    if (!form) return;

    form.addEventListener('input', () => {
      const accountingData = getAccountingFormData();
      saveAccountingCache(reservationId, accountingData);
    });
  }

  // =================================================================
  // --- Action Handlers ---
  // -----------------------------------------------------------------
  // ユーザーの操作（ボタンクリックなど）を起点として実行される
  // 全ての処理を定義するオブジェクトです。
  // 各キーが data-action 属性に対応します。
  // =================================================================
  const actionHandlers = {
    /** ログインまたは新規登録を開始します（キャッシュ活用版） */
    login: () => {
      const p = document.getElementById('phone').value;
      // 入力値をsetState経由で保存
      setState({ loginPhone: p });
      if (!p) return showInfo('電話番号を入力してください。');
      const n = p.replace(/[‐－-]/g, '').replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 65248));
      showLoading('login');

      // 環境分岐: テスト環境の場合はモックデータを使用
      if (isTestEnvironment) {
        // テスト環境ではモックデータを使用
        setTimeout(() => {
          hideLoading();
          setState({
            currentUser: getEnvironmentData('currentUser', { displayName: 'テストユーザー', phone: n }),
            slots: getEnvironmentData('slots', []),
            myBookings: getEnvironmentData('myBookings', []),
            accountingMaster: getEnvironmentData('accountingMaster', {}),
            history: getEnvironmentData('history', []),
            historyTotal: getEnvironmentData('history', []).length,
            recordsToShow: 10, // UI.HISTORY_INITIAL_RECORDSで後で更新
            view: 'dashboard', // テスト環境ではダッシュボードに直接遷移
          });
        }, 300);
        return;
      }

      // 本番環境: 統合エンドポイントで初期データと空席情報を一括取得
      google.script.run
        .withSuccessHandler(response => {
          hideLoading();

          // デバッグ情報を画面に表示
          debugLog('初期データ取得完了');
          debugLog('response.success: ' + response.success);
          debugLog('response.userFound: ' + response.userFound);
          debugLog(
            'response.availableSlots: ' +
              (response.availableSlots ? response.availableSlots.length + '件' : 'null/undefined'),
          );
          debugLog('response.data: ' + (response.data ? 'あり' : 'null/undefined'));

          if (response.success && response.userFound) {
            // ユーザーが見つかった場合：クライアントサイド処理で状態構築
            const newAppState = processInitialData(
              response.data,
              n,
              response.availableSlots,
              response.data.userReservations,
            );
            debugLog(
              'processInitialData完了 - slots: ' + (newAppState.slots ? newAppState.slots.length + '件' : 'null'),
            );
            debugLog('processInitialData完了 - classrooms: ' + JSON.stringify(newAppState.classrooms));
            // NF-04.2: 初回予約判定
            const isFirstTime =
              (!newAppState.myBookings || newAppState.myBookings.length === 0) &&
              (!newAppState.history || newAppState.history.length === 0);
            setState({
              ...newAppState,
              isFirstTimeBooking: isFirstTime,
              recordsToShow: 10, // UI.HISTORY_INITIAL_RECORDSで後で更新
              isDataFresh: true, // ログイン時にデータを読み込んだことを記録
            });
          } else {
            // ユーザーが見つからない場合または特別コマンド認識時
            setState({
              view: 'userSearch',
              searchedUsers: [],
              selectedSearchedUser: null,
              searchAttempted: false,
            });
          }
        })
        .withFailureHandler(err => {
          hideLoading();
          debugLog('初期データ取得エラー: ' + err.message);
          handleServerError(err);
        })
        .getLoginData(n);
    },

    /** 新しいログインフロー（メインのloginに統合済み） */

    /** 新規ユーザー登録：Step1からStep2へ */
    goToStep2: () => {
      const realName = document.getElementById('reg-realname').value;
      const nickname = document.getElementById('reg-nickname').value.trim();
      const phone = document.getElementById('reg-phone').value;
      // 入力値をsetState経由で保存
      const updatedRegistrationData = {
        ...appState.registrationData,
        phone,
        realName,
        nickname: nickname || realName,
      };
      if (!realName) return showInfo('お名前（本名）は必須です。');
      setState({
        registrationData: updatedRegistrationData,
        registrationStep: 2,
        view: 'registrationStep2',
      });
    },

    /** 新規ユーザー登録：Step2からStep1へ戻る */
    backToStep1: () => {
      const realName = document.getElementById('reg-realname')?.value;
      const nickname = document.getElementById('reg-nickname')?.value;
      const phone = document.getElementById('reg-phone')?.value;
      if (realName || nickname || phone) {
        const updatedRegistrationData = {
          ...appState.registrationData,
          realName: realName || appState.registrationData?.realName || '',
          nickname: nickname || appState.registrationData?.nickname || '',
          phone: phone || appState.registrationData?.phone || '',
        };
        setState({ registrationData: updatedRegistrationData });
      }
      setState({ view: 'register', registrationStep: 1 });
    },

    /** 新規ユーザー登録：Step2からStep3へ進む */
    goToStep3: () => {
      const email = document.getElementById('q-email').value;
      if (!email || !email.includes('@')) {
        return showInfo('有効なメールアドレスを入力してください。');
      }

      const step2Data = {
        email: email,
        wantsEmail: document.getElementById('q-wants-email').checked,
        ageGroup: document.getElementById('q-age-group').value,
        gender: document.querySelector('input[name="gender"]:checked')?.value || '',
        dominantHand: document.querySelector('input[name="dominantHand"]:checked')?.value || '',
        address: document.getElementById('q-address').value,
      };

      setState({
        registrationData: { ...appState.registrationData, ...step2Data },
        registrationStep: 3,
        view: 'registrationStep3',
      });
    },

    /** 新規ユーザー登録：Step3からStep2へ戻る */
    backToStep2: () => setState({ view: 'registrationStep2', registrationStep: 2 }),

    /** 新規ユーザー登録：最終データをサーバーに送信（バッチ処理版） */
    submitRegistration: () => {
      const step3Data = {
        experience: document.querySelector('input[name="experience"]:checked')?.value || '',
        pastWork: document.getElementById('q-past-work').value,
        futureGoal: document.getElementById('q-future-goal').value,
      };

      const finalUserData = { ...appState.registrationData, ...step3Data };

      showLoading('login');
      google.script.run
        .withSuccessHandler(res => {
          if (res.success) {
            // 登録後、バッチ処理で初期データと空席情報を一括取得
            google.script.run
              .withSuccessHandler(batchResult => {
                hideLoading();

                if (batchResult.success) {
                  const newAppState = processInitialData(
                    batchResult.data.initial,
                    res.user.phone,
                    batchResult.data.slots,
                  );
                  setState({
                    ...newAppState,
                    currentUser: res.user,
                    view: 'classroomSelection',
                  });
                } else {
                  showInfo(batchResult.message || 'データの取得に失敗しました', 'エラー');
                }
              })
              .withFailureHandler(handleServerError)
              .getBatchData(['initial', 'slots'], res.user.phone);
          } else {
            hideLoading();
            showInfo(res.message || '登録に失敗しました');
          }
        })
        .withFailureHandler(handleServerError)
        .registerNewUser(finalUserData);
    },

    /** きろくカードの編集ボタン（キャッシュ活用版） */
    editHistoryMemo: d => {
      const item = appState.history.find(h => h.reservationId === d.reservationId);
      if (!item) return;

      const originalMemo = item.workInProgress;

      showConfirm({
        title: '制作メモの編集',
        message: buildMemoEditModal(item),
        confirmText: '保存する',
        cancelText: 'キャンセル',
        confirmColorClass: DesignConfig.colors.primary,
        onConfirm: () => {
          const newMemo = document.getElementById('memo-edit-textarea').value;

          // 楽観的UI: まずフロントの表示を更新
          item.workInProgress = newMemo;
          setState({ history: [...appState.history] });

          showLoading();

          // サーバーに保存（統合予約シート更新 + キャッシュ再構築 + 最新データ取得）
          google.script.run
            .withSuccessHandler(r => {
              hideLoading();
              if (r.success) {
                showInfo('制作メモを更新しました。', '保存完了');
                // 他の操作と同様に最新データで状態を更新
                if (r.data) {
                  setState({
                    ...r.data.initialData,
                    myBookings: r.data.myBookings || [],
                    history: r.data.initialData.myHistory || [],
                    historyTotal: (r.data.initialData.myHistory || []).length,
                    isDataFresh: true, // 最新データ受信済み
                  });
                } else {
                  setState({ view: 'dashboard' });
                }
              } else {
                // サーバーエラーの場合は元に戻す
                item.workInProgress = originalMemo;
                setState({ history: [...appState.history] });
                showInfo(r.message || 'メモの保存に失敗しました。', 'エラー');
              }
            })
            .withFailureHandler(err => {
              hideLoading();
              // 通信エラーの場合は元に戻す
              item.workInProgress = originalMemo;
              setState({ history: [...appState.history] });
              handleServerError(err);
            })
            .updateReservationMemoAndGetLatestData(d.reservationId, appState.currentUser.studentId, newMemo);
        },
      });
    },

    /** プロフィール情報を保存します（キャッシュ活用版） */
    saveProfile: () => {
      const r = document.getElementById('edit-realname').value;
      let n = document.getElementById('edit-nickname').value.trim();
      if (!r) return showInfo('お名前（本名）は必須です。');
      if (!n) n = r;

      // NF-01: 電話番号入力欄があればその値も取得
      const phoneInput = document.getElementById('edit-phone');
      const phone = phoneInput ? phoneInput.value : appState.currentUser.phone; // 電話番号入力欄がなければ既存の電話番号を使用

      const u = { ...appState.currentUser, realName: r, displayName: n, phone: phone }; // 電話番号も追加
      showLoading();
      google.script.run
        .withSuccessHandler(res => {
          hideLoading();
          if (res.success) {
            // プロフィール更新後、キャッシュも更新されているのでそのまま状態更新
            showInfo('プロフィールを更新しました', '更新完了');
            setState({ currentUser: res.updatedUser, view: 'dashboard' });
          } else {
            showInfo(res.message || '更新に失敗しました');
          }
        })
        .withFailureHandler(handleServerError)
        .updateUserProfile(u);
    },

    /**
     * NF-01: 電話番号未登録ユーザーの検索を実行します（キャッシュ活用版）。
     */
    searchUserByName: () => {
      const searchInput = document.getElementById('nickname-search-input');
      const searchTerm = searchInput ? searchInput.value.trim() : ''; // 検索語をsearchTermに変更

      if (!searchTerm) {
        return showInfo('お名前（本名）またはニックネームを入力してください。');
      }

      showLoading('login');

      // 検索語からスペースを除去して小文字化して比較に使う
      const normalizedSearchTerm = searchTerm.replace(/\s+/g, '').toLowerCase();

      google.script.run
        .withSuccessHandler(response => {
          hideLoading();
          if (response.success) {
            // 【統一レスポンス形式】データ構造の修正
            // searchName (スペース除去済み・小文字化された結合名) を使ってフィルタリング
            const filteredUsers = response.data.filter(
              user => user.searchName && user.searchName.includes(normalizedSearchTerm),
            );

            // NF-01: 検索が試行されたことを示すフラグをセット
            setState({ searchedUsers: filteredUsers, searchAttempted: true });

            if (filteredUsers.length === 0) {
              // アカウントが見つからなかった場合のメッセージはビュー側で表示
            }
          } else {
            showInfo(response.message || 'ユーザー検索に失敗しました。');
          }
        })
        .withFailureHandler(handleServerError)
        .searchUsersWithoutPhone(searchTerm);
    },

    /**
     * NF-01: 検索結果から電話番号未登録ユーザーを選択します（バッチ処理版）。
     */
    selectSearchedUser: d => {
      // ボタンに埋め込まれたデータから、まず仮のユーザー情報を作成
      const tempUser = {
        studentId: d.studentId,
        realName: d.realName, // ボタンのdata属性から取得
        displayName: d.nickname, // ボタンのdata属性から取得
        phone: '', // 電話番号はまだないので空
      };

      showLoading('login');

      // バッチ処理で初期データ、空席情報、ユーザーデータを一括取得
      google.script.run
        .withSuccessHandler(response => {
          hideLoading();
          if (response.success) {
            // tempUserの情報でcurrentUserを上書きしつつ、キャッシュデータを活用
            const userFromCache = response.data.initial.allStudents[tempUser.studentId];
            const finalUser = userFromCache
              ? {
                  ...userFromCache,
                  displayName: tempUser.displayName,
                  phone: tempUser.phone,
                }
              : tempUser;

            // 個人予約データはバックエンドから取得済み
            const { myBookings, myHistory } = response.data.userReservations || { myBookings: [], myHistory: [] };
            const today = response.data.initial.today;

            setState({
              currentUser: finalUser,
              slots: response.data.slots,
              myBookings: myBookings,
              accountingMaster: response.data.initial.accountingMaster,
              history: myHistory,
              historyTotal: myHistory.length,
              recordsToShow: 10, // UI.HISTORY_INITIAL_RECORDSで後で更新
              view: 'editProfile', // 電話番号登録を促すためプロフィール編集画面へ
              today: today,
              _allStudents: response.data.initial.allStudents,
              _cacheVersions: response.data.initial.cacheVersions,
            });
          } else {
            showInfo(response.message || 'データの読み込みに失敗しました。');
          }
        })
        .withFailureHandler(handleServerError)
        .getBatchData(['initial', 'slots', 'reservations'], null, tempUser.studentId);
    },

    /**
     * NF-01: 自分のアカウントが見つからなかった場合に新規登録画面へ遷移します。
     */
    goToRegisterFromUserSearch: () => {
      // 新規登録画面へ遷移。電話番号は未入力のまま。
      setState({ view: 'register', registrationPhone: '' });
    },

    /** 予約をキャンセルします */
    cancel: d => {
      const message = `
        <div class="text-left space-y-4">
          <p class="text-center"><b>${formatDate(d.date)}</b><br>${d.classroom}<br>この予約を取り消しますか？</p>
          <div class="pt-4 border-t">
            <label class="block text-sm font-bold mb-2">先生へのメッセージ（任意）</label>
            <textarea id="cancel-message" class="w-full p-2 border border-ui-border rounded" rows="3" placeholder=""></textarea>
          </div>
        </div>
      `;
      showConfirm({
        title: '予約の取り消し',
        message: message,
        confirmText: 'はい　取り消します',
        cancelText: 'いいえ',
        confirmColorClass: DesignConfig.colors.danger,
        onConfirm: () => {
          showLoading('cancel');
          const cancelMessage = document.getElementById('cancel-message')?.value || '';
          const p = {
            ...d,
            studentId: appState.currentUser.studentId,
            cancelMessage: cancelMessage,
          };
          google.script.run
            .withSuccessHandler(r => {
              hideLoading();
              if (r.success) {
                if (r.data) {
                  setState({
                    ...r.data.initialData,
                    myBookings: r.data.myBookings || [],
                    history: r.data.initialData.myHistory || [],
                    historyTotal: (r.data.initialData.myHistory || []).length,
                    view: 'dashboard',
                    isDataFresh: true, // 最新データ受信済み
                  });
                } else {
                  setState({
                    view: 'dashboard',
                    isDataFresh: false, // 再読み込み必要
                  });
                }
                showInfo(r.message || '予約を取り消しました。', 'キャンセル完了');
              } else {
                showInfo(r.message || 'キャンセル処理に失敗しました。');
              }
            })
            .withFailureHandler(err => {
              // エラー時は画面を更新せず、元の状態を維持
              handleServerError(err);
            })
            .cancelReservationAndGetLatestData(p);
        },
      });
    },

    /** 予約を確定します */
    confirmBooking: () => {
      const bookingOptions = {
        chiselRental: document.getElementById('option-rental')?.checked || false,
        firstLecture: document.getElementById('option-first-lecture')?.checked || false,
        startTime: document.getElementById('res-start-time')?.value || '',
        endTime: document.getElementById('res-end-time')?.value || '',
        workInProgress: document.getElementById('wip-input')?.value || '',
        order: document.getElementById('order-input')?.value || '',
        messageToTeacher: document.getElementById('message-input')?.value || '',
        materialInfo: document.getElementById('material-input')?.value || '',
      };

      showLoading('booking');
      const p = {
        ...appState.selectedSlot,
        user: appState.currentUser,
        studentId: appState.currentUser.studentId,
        options: bookingOptions,
      };

      google.script.run
        .withSuccessHandler(r => {
          hideLoading();
          if (r.success) {
            if (r.data) {
              setState({
                ...r.data.initialData,
                myBookings: r.data.myBookings || [],
                history: r.data.initialData.myHistory || [],
                historyTotal: (r.data.initialData.myHistory || []).length,
                view: 'complete',
                completionMessage: r.message,
                isDataFresh: true, // 最新データ受信済み
              });
            } else {
              setState({
                view: 'complete',
                completionMessage: r.message,
                isDataFresh: false, // 再読み込み必要
              });
            }
          } else {
            showInfo(r.message || '予約に失敗しました。');
          }
        })
        .withFailureHandler(handleServerError)
        .makeReservationAndGetLatestData(p);
    },

    /** 予約編集画面に遷移します（予約データはキャッシュから取得済み） */
    goToEditReservation: d => {
      // 予約データは既にキャッシュから取得済みなので、直接編集画面に遷移
      const reservation = appState.myBookings.find(
        booking => booking.reservationId === d.reservationId && booking.classroom === d.classroom,
      );

      if (reservation) {
        const editingDetails = {
          reservationId: reservation.reservationId,
          classroom: reservation.classroom,
          date: reservation.date,
          venue: reservation.venue,
          chiselRental: reservation.chiselRental || false,
          firstLecture: reservation.firstLecture || false,
          startTime: reservation.startTime || '',
          endTime: reservation.endTime || '',
          workInProgress: reservation.workInProgress || '',
          order: reservation.order || '',
          messageToTeacher: reservation.message || '',
          materialInfo: reservation.materialInfo || '',
        };
        setState({ view: 'editReservation', editingReservationDetails: editingDetails });
      } else {
        showInfo('予約情報が見つかりませんでした。');
      }
    },

    /** 予約情報を更新します */
    updateReservation: () => {
      const d = appState.editingReservationDetails;
      const p = {
        reservationId: d.reservationId,
        classroom: d.classroom,
        studentId: appState.currentUser.studentId,
        chiselRental: document.getElementById('option-rental')?.checked || false,
        firstLecture: document.getElementById('option-first-lecture')?.checked || false,
        startTime: document.getElementById('res-start-time')?.value || '',
        endTime: document.getElementById('res-end-time')?.value || '',
        workInProgress: document.getElementById('wip-input').value,
        order: document.getElementById('order-input').value,
        messageToTeacher: document.getElementById('message-input').value,
        materialInfo: document.getElementById('material-input')?.value || '',
      };
      showLoading('booking');
      google.script.run
        .withSuccessHandler(r => {
          hideLoading();
          if (r.success) {
            if (r.data) {
              setState({
                ...r.data.initialData,
                myBookings: r.data.myBookings || [],
                history: r.data.initialData.myHistory || [],
                historyTotal: (r.data.initialData.myHistory || []).length,
                view: 'dashboard',
                isDataFresh: true, // 最新データ受信済み
              });
            } else {
              setState({
                view: 'dashboard',
                isDataFresh: false, // 再読み込み必要
              });
            }
            showInfo(r.message || '予約内容を更新しました。', '更新完了');
          } else {
            showInfo(r.message || '更新に失敗しました。');
          }
        })
        .withFailureHandler(handleServerError)
        .updateReservationDetailsAndGetLatestData(p);
    },

    /** 会計画面に遷移します（予約データはキャッシュから取得済み） */
    goToAccounting: d => {
      // 予約データは既にキャッシュから取得済みなので、キャッシュされたフォームデータのみ読み込み
      const reservationId = d.reservationId;
      const cachedData = loadAccountingCache(reservationId);

      // 基本的な予約情報はキャッシュから取得
      const reservation = appState.myBookings.find(booking => booking.reservationId === reservationId);

      if (reservation) {
        const baseDetails = {
          firstLecture: reservation.firstLecture || false,
          chiselRental: reservation.chiselRental || false,
          startTime: reservation.startTime || null,
          endTime: reservation.endTime || null,
        };

        // キャッシュデータと基本データをマージ (キャッシュを優先)
        const initialValues = { ...baseDetails, ...cachedData };

        setState({
          view: 'accounting',
          accountingReservation: d,
          accountingInitialValues: initialValues,
        });
      } else {
        showInfo('予約情報が見つかりませんでした。');
      }
    },

    /** 履歴から会計詳細をモーダルで表示します（データはキャッシュから取得済み） */
    showHistoryAccounting: d => {
      const details = JSON.parse(d.details);
      const tuitionItemsHtml = details.tuition.items
        .map(i => `<li>${i.name}: ${i.price.toLocaleString()}円</li>`)
        .join('');
      const salesItemsHtml = details.sales.items.map(i => `<li>${i.name}: ${i.price.toLocaleString()}円</li>`).join('');
      const message = `
            <div class="p-4 bg-brand-light rounded-lg text-left space-y-4 text-base">
                ${tuitionItemsHtml ? `<b>授業料</b><ul class="list-disc list-inside">${tuitionItemsHtml}</ul>` : ''}
                ${salesItemsHtml ? `<b class="mt-1 inline-block">販売</b><ul class="list-disc list-inside">${salesItemsHtml}</ul>` : ''}
                <div class="font-bold mt-1 pt-1 border-t">合計: ${details.grandTotal.toLocaleString()}円</div><div class="text-right text-sm pt-1">支払方法: ${details.paymentMethod}</div></div>`;
      showInfo(message, '会計記録');
    },

    /** 会計画面で材料入力行を追加します */
    addMaterialRow: () => {
      const container = document.getElementById('materials-container');
      const newIndex = container.querySelectorAll('div[data-material-row-index]').length;
      const newRow = document.createElement('div');
      newRow.className = 'mt-4 pt-4 border-t border-ui-border-light';
      newRow.dataset.materialRowIndex = newIndex;
      newRow.innerHTML = buildMaterialRow(newIndex);
      container.appendChild(newRow);
    },

    /** 会計画面でその他販売品入力行を追加します */
    addOtherSalesRow: () => {
      const container = document.getElementById('other-sales-container');
      const newIndex = container.querySelectorAll('div[data-other-sales-row]').length;
      // getOtherSalesRowHtmlが返すHTML文字列を、ラッパーを介さず直接コンテナの末尾に追加する
      container.insertAdjacentHTML('beforeend', getOtherSalesRowHtml(newIndex));
    },

    /** 会計画面で合計金額をクリップボードにコピーします */
    copyGrandTotal: button => {
      const totalText = document.getElementById('grand-total-amount')?.textContent || '';
      const numericTotal = totalText.replace(/[^0-9-]/g, '');
      actionHandlers.copyToClipboard(button, numericTotal);
    },

    /** 指定されたテキストをクリップボードにコピーします */
    copyToClipboard: (button, text) => {
      const textToCopy = text || button.dataset.copyText;
      const textArea = document.createElement('textarea');
      textArea.style.position = 'fixed';
      textArea.style.top = '-9999px';
      textArea.style.left = '-9999px';
      textArea.value = textToCopy.replace(/,/g, '');
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      try {
        const successful = document.execCommand('copy');
        if (successful) {
          const originalText = button.textContent;
          button.textContent = 'コピーしました!';
          setTimeout(() => {
            button.textContent = originalText;
          }, 2000);
        } else {
          showInfo('コピーに失敗しました。');
        }
      } catch (err) {
        showInfo('コピーに失敗しました。');
        // エラーログは開発環境でのみ出力
        if (typeof console !== 'undefined' && console.error) {
          console.error('Clipboard copy failed:', err);
        }
      }
      document.body.removeChild(textArea);
    },

    /** 参加記録を追加で読み込みます（統合ダッシュボード用） */
    loadMoreHistory: () => {
      const newCount =
        (appState.recordsToShow || UI?.HISTORY_INITIAL_RECORDS || 10) + (UI?.HISTORY_LOAD_MORE_RECORDS || 10);
      setState({ recordsToShow: newCount });
    },

    /** 新規予約のための教室選択画面に遷移します */
    goToClassroomSelection: () => {
      if (appState.classrooms && appState.classrooms.length > 0) {
        setState({ view: 'classroomSelection' });
      } else {
        showInfo('教室情報の取得に失敗しました。ダッシュボードに戻ります。');
        setState({ view: 'dashboard' });
      }
    },

    /** プロフィール編集画面に遷移します */
    goToEditProfile: () => setState({ view: 'editProfile' }),

    /** 
     * スロット情報をキャッシュから取得して状態を更新する統合関数
     * 教室選択画面で利用する空き枠情報を最新化し、コールバック関数を実行
     * @param {Function} [onComplete] - スロット更新完了時のコールバック関数
     */
    refreshAndUpdateSlots: function (onComplete) {
      google.script.run
        .withSuccessHandler(response => {
          debugLog('スロット取得完了 - success: ' + response.success);

          if (response.success && response.data && response.data.slots) {
            const classroomsFromSlots = [...new Set(response.data.slots.map(slot => slot.classroom))];
            debugLog('取得したスロット: ' + response.data.slots.length + '件');

            setState({
              slots: response.data.slots,
              classrooms: classroomsFromSlots,
            });
          } else {
            debugLog('スロット取得に失敗');
          }

          if (onComplete) onComplete(response);
        })
        .withFailureHandler(error => {
          debugLog('スロット取得エラー: ' + error.message);
          if (onComplete) onComplete({ success: false, message: error.message });
        })
        .getBatchData(['slots'], appState.currentUser.phone);
    },

    /** 教室を選択し、予約枠一覧画面に遷移します */
    selectClassroom: d => {
      if (!d || !d.classroomName) {
        // slotsはrefreshAndUpdateSlots内で更新済み。ここでは画面遷移と教室選択の状態をセット。
        setState({ selectedClassroom: d.classroomName, view: 'booking' });
      } else {
        showInfo('予約枠の取得に失敗しました。時間をおいて再度お試しください。');
      }
    },

    /** 予約枠を選択し、予約確認画面に遷移します */
    bookSlot: d => {
      const foundSlot = appState.slots.find(s => s.classroom === d.classroom && s.date === d.date);
      if (foundSlot) {
        // 空席数に基づいてisFull状態を確実に設定
        const isFullSlot =
          foundSlot.isFull ||
          foundSlot.availableSlots === 0 ||
          (typeof foundSlot.morningSlots !== 'undefined' &&
            foundSlot.morningSlots === 0 &&
            foundSlot.afternoonSlots === 0);
        setState({
          selectedSlot: {
            ...foundSlot,
            isFull: isFullSlot,
          },
          view: 'newReservation',
        });
      } else {
        showInfo('エラーが発生しました。選択した予約枠が見つかりません。');
      }
    },

    /** ログイン画面に戻ります（電話番号入力値を保存） */
    goBackToLogin: () => {
      const phoneInput = document.getElementById('phone');
      const loginPhone = phoneInput ? phoneInput.value : appState.loginPhone;
      setState({ view: 'login', loginPhone: loginPhone });
    },

    /** ダッシュボード（メイン画面）に戻ります */
    goBackToDashboard: () => setState({ view: 'dashboard' }),

    /** ダッシュボード（メイン画面）に戻ります（別名） */
    goToDashboard: () => setState({ view: 'dashboard' }),

    /** 予約枠一覧画面に戻ります */
    goBackToBooking: () => {
      if (appState.view === 'accounting') {
        showConfirm({
          title: '確認',
          message: '会計入力を破棄しますか？<br>（入力内容はクリアされます）',
          confirmText: 'はい',
          cancelText: 'いいえ',
          confirmColorClass: DesignConfig.colors.danger,
          onConfirm: () => {
            clearAccountingCache(appState.accountingReservation.reservationId);
            setState({
              view: 'booking',
              selectedClassroom:
                appState.selectedSlot?.classroom ||
                appState.accountingReservation?.classroom ||
                appState.editingReservationDetails?.classroom,
            });
          },
        });
      } else {
        setState({
          view: 'booking',
          selectedClassroom:
            appState.selectedSlot?.classroom ||
            appState.accountingReservation?.classroom ||
            appState.editingReservationDetails?.classroom,
        });
      }
    },

    /** ダッシュボードに戻ります */
    goToDashboard: () => setState({ view: 'dashboard' }),

    /** モーダルの確認ボタンを押したときの処理です */
    modalConfirm: () => {
      ModalManager.executeCallback();
      hideModal();
    },

    /** モーダルのキャンセルボタンを押したときの処理です */
    modalCancel: () => hideModal(),
  };

  /**
   * 会計の確認モーダルを表示
   */
  actionHandlers.showAccountingConfirmation = () => {
    const accountingDetails = calculateAccountingDetails();
    if (!accountingDetails || accountingDetails.grandTotal <= 0) {
      showInfo('合計金額が0円です。項目を選択してください。');
      return;
    }

    const message = `
        <div class="p-4 bg-brand-light rounded-lg text-left space-y-4 text-base" id="modal-accounting-form">
            <div>
                <span class="font-bold">合計金額:</span> ${accountingDetails.grandTotal.toLocaleString()}円
                <button data-action="copyGrandTotal" class="ml-2 text-sm bg-action-secondary-bg active:bg-action-secondary-hover text-action-secondary-text font-bold px-2 py-1 rounded">コピー</button>
            </div>
            <div>
                <span class="font-bold">支払い方法:</span>
                <div class="mt-2 space-y-3">
                    ${getPaymentOptionsHtml()}
                </div>
            </div>
            <div class="mt-4">
                <button id="confirm-payment-button" data-action="confirmAndPay" class="w-full bg-action-primary-bg text-action-primary-text font-bold py-2 rounded disabled:bg-brand-muted" disabled>この内容で支払いました</button>
            </div>
            <p class="text-red-700 font-bold mt-2 text-center">必ずボタンを押してね</p>
        </div>
    `;
    showModal({
      title: 'お会計',
      message: message,
      showCancel: true,
      cancelText: 'キャンセル',
      onConfirm: null,
    });
  };

  /**
   * 「この内容で支払いました」ボタン押下時の処理
   */
  actionHandlers.confirmAndPay = () => {
    const reservationId = appState.accountingReservation.reservationId;
    // モーダル内の支払い方法を取得
    const modalForm = document.getElementById('modal-accounting-form');
    let paymentMethod = PAYMENT.CASH;
    if (modalForm) {
      const selected = modalForm.querySelector('input[name="payment-method"]:checked');
      if (selected) paymentMethod = selected.value;
    }

    // --- バックエンドに送信する「ユーザー入力」オブジェクトを構築 ---
    const form = document.getElementById('accounting-form');
    const userInput = {
      paymentMethod: paymentMethod,
      tuitionItems: [],
      salesItems: [],
      timeBased: null,
    };

    // 授業料項目（チェックボックス）
    form.querySelectorAll(`input[type="checkbox"][data-item-type="${C.itemTypes.TUITION}"]:checked`).forEach(cb => {
      userInput.tuitionItems.push(cb.dataset.itemName);
    });

    // 時間制授業料
    if (document.getElementById('start-time')) {
      userInput.timeBased = {
        startTime: document.getElementById('start-time').value,
        endTime: document.getElementById('end-time').value,
        breakMinutes: parseInt(document.getElementById('break-time')?.value || 0, 10),
        discountMinutes: parseInt(document.getElementById('discount-selector')?.value || 0, 10),
      };
    }

    // 物販・材料費項目
    const materialContainer = document.getElementById('materials-container');
    if (materialContainer) {
      materialContainer.querySelectorAll('div[data-material-row-index]').forEach((row, index) => {
        const name = document.getElementById(`material-type-${index}`)?.value;
        const priceText = document.getElementById(`material-price-${index}`)?.textContent || '0';
        const price = parseInt(priceText.replace(/[^0-9]/g, ''), 10);
        if (name && price > 0) userInput.salesItems.push({ name: name, price: price });
      });
    }

    // 物販項目（チェックボックス）
    form.querySelectorAll(`input[type="checkbox"][data-item-type="${C.itemTypes.SALES}"]:checked`).forEach(cb => {
      userInput.salesItems.push({ name: cb.dataset.itemName });
    });

    form.querySelectorAll('div[data-other-sales-row]').forEach((row, index) => {
      const name = document.getElementById(`other-sales-name-${index}`)?.value.trim();
      const price = document.getElementById(`other-sales-price-${index}`)?.value;
      if (name && price) userInput.salesItems.push({ name: name, price: Number(price) });
    });
    // --- ここまで ---

    const payload = {
      reservationId: appState.accountingReservation.reservationId,
      classroom: appState.accountingReservation.classroom,
      studentId: appState.currentUser.studentId,
      userInput: userInput,
    };

    showLoading('accounting');
    google.script.run
      .withSuccessHandler(r => {
        if (r.success) {
          clearAccountingCache(reservationId); // <-- キャッシュ削除
          hideModal(); // モーダルを閉じる
          hideLoading();
          setState({
            view: 'complete',
            completionMessage: '会計情報を記録しました。',
            accountingReservation: appState.accountingReservation,
            isDataFresh: false, // 最新スロット情報を取得するため
          });
        } else {
          hideLoading();
          showInfo(r.message || '会計情報の記録に失敗しました。');
        }
      })
      .withFailureHandler(handleServerError)
      .saveAccountingDetails(payload);
  };

  // =================================================================
  // --- Main Application Logic ---
  // -----------------------------------------------------------------
  // アプリケーションの起動、サーバーとの通信、状態管理、画面描画など、
  // 全体を制御するコアとなる関数群です。
  // =================================================================

  /**
   * アプリケーションの状態を更新し、画面を再描画します。
   * @param {object} newState - 更新する新しい状態オブジェクト
   */
  function setState(newState) {
    Object.assign(appState, newState);

    // 統一定数の短縮参照を初期化（constants が設定された場合）
    if (newState.constants) {
      initializeConstantShortcuts();
    }

    // データの整合性チェック
    if (appState.myBookings && !Array.isArray(appState.myBookings)) {
      appState.myBookings = [];
    }
    if (!appState.myBookings) {
      appState.myBookings = [];
    }
    if (!appState.history) {
      appState.history = [];
    }
    if (!appState.slots) {
      appState.slots = [];
    }

    // データが変更された場合、計算済みデータを更新
    // 統一定数が初期化されている場合のみ実行
    const dataChanged = hasDataChanged(newState);
    if (dataChanged && C) {
      updateComputedData();
    }

    render();
  }

  /**
   * データが変更されたかどうかを判定します。
   * @param {object} newState - 新しい状態
   * @returns {boolean} データが変更された場合true
   */
  function hasDataChanged(newState) {
    const dataKeys = ['myBookings', 'history', 'slots', 'accountingMaster', 'classrooms', 'recordsToShow'];
    return dataKeys.some(key => newState.hasOwnProperty(key));
  }
  window.setState = setState;
  this.setState = setState;
  self.setState = setState;

  /**
   * 指定されたビューで最新データが必要かどうかを判定
   * データ要求ビュー、ユーザーログイン状態、更新中フラグを考慮して判定
   * @param {string} view - 判定対象のビュー名
   * @returns {boolean} 最新データ取得が必要な場合true
   */
  function shouldUpdateAppStateForView(view) {
    // 教室選択画面は専用の更新処理(refreshAndUpdateSlots)に任せるため、ここからは除外
    const dataRequiredViews = ['dashboard', 'editProfile', 'booking', 'complete'];
    return (
      dataRequiredViews.includes(view) &&
      appState.currentUser &&
      !appState._dataUpdateInProgress && // 更新中フラグでループ防止
      !appState.isDataFresh
    ); // 既に新鮮なデータが読み込まれている場合はスキップ
  }

  /**
   * バッチ処理でキャッシュから最新データを取得してappStateを更新
   * ユーザーの予約・履歴・スロット情報を一括取得し、UIを再描画
   */
  function updateAppStateFromCache() {
    if (!appState.currentUser || !appState.currentUser.phone) {
      render(); // ユーザー情報がない場合はそのまま描画
      return;
    }

    // 更新中フラグを設定
    setState({ _dataUpdateInProgress: true });

    showLoading('最新データを取得中...');
    google.script.run
      .withSuccessHandler(response => {
        hideLoading();
        setState({ _dataUpdateInProgress: false }); // フラグをクリア

        if (response.success && response.userFound) {
          // バッチ処理結果からappStateを更新
          const newAppState = processInitialData(
            response.data.initial,
            appState.currentUser.phone,
            response.data.slots,
          );
          // 現在のビューと重要な状態は保持
          const preservedState = {
            view: appState.view,
            selectedClassroom: appState.selectedClassroom,
            selectedSlot: appState.selectedSlot,
            editingReservationDetails: appState.editingReservationDetails,
            accountingReservation: appState.accountingReservation,
            isDataFresh: true, // 新鮮なデータが読み込まれたことを記録
          };
          setState({ ...newAppState, ...preservedState }); // setStateに統合し、状態更新と再描画を一元化
        } else {
          // 失敗時もsetStateを介して状態を更新し、再描画をトリガーする
          setState({ _dataUpdateInProgress: false });
          showInfo(response.message || 'データの取得に失敗しました。');
        }
      })
      .withFailureHandler(err => {
        hideLoading();
        setState({ _dataUpdateInProgress: false }); // フラグをクリア
        handleServerError(err);
        // setStateがrenderを呼び出すので、ここでのrender()は不要
      })
      .getBatchData(['initial', 'slots'], appState.currentUser.phone);
  }

  /**
   * 指定されたビューでどのようなデータ更新が必要かを判定します。
   * @param {string} view - 現在のビュー名
   * @returns {'full' | 'slotsOnly' | 'none'} 必要な更新タイプ
   */
  function getUpdateTypeForView(view) {
    // 更新中、またはデータが新鮮な場合は更新不要
    if (!appState.currentUser || appState._dataUpdateInProgress || appState.isDataFresh) {
      return 'none';
    }

    // フルデータ更新が必要なビュー
    const fullDataRequiredViews = ['dashboard', 'editProfile', 'complete'];
    if (fullDataRequiredViews.includes(view)) {
      return 'full';
    }

    // スロットデータのみ更新が必要なビュー
    const slotsOnlyRequiredViews = ['classroomSelection', 'booking'];
    if (slotsOnlyRequiredViews.includes(view)) {
      return 'slotsOnly';
    }

    return 'none'; // その他のビューでは更新不要
  }

  /**
   * 現在のアプリケーションの状態に基づいて、適切なビューを描画する
   * データ更新の必要性を判定し、必要に応じて最新データ取得後に再描画
   * appState.viewの値に応じて対応するビュー関数を呼び出してUIを更新
   */
  function render() {

    const updateType = getUpdateTypeForView(appState.view);

    if (updateType === 'full') {
      // フルデータ更新が必要な画面
      updateAppStateFromCache();
      return; // updateAppStateFromCache内で再度render()が呼ばれるため、ここで終了
    } else if (updateType === 'slotsOnly') {
      // スロットデータ更新が必要な画面
      showLoading('最新データを取得中...'); // ローディング表示
      actionHandlers.refreshAndUpdateSlots(response => {
        hideLoading(); // ローディング非表示
        if (!response.success) {
          showInfo('データの取得に失敗しました。');
        }
        render(); // スロット更新後に再度renderを呼び出す
      });
      return; // refreshAndUpdateSlots内で再度render()が呼ばれるため、ここで終了
    }

    let v = '';
    switch (appState.view) {
      case 'login':
        v = getLoginView();
        break;
      case 'register':
        v = getRegisterView(appState.registrationPhone);
        break;
      case 'registrationStep2':
        v = getRegistrationStep2View();
        break;
      case 'registrationStep3':
        v = getRegistrationStep3View();
        break;
      case 'dashboard':
        v = getDashboardView();
        break;
      case 'classroomSelection':
        v = getClassroomSelectionView();
        break;
      case 'editProfile':
        v = getEditProfileView();
        break;
      case 'booking':
        v = getBookingView(appState.selectedClassroom);
        break;
      case 'newReservation':
        v = getReservationFormView('new');
        break;
      case 'editReservation':
        v = getReservationFormView('edit');
        break;
      case 'accounting':
        v = getAccountingView();
        break;
      case 'complete':
        v = getCompleteView(appState.completionMessage);
        break;
      case 'userSearch':
        v = getUserSearchView();
        break;
    }
    document.getElementById('view-container').innerHTML = `<div class="fade-in">${v}</div>`;

    if (appState.view === 'accounting') {
      requestAnimationFrame(() => {
        calculateAccountingDetails();
        setupAccountingFormListeners(appState.accountingReservation.reservationId);
      });
    }

    window.scrollTo(0, 0);
  }

  /**
   * アプリケーションの起動点です。
   * ページ読み込み完了時に実行され、イベントリスナーを設定します。
   */
  window.onload = function () {
    const app = document.getElementById('app');

    // 会計計画面での入力変更を検知し、リアルタイムで再計算
    ['input', 'change'].forEach(eventName => {
      app.addEventListener(eventName, e => {
        if (appState.view === 'accounting' && e.target.closest('#accounting-form')) {
          calculateAccountingDetails();
        }
        // changeイベントの場合のみ、支払い方法選択をチェック
        if (eventName === 'change' && e.target.matches('#modal-accounting-form input[name="payment-method"]')) {
          document.getElementById('confirm-payment-button')?.removeAttribute('disabled');
        }
      });
    });

    // アプリ全体のクリックイベントを捕捉
    app.addEventListener('click', e => {
      const targetButton = e.target.closest('button');
      if (targetButton?.dataset.action) {
        const { action, ...data } = targetButton.dataset;
        if (action === 'copyToClipboard' || action === 'copyGrandTotal') {
          actionHandlers[action](targetButton);
        } else if (actionHandlers[action]) {
          actionHandlers[action](data);
        }
      }
    });

    // NF-04: 木彫り経験ラジオボタンの変更を監視
    app.addEventListener('change', e => {
      if (e.target.closest('#experience-radio-group')) {
        const container = document.getElementById('past-work-container');
        if (container) {
          if (e.target.value === 'はじめて！') {
            container.classList.add('hidden');
          } else {
            container.classList.remove('hidden');
          }
        }
      }
    });

    // 初期画面を描画
    render();
  };
</script>
