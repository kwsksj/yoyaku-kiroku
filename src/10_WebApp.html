<!--
=================================================================
【ファイル名】: 10_WebApp.html
【バージョン】: 26.0 (モジュール化対応版)
【更新日時】: 2025-08-04
【説明】:
- 設定とモック機能を外部ファイルに分離
- より保守性の高い構造に改善
- テスト環境とプロダクション環境の分離
=================================================================
-->
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <base target="_top" />
    <title>きぼりの よやく・きろく 川崎誠二木彫り教室</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+New:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
  </head>

  <body class="bg-brand-bg min-h-screen">
    <!-- デバッグ情報表示エリア（本番環境では非表示） -->

    <!-- アプリケーションのメインコンテナ -->
    <div id="app" class="container mx-auto px-4 max-w-lg">
      <!-- ローディング画面 -->
      <div
        id="loading"
        class="loading-fade fixed inset-0 flex flex-col items-center justify-center z-50"
      >
        <div class="spinner mb-4"></div>
        <p id="loading-message" class="text-brand-text">
          アプリケーションを読み込み中...
        </p>
      </div>

      <!-- メインコンテンツ -->
      <main id="main-content" class="py-6">
        <div id="view-container"></div>
      </main>

      <!-- モーダルオーバーレイ -->
      <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content" class="modal-content">
          <div id="modal-body"></div>
        </div>
      </div>

      <!-- カスタムモーダル -->
      <div
        id="custom-modal"
        class="fixed inset-0 bg-gray-800 bg-opacity-50 flex items-center justify-center z-50"
      >
        <div class="bg-white rounded-lg p-6 max-w-sm mx-4">
          <h3 id="modal-title" class="text-lg font-bold mb-4"></h3>
          <div id="modal-message" class="mb-6"></div>
          <div id="modal-buttons" class="flex gap-3 justify-end"></div>
        </div>
      </div>
      <footer class="text-center text-sm text-brand-muted mt-4">
        きぼりの よやく・きろく
      </footer>
    </div>

    <!-- GAS環境用のJavaScriptファイル読み込み（テンプレート評価対応） -->
    
    <!-- 統合JavaScript (自動生成) -->
<script>
  // @ts-check
  /// <reference path="../html-globals.d.ts" />

  // グローバル変数宣言（VSCode TypeScript言語サーバー用）
  /* global CONSTANTS:readonly, STATUS:readonly, CLASSROOMS:readonly, ITEMS:readonly, HEADERS:readonly */
  /* global ITEM_TYPES:readonly, UNITS:readonly, PAYMENT_METHODS:readonly, UI:readonly, SESSIONS:readonly */
  /* global PAYMENT:readonly, BANK_INFO:readonly, BANK:readonly, MESSAGES:readonly, LOG_ACTIONS:readonly */
  /* global CLASSROOM_TYPES:readonly, SCHEDULE_STATUS:readonly, SHEET_NAMES:readonly, LIMITS:readonly */
  /* global DISCOUNT_OPTIONS:readonly, TIME_SETTINGS:readonly, SYSTEM:readonly, HEADERS_RESERVATIONS:readonly */
  /* global HEADERS_ROSTER:readonly, HEADERS_ACCOUNTING:readonly, HEADERS_SCHEDULE:readonly */
  /* global DesignConfig:readonly, stateManager:readonly, Components:readonly, pageTransitionManager:readonly */
  /* global escapeHTML:readonly, formatDate:readonly, showLoading:readonly, hideLoading:readonly */
  /* global showInfo:readonly, showConfirm:readonly, debugLog:readonly, getTuitionItemRule:readonly */
  /* global getTimeBasedTuitionHtml:readonly, createReservationCard:readonly, findReservationByDateAndClassroom:readonly */
  /* global isTimeBasedClassroom:readonly, getClassroomTimesFromSchedule:readonly, buildSalesChecklist:readonly */
  /* global findReservationById:readonly, google:readonly, server:readonly, MockData:readonly */
  /* global isProduction:readonly, C:readonly */

  // ESLintワンライン無効化
  /* eslint-disable no-undef */

  /**
   * =================================================================
   * 統合フロントエンドJavaScript (自動生成)
   * Generated: 2025-09-06T17:16:39.751Z
   * =================================================================
   */

  // =================================================================
  // 11_WebApp_Config.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 11_WebApp_Config.html
   * 【バージョン】: 1.7
   * 【役割】: WebAppのフロントエンドで使用される設定とスタイル定義
   * 【構成】: 14ファイル構成のうちの11番目
   * 【v1.7での変更点】:
   * - 全体的な配色をよりエネルギッシュで温かみのあるテーマに更新
   * - ボタンのテキストの可読性を向上
   * - 会計ボタンに黄色系の配色を適用
   * - 記録カードに背景色を追加
   * =================================================================
   */

  // =================================================================
  // 1. APPLICATION CONSTANTS（統一定数システム）
  // =================================================================

  // 【重要】統一定数は getAppInitialData() で取得される constants オブジェクトを使用
  // バックエンドの 00_Constants.js で定義された統一定数がフロントエンドに配信される
  //
  // 使用例:
  // - stateManager.getState().constants.classrooms.TOKYO （'東京教室'）
  // - stateManager.getState().constants.headers.STUDENT_ID （'生徒ID'）
  // - STATUS.WAITLISTED （'waitlisted'）
  // - stateManager.getState().constants.sessions.MORNING （'午前'）
  // - BANK.NAME （'ゆうちょ銀行'）
  // - stateManager.getState().constants.frontendUi.DISCOUNT_OPTIONS.THIRTY_MIN （30）
  //
  // 注意: このファイルでは、バックエンド定数との重複を避けるため
  // フロントエンド固有の定数のみ定義する

  // --- フロントエンド専用定数（統一定数システムに移行済み） ---

  // 【移行完了】以下の定数は 00_Constants.js に移行し、constants オブジェクトでアクセス可能
  // - ITEM_NAME_DISCOUNT → stateManager.getState().constants.items.DISCOUNT
  // - SESSION_MORNING/AFTERNOON/ALL_DAY → stateManager.getState().constants.sessions.MORNING/AFTERNOON/ALL_DAY
  // - UNIT_CM3 → stateManager.getState().constants.units.CM3
  // - PAYMENT.* → stateManager.getState().constants.paymentDisplay.*
  // - BANK_* → BANK.*
  // - DISCOUNT_OPTION_* → stateManager.getState().constants.frontendUi.DISCOUNT_OPTIONS.*
  // - TIME_STEP_MINUTES → stateManager.getState().constants.frontendUi.TIME_SETTINGS.STEP_MINUTES
  // - TIME_END_BUFFER_HOURS → stateManager.getState().constants.frontendUi.TIME_SETTINGS.END_BUFFER_HOURS

  // 【互換性】既存コードとの互換性のため、必要に応じて個別定数も利用可能
  // 例: const SESSION_MORNING = stateManager.getState().constants.sessions.MORNING;

  // 【純粋にフロントエンド専用】以下は本当にフロントエンドでしか使わない定数のみ

  // ステータス定数（フロントエンド専用 - バックエンド定数と同期）
  const STATUS = {
    CANCELED: '取消', // キャンセル済み
    WAITLISTED: '待機', // キャンセル待ち
    CONFIRMED: '確定', // 予約確定（会計前）
    COMPLETED: '完了', // 完了（会計済み）
  };

  // =================================================================
  // 2. DESIGN CONFIGURATION
  // =================================================================
  const DesignConfig = {
    // テキストや背景の色設定（温かみと活気のある配色）
    colors: {
      text: 'text-brand-text', // メインテキスト
      textSubtle: 'text-brand-subtle', // サブテキスト
      textMuted: 'text-brand-muted', // 薄いテキスト
      primary:
        'bg-action-primary-bg text-action-primary-text active:bg-action-primary-hover', // プライマリ (テラコッタ)
      secondary:
        'bg-action-secondary-bg text-action-secondary-text active:bg-action-secondary-hover', // セカンダリ (明るいベージュ)
      attention:
        'bg-action-attention-bg text-action-attention-text active:bg-action-attention-hover', // 注意 (若葉色)
      accounting:
        'bg-action-accounting-bg text-action-accounting-text active:bg-action-accounting-hover', // 会計 (アンバー)
      danger:
        'bg-state-danger-bg text-state-danger-text active:bg-state-danger-hover', // 危険 (落ち着いた赤)
      success:
        'bg-state-success-bg text-state-success-text active:bg-state-success-hover', // 成功 (若葉色)
      paid: 'bg-action-paid-bg text-action-paid-text', // 支払い済み (薄い緑)
      info: 'bg-ui-surface text-brand-text border border-ui-border',
      warning:
        'bg-ui-warning-bg text-ui-warning-text border border-ui-warning-border',
      error: 'bg-ui-error-bg text-ui-error-text border border-ui-error-border',
    },

    // 教室別のボタン色設定
    classroomColors: {
      tokyo: {
        button: 'bg-red-50 border-red-200 text-red-800 hover:bg-red-100',
        colorClass: 'bg-red-50 border-red-200 text-red-800 hover:bg-red-100',
      },
      numazu: {
        button: 'bg-blue-50 border-blue-200 text-blue-800 hover:bg-blue-100',
        colorClass: 'bg-blue-50 border-blue-200 text-blue-800 hover:bg-blue-100',
      },
      tsukuba: {
        button: 'bg-green-50 border-green-200 text-green-800 hover:bg-green-100',
        colorClass:
          'bg-green-50 border-green-200 text-green-800 hover:bg-green-100',
      },
      default: {
        button:
          'bg-state-available-bg border-state-available-border text-brand-text hover:bg-gray-50',
        colorClass:
          'bg-state-available-bg border-state-available-border text-brand-text hover:bg-gray-50',
      },
    },

    // ボタンの基本スタイル
    buttons: {
      base: 'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly',
      full: 'w-[250px] mx-auto block',
      auto: 'w-auto',
      primary:
        'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly bg-action-primary-bg text-action-primary-text active:bg-action-primary-hover',
      secondary:
        'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly bg-action-secondary-bg text-action-secondary-text active:bg-action-secondary-hover',
      attention:
        'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly bg-action-attention-bg text-action-attention-text active:bg-action-attention-hover',
      accounting:
        'font-bold py-2.5 px-5 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly bg-action-accounting-bg text-action-accounting-text active:bg-action-accounting-hover',
    },

    // テキストスタイル設定
    text: {
      heading: 'text-xl font-bold text-brand-text',
      subheading: 'text-lg font-medium text-brand-text',
      body: 'text-base text-brand-text',
      bodySubtle: 'text-base text-brand-subtle',
      caption: 'text-sm text-brand-subtle',
      label: 'text-base font-bold text-brand-text',
      labelBlock: 'block text-brand-text text-base font-bold mb-2',
    },

    // レイアウトユーティリティ
    layout: {
      container: 'max-w-screen-sm mx-auto p-4',
      containerNoPadding: 'max-w-screen-sm mx-auto',
      section: 'mb-8',
      card: 'shadow-card rounded-lg border border-solid border-card-border',
      centerContent: 'flex items-center justify-center',
      spaceBetween: 'flex items-center justify-between',
    },

    // ユーティリティクラス
    utils: {
      hidden: 'hidden',
      loading: 'opacity-50 pointer-events-none',
      mobileFriendly: 'mobile-button touch-friendly',
      flexCenter: 'flex items-center justify-center',
      flexBetween: 'flex items-center justify-between',
      fullWidth: 'w-full',
      autoMargin: 'mx-auto',
    },

    // カードスタイル
    cards: {
      base: 'w-full text-left p-3 rounded-lg mobile-card touch-friendly transition-all duration-150',
      container: 'max-w-md mx-auto space-y-3',
      background: 'bg-ui-surface border border-ui-border',
      state: {
        available: {
          card: 'bg-state-available-bg border border-state-available-border mobile-card active:bg-state-success-hover',
          text: 'text-state-available-text',
        },
        waitlist: {
          card: 'bg-state-waitlist-bg border border-state-waitlist-border mobile-card',
          text: 'text-state-waitlist-text',
        },
        booked: {
          card: 'bg-state-booked-bg border border-state-booked-border mobile-card',
          text: 'text-state-booked-text',
        },
        history: {
          card: 'bg-brand-light border border-ui-border mobile-card',
        },
      },
    },

    // 入力フォームのスタイル
    inputs: {
      container: 'max-w-md mx-auto',
      base: 'text-lg w-full p-3 border border-ui-border rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-text mobile-input touch-friendly bg-ui-input focus:bg-ui-input-focus transition-all duration-150',
      textarea:
        'text-lg w-full p-3 border border-ui-border rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-text h-24 mobile-input bg-ui-input focus:bg-ui-input-focus transition-all duration-150',
    },
  };

  // =================================================================
  // 3. CSS STYLES SETUP
  // =================================================================
  const addCustomStyles = () => {
    const style = document.createElement('style');
    style.textContent = `
        /* ========== Font Loading Optimization ========== */
        @import url('https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+New:wght@400;500;700&display=swap');

        /* Prevent FOUT (Flash of Unstyled Text) */
        .font-loading {
          visibility: hidden;
        }

        .fonts-loaded .font-loading {
          visibility: visible;
        }

        /* ========== CSS Variables - kibori-class.net完全調和デザイン ========== */
        :root {
          /* Energetic and warm theme for a wood carving school */
          --brand-text: #4E342E;       /* Dark Brown for high readability */
          --brand-subtle: #785A4E;     /* Medium Brown for sub-text */
          --brand-muted: #A1887F;      /* Lighter, soft brown */
          --brand-bg: #FFFDF5;         /* Warm, very light cream background */
          --brand-surface: #FFFFFF;    /* White for card backgrounds for a clean look */
          --brand-light: #F5F1ED;      /* Light, warm beige for hover states */

          --action-primary: #C86F34;   /* Energetic terracotta for main actions */
          --action-secondary: #E4CDBA; /* Light, warm beige for secondary actions */
          --action-attention: #5A8C36; /* Lively, fresh green for attention */
          --action-accounting: #F59E0B;/* Bright amber for accounting actions */
          --action-danger: #B91C1C;    /* A clear, strong red for danger */

          --state-available: #5A8C36;  /* Lively green for available slots */
          --state-waitlist: #F59E0B;   /* Bright amber for waitlist */
          --state-booked: #785A4E;     /* Medium brown for booked slots */

          /* UI要素 - より洗練された境界線と背景 */
          --ui-border: #D4C4B8;        /* 温かみのあるベージュ境界線 */
          --ui-border-light: #E8DDD6;  /* より薄い境界線 */
          --ui-input: #FAFAFA;         /* 入力フィールド背景 */
          --ui-input-focus: #FFFFFF;   /* フォーカス時背景 */
          --ui-surface: #FFFFFF;       /* サーフェス背景 */

          /* モーダルとオーバーレイ */
          --modal-overlay: rgba(73, 59, 49, 0.6); /* ブランドカラーベースのオーバーレイ */
          --spinner-border: #f3f4f6;

          /* 影とエフェクト */
          --shadow-sm: 0 1px 2px 0 rgba(73, 59, 49, 0.05);
          --shadow-md: 0 4px 6px -1px rgba(73, 59, 49, 0.1);
          --shadow-lg: 0 10px 15px -3px rgba(73, 59, 49, 0.1);
        }

        /* ========== Base Styles ========== */
        body {
          font-family: 'Zen Kaku Gothic New', sans-serif;
          color: var(--brand-text);
          background-color: var(--brand-bg);
          line-height: 1.6;
          /* モバイル環境でのGoogleサイト埋め込み対応 */
          padding-top: env(safe-area-inset-top, 0);
        }

        /* Googleサイト埋め込み時のモバイル対応 */
        @media screen and (max-width: 768px) {
          body.embedded-in-google-sites {
            padding-top: 60px; /* Googleサイトのメニューバー分の余白 */
          }

          body.embedded-in-google-sites .fixed.top-4 {
            top: 70px; /* 戻るボタン位置を調整 */
          }

          .app-container {
            min-height: calc(100vh - 60px);
          }
        }

        /* より大きなメニューバーの場合 */
        @media screen and (max-width: 480px) {
          body.embedded-in-google-sites {
            padding-top: 80px;
          }

          body.embedded-in-google-sites .fixed.top-4 {
            top: 90px; /* より小さなスクリーンでの戻るボタン調整 */
          }

          .app-container {
            min-height: calc(100vh - 80px);
          }
        }

        /* ========== Mobile-Friendly Components ========== */
        .mobile-button, .mobile-input, .mobile-card {
          min-height: 48px;
        }
        .touch-friendly {
          touch-action: manipulation;
        }

        /* ========== Animations ========== */
        .fade-in { animation: fadeInUp 0.3s ease-out; }
        @keyframes fadeInUp {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .spinner {
          border: 4px solid var(--spinner-border);
          width: 32px;
          height: 32px;
          border-radius: 50%;
          border-left-color: var(--brand-text);
          animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* ========== Layout Components ========== */
        #loading { z-index: 100; }
        .modal-overlay {
          position: fixed; inset: 0; background-color: var(--modal-overlay);
          display: flex; align-items: center; justify-content: center;
          z-index: 50; opacity: 0; transition: opacity 0.3s ease;
          pointer-events: none; backdrop-filter: blur(3px);
        }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }
        #custom-modal {
          opacity: 0; transition: opacity 0.3s ease; pointer-events: none;
        }
        #custom-modal.active { opacity: 1; pointer-events: auto; }
        /* 汎用モーダルのフェードインアニメーション */
        .modal-fade {
          opacity: 0; transition: opacity 0.3s ease; pointer-events: none;
        }
        .modal-fade.active { opacity: 1; pointer-events: auto; }
        /* ローディング画面のフェードアニメーション */
        .loading-fade {
          opacity: 0; transition: opacity 0.3s ease; pointer-events: none;
        }
        .loading-fade.active { opacity: 1; pointer-events: auto; }
        /* ローディング画面の背景を少し透明にして滑らかな遷移を実現 */
        #loading { background-color: rgba(255, 255, 255, 0.95); backdrop-filter: blur(2px); }
        .modal-content {
          background: white; padding: 1.5rem; border-radius: 0.75rem;
          width: 90%; max-width: 400px; text-align: center;
          max-height: 85vh; overflow-y: auto;
        }
        .modal-content p { margin-bottom: 1.25rem; }
        .modal-content .modal-buttons { justify-content: center; }

        /* ========== Custom Components ========== */
        details > summary { list-style: none; cursor: pointer; }
        details > summary::-webkit-details-marker { display: none; }

        .accounting-item, .reservation-card {
          background-color: var(--brand-surface);
          border: 1px solid var(--ui-border);
          transition: all 0.2s ease;
          position: relative;
        }
        .accounting-item:hover, .reservation-card:hover {
          transform: translateY(-2px);
          box-shadow: var(--shadow-md);
          border-color: var(--brand-accent);
        }

        /* ========== レイアウト改善 - memo.md問題対応 ========== */

        /* 戻るボタンの位置を右上に固定（問題#3対応） */
        .back-button-container {
          position: fixed;
          top: 1rem;
          right: 1rem;
          z-index: 40;
          transform: none !important; /* 位置ズレ防止（問題#36対応） */
        }

        /* Googleサイト埋め込み時の戻るボタン調整（問題#14対応） */
        body.embedded-in-google-sites .back-button-container {
          top: 70px;
        }

        @media screen and (max-width: 480px) {
          body.embedded-in-google-sites .back-button-container {
            top: 90px;
          }
        }

        /* ========== 新カードレイアウト - よやく・きろくカード ========== */

        .reservation-card, .record-card {
          padding: 1rem;
          display: flex;
          flex-direction: column;
          gap: 1rem;
          position: relative;
        }

        /* カード上部: 教室情報 + 編集ボタン */
        .card-header {
          display: flex;
          justify-content: space-between;
          align-items: flex-start;
          gap: 1rem;
        }

        .card-class-info {
          flex: 1;
          display: flex;
          flex-direction: column;
          gap: 0.25rem;
        }

        .card-class-info .class-datetime {
          font-weight: 600;
          color: var(--brand-text);
          font-size: 1rem;
        }

        .card-class-info .class-venue {
          color: var(--brand-subtle);
          font-size: 0.875rem;
        }

        .card-edit-button {
          flex-shrink: 0;
          align-self: flex-start;
        }

        .card-edit-button button {
          font-size: 0.75rem;
          padding: 0.375rem 0.75rem;
          white-space: nowrap;
        }

        /* カード中央: 制作メモエリア */
        .card-memo-section {
          background-color: var(--brand-light);
          border: 1px solid var(--ui-border-light);
          border-radius: 0.5rem;
          padding: 0.75rem;
          min-height: 4rem;
        }

        .card-memo-section .memo-label {
          font-size: 0.75rem;
          font-weight: 600;
          color: var(--brand-subtle);
          margin-bottom: 0.5rem;
          display: block;
        }

        .card-memo-section .memo-content {
          color: var(--brand-text);
          font-size: 0.875rem;
          line-height: 1.4;
          white-space: pre-wrap;
          word-break: break-word;
        }

        .card-memo-section .memo-empty {
          color: var(--brand-muted);
          font-style: italic;
        }

        /* カード下部: 当日のみ表示される会計ボタン */
        .card-accounting-section {
          border-top: 1px solid var(--ui-border-light);
          padding-top: 0.75rem;
          display: flex;
          justify-content: center;
        }

        .card-accounting-section button {
          min-width: 150px;
        }

        /* 当日以外は会計セクションを非表示 */
        .card-accounting-section.hidden {
          display: none;
        }

        /* ボタン配置の統一（問題#27,33対応） */
        .button-group {
          display: flex;
          gap: 0.75rem;
          justify-content: center;
          flex-wrap: wrap;
          margin: 1rem 0;
        }

        /* 左寄せが適切なページでは左寄せを維持 */
        .button-group.left-aligned {
          justify-content: flex-start;
        }

        /* オレンジ色ボタンの配置修正（問題#27対応） */
        .button-group button.accounting {
          flex-shrink: 0;
        }

        /* モーダル長さ制限（問題#15対応） */
        .modal-content {
          max-height: 80vh;
          overflow-y: auto;
        }

        @media screen and (max-height: 600px) {
          .modal-content {
            max-height: 70vh;
          }
        }

        /* ========== ページ遷移とスクロール位置管理（問題#16対応） ========== */
        .page-container {
          min-height: 100vh;
          scroll-behavior: smooth;
        }

        /* ページ遷移時のスクロール位置リセット */
        .view-transition {
          animation: pageSlideIn 0.3s ease-out;
        }

        @keyframes pageSlideIn {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        /* ========== 文字のちらつき防止（問題#6対応） ========== */
        .content-container {
          opacity: 0;
          transition: opacity 0.2s ease-in;
        }

        .content-container.loaded {
          opacity: 1;
        }

        /* フォント読み込み完了まで非表示 */
        .font-loading .content-container {
          visibility: hidden;
        }

        /* ========== Skeleton Loading States ========== */
        .skeleton {
          background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
          background-size: 200% 100%;
          animation: loading 1.5s infinite;
        }
        @keyframes loading {
          0% { background-position: 200% 0; }
          100% { background-position: -200% 0; }
        }

        /* ========== Enhanced Responsive Design ========== */

        /* タブレット用調整 */
        @media screen and (min-width: 641px) and (max-width: 1024px) {
          .container {
            max-width: 600px;
            padding: 2rem;
          }

          .button-group {
            gap: 1rem;
          }

          .reservation-card .card-actions button {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
          }
        }

        /* スマートフォン用調整 */
        @media (max-width: 640px) {
          .modal-content {
            width: 95%;
            padding: 1rem;
            margin: 1rem;
          }
          .mobile-button, .mobile-input { font-size: 16px; }

          /* ボタングループの小画面対応 */
          .button-group {
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
          }

          .button-group button {
            width: 100%;
            max-width: 280px;
          }

          /* 戻るボタンのモバイル調整 */
          .back-button-container {
            top: 0.5rem;
            right: 0.5rem;
          }

          .back-button-container button {
            padding: 0.5rem;
            font-size: 0.875rem;
          }

          /* カードのモバイル最適化 */
          .reservation-card, .record-card {
            padding: 0.75rem;
            gap: 0.75rem;
          }

          .card-header {
            flex-direction: column;
            gap: 0.75rem;
            align-items: stretch;
          }

          .card-edit-button {
            align-self: center;
          }

          .card-edit-button button {
            width: 100%;
            max-width: 120px;
          }

          .card-memo-section {
            padding: 0.5rem;
          }

          .card-accounting-section button {
            width: 100%;
            max-width: 200px;
          }
        }

        /* 極小画面（320px以下）対応 */
        @media (max-width: 320px) {
          .container {
            padding: 0.5rem;
          }

          .button-group button {
            font-size: 0.875rem;
            padding: 0.75rem;
          }

          .modal-content {
            margin: 0.5rem;
            padding: 0.75rem;
          }
        }
      `;
    document.head.appendChild(style);
  };

  // =================================================================
  // Font Loading Detection
  // =================================================================
  const setupFontLoadingDetection = () => {
    if ('fonts' in document) {
      document.fonts.ready.then(() => {
        document.documentElement.classList.add('fonts-loaded');
      });
    } else {
      // Fallback for older browsers
      setTimeout(() => {
        document.documentElement.classList.add('fonts-loaded');
      }, 1000);
    }
  };

  // =================================================================
  // Page Transition & Content Loading Management
  // =================================================================
  const setupPageTransitionManagement = () => {
    let currentView = null;
    let previousScrollPosition = 0;

    // ページ遷移時のスクロール位置リセット（問題#16対応）
    const resetScrollPosition = () => {
      window.scrollTo({ top: 0, left: 0, behavior: 'smooth' });
    };

    // スクロール位置を保存
    const saveScrollPosition = () => {
      previousScrollPosition = window.scrollY;
    };

    // スクロール位置を復元
    const restoreScrollPosition = () => {
      window.scrollTo({
        top: previousScrollPosition,
        left: 0,
        behavior: 'auto',
      });
    };

    // ページ遷移の判定とスクロール管理
    const handleViewChange = (newView, isModal = false) => {
      const hasViewChanged = currentView !== newView;

      if (isModal) {
        // モーダル開閉：スクロール位置を保持
        if (newView) {
          // モーダル開く時：現在位置を保存
          saveScrollPosition();
        } else {
          // モーダル閉じる時：位置を復元
          restoreScrollPosition();
        }
      } else if (hasViewChanged && newView) {
        // 実際のページ遷移：スクロール位置をリセット
        currentView = newView;
        resetScrollPosition();
      }
    };

    // コンテンツ読み込み完了時の表示制御（問題#6対応）
    const initializeContentVisibility = () => {
      // フォント読み込み完了を待機
      document.fonts.ready.then(() => {
        const contentContainers = document.querySelectorAll('.content-container');
        contentContainers.forEach(container => {
          container.classList.add('loaded');
        });
      });

      // ページ遷移アニメーション
      const pageContainer = document.querySelector('.page-container');
      if (pageContainer) {
        pageContainer.classList.add('view-transition');
      }
    };

    // 戻るボタンの位置調整（問題#36対応）
    const stabilizeBackButtonPosition = () => {
      const backButtonContainer = document.querySelector(
        '.back-button-container',
      );
      if (backButtonContainer) {
        // 位置の強制リセット
        backButtonContainer.style.transform = 'none';
        backButtonContainer.style.transition = 'none';

        // 少し待ってからtransitionを復活（スムーズな動作のため）
        setTimeout(() => {
          backButtonContainer.style.transition = 'all 0.2s ease';
        }, 100);
      }
    };

    return {
      resetScrollPosition,
      saveScrollPosition,
      restoreScrollPosition,
      handleViewChange,
      initializeContentVisibility,
      stabilizeBackButtonPosition,

      // 統合初期化関数
      initializePage: () => {
        // 初回読み込み時は現在のビューを記録するのみ、スクロールリセットしない
        if (window.stateManager && window.stateManager.getState) {
          currentView = window.stateManager.getState().view;
        }
        initializeContentVisibility();
        stabilizeBackButtonPosition();
      },

      // ページ遷移時専用初期化（StateManagerから呼び出し）
      onPageTransition: newView => {
        handleViewChange(newView, false);
      },

      // モーダル操作時専用（showInfo, showConfirm等から呼び出し）
      onModalOpen: () => {
        handleViewChange('modal', true);
      },

      onModalClose: () => {
        handleViewChange(null, true);
      },
    };
  };

  // グローバルに公開（StateManagerから使用可能）
  window.pageTransitionManager = setupPageTransitionManagement();

  // =================================================================
  // Mobile & Embedded Site Detection
  // =================================================================
  const setupMobileOptimizations = () => {
    // Googleサイト埋め込み検知
    const detectEmbeddedEnvironment = () => {
      try {
        // iframe内での実行かどうかを判定
        const isInIframe = window.self !== window.top;

        // Googleサイトのreferrerを検知
        const isFromGoogleSites = document.referrer.includes('sites.google.com');

        // URLのクエリパラメータでの判定（将来的な拡張用）
        const urlParams = new URLSearchParams(window.location.search);
        const embedParam = urlParams.get('embedded');

        return isInIframe || isFromGoogleSites || embedParam === 'true';
      } catch (e) {
        // Cross-origin制限でエラーが発生した場合、埋め込み環境と判定
        return true;
      }
    };

    // モバイル環境の検知
    const isMobile =
      /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent,
      ) || window.innerWidth <= 768;

    // viewport設定の最適化
    const optimizeViewport = () => {
      let viewport = document.querySelector('meta[name=viewport]');
      if (!viewport) {
        viewport = document.createElement('meta');
        viewport.name = 'viewport';
        document.head.appendChild(viewport);
      }

      if (isMobile) {
        viewport.content =
          'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
      } else {
        viewport.content = 'width=device-width, initial-scale=1.0';
      }
    };

    // 埋め込み環境での調整を適用
    if (detectEmbeddedEnvironment()) {
      document.body.classList.add('embedded-in-google-sites');

      // 必要に応じて追加の調整
      if (isMobile) {
        document.body.classList.add('mobile-embedded');
      }
    }

    optimizeViewport();

    // タッチ操作の最適化
    if (isMobile) {
      document.body.classList.add('touch-device');

      // iOS Safariでのバウンス効果を無効化
      document.addEventListener(
        'touchmove',
        e => {
          if (e.target.closest('.scrollable')) {
            return; // スクロール可能エリア内では許可
          }
          e.preventDefault();
        },
        { passive: false },
      );
    }
  };

  // =================================================================
  // 4. TAILWIND CSS SETUP
  // =================================================================
  // 注意: CDN版Tailwindは本番環境では推奨されませんが、Google Apps Script環境では
  // PostCSS pluginやTailwind CLIの利用が困難なため、CDN版を使用しています。
  const setupTailwindCSS = () => {
    const tailwindScript = document.createElement('script');
    tailwindScript.src = 'https://cdn.tailwindcss.com';

    tailwindScript.onload = function () {
      if (window.tailwind) {
        window.tailwind.config = {
          theme: {
            extend: {
              fontSize: { '2xs': '0.625rem' },
              fontFamily: { sans: ['Zen Kaku Gothic New', 'sans-serif'] },
              colors: {
                brand: {
                  bg: '#FFFDF5',
                  surface: '#FFFFFF',
                  text: '#4E342E',
                  subtle: '#785A4E',
                  light: '#F5F1ED',
                  dark: '#4E342E',
                  muted: '#A1887F',
                },
                action: {
                  'primary-bg': '#C86F34',
                  'primary-text': '#FFFFFF',
                  'primary-hover': '#A95B2A',
                  'secondary-bg': '#E4CDBA',
                  'secondary-text': '#4E342E', // Improved contrast
                  'secondary-hover': '#D7BCA9',
                  'attention-bg': '#5A8C36',
                  'attention-text': '#FFFFFF',
                  'attention-hover': '#4A732C',
                  'accounting-bg': '#F59E0B', // Amber
                  'accounting-text': '#4E342E', // Dark text for readability
                  'accounting-hover': '#D97706',
                  'danger-bg': '#B91C1C',
                  'danger-text': '#FFFFFF',
                  'danger-hover': '#991B1B',
                  'paid-bg': '#F0FDF4',
                  'paid-text': '#166534',
                },
                state: {
                  'available-text': '#166534',
                  'available-bg': '#F0FDF4',
                  'available-border': '#A7F3D0',
                  'available-hover': '#D1FAE5',
                  'waitlist-text': '#B45309',
                  'waitlist-bg': '#FFFBEB',
                  'waitlist-border': '#FDE68A',
                  'booked-text': '#44403C',
                  'booked-bg': '#F5F5F4',
                  'booked-border': '#E7E5E4',
                  'success-bg': '#F0FDF4',
                  'success-text': '#166534',
                  'success-border': '#A7F3D0',
                  'success-hover': '#D1FAE5',
                  'danger-bg': '#FEF2F2',
                  'danger-text': '#B91C1C',
                  'danger-border': '#FECACA',
                  'danger-hover': '#FEE2E2',
                },
                ui: {
                  border: '#E4CDBA',
                  'border-light': '#F5F1ED',
                  surface: '#FFFFFF',
                  input: '#FAFAFA',
                  'input-focus': '#FFFFFF',
                  'error-text': '#B91C1C',
                  'error-bg': '#FEF2F2',
                  'error-border': '#FECACA',
                  'warning-text': '#B45309',
                  'warning-bg': '#FFFBEB',
                  'warning-border': '#FDE68A',
                  'link-text': '#0369A1',
                  'weekend-sunday': '#B91C1C',
                  'weekend-saturday': '#0369A1',
                },
              },
            },
          },
        };
      }
    };

    tailwindScript.onerror = function () {
      console.warn('[CONFIG] Tailwind CSS読み込みに失敗しました');
    };

    document.head.appendChild(tailwindScript);
  };

  // =================================================================
  // 5. INITIALIZATION
  // =================================================================
  addCustomStyles();
  setupTailwindCSS();
  setupFontLoadingDetection();
  setupMobileOptimizations();

  // DOM読み込み完了後にページ遷移管理を初期化
  document.addEventListener('DOMContentLoaded', () => {
    if (window.pageTransitionManager) {
      window.pageTransitionManager.initializePage();
    }
  });


  // =================================================================
  // 12_WebApp_Core.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 12_WebApp_Core.js
   * 【バージョン】: 1.2
   * 【役割】: WebAppのフロントエンドにおける中核機能を集約します。
   * - 状態管理 (State Management)
   * - UIコンポーネント生成 (UI Components)
   * - 汎用ユーティリティ (Utilities)
   * - 会計計算ロジック (Calculation Logic)
   * 【構成】: 14ファイル構成のうちの12番目
   * 【v1.2での変更点】:
   * - リファクタリング: 日付・スロット処理の共通ユーティリティ関数を追加。
   * - filterFutureSlots, groupSlotsByMonth 関数を新規追加。
   * - コードの可読性とメンテナンス性を向上。
   * =================================================================
   */

  /**
   * =================================================================
   * --- New Data Model Client-Side Processing (2025-08-19) ---
   * =================================================================
   */

  // calculateSlotsFromReservations関数とtransformReservationArrayToObject関数は削除されました
  // 予約データの処理は全てバックエンドで実行され、getAvailableSlots()とgetUserReservations()を使用します

  /**
   * =================================================================
   * --- 統一検索関数システム (2025-08-30) ---
   * 「よやく」(myBookings) と「きろく」(history) を統一的に検索する関数群
   * =================================================================
   */

  /**
   * 予約IDで「よやく」と「きろく」を統一的に検索します
   * @param {string} reservationId - 検索対象の予約ID
   * @param {object} state - stateManager.getState()の戻り値
   * @returns {object|null} 見つかった予約/記録データ、見つからない場合はnull
   */
  function findReservationById(reservationId, state = null) {
    const currentState = state || window.stateManager?.getState();
    if (!currentState) return null;

    // 1. まず「よやく」(myBookings)から検索
    const bookingResult = currentState.myBookings?.find(
      item => item.reservationId === reservationId,
    );
    if (bookingResult) {
      return { ...bookingResult, type: 'booking' };
    }

    // 2. 次に「きろく」(history)から検索
    const historyResult = currentState.history?.find(
      item => item.reservationId === reservationId,
    );
    if (historyResult) {
      return { ...historyResult, type: 'record' };
    }

    return null;
  }

  /**
   * 日付と教室で「よやく」と「きろく」を統一的に検索します
   * @param {string} date - 検索対象の日付 (YYYY-MM-DD)
   * @param {string} classroom - 検索対象の教室名
   * @param {object} state - stateManager.getState()の戻り値
   * @returns {object|null} 見つかった予約/記録データ、見つからない場合はnull
   */
  function findReservationByDateAndClassroom(date, classroom, state = null) {
    const currentState = state || window.stateManager?.getState();
    if (!currentState) return null;

    // キャンセル済みステータスの判定用関数
    const isCancelledStatus = status => {
      return (
        status === (window.STATUS?.CANCELED || '取消') ||
        status === 'キャンセル' ||
        status === 'キャンセル済み' ||
        status === '取消'
      );
    };

    // 1. まず「よやく」(myBookings)から検索（キャンセル済みを除外）
    const bookingResult = currentState.myBookings?.find(
      item =>
        item.date === date &&
        item.classroom === classroom &&
        !isCancelledStatus(item.status),
    );
    if (bookingResult) {
      return { ...bookingResult, type: 'booking' };
    }

    // 2. 次に「きろく」(history)から検索（キャンセル済みを除外）
    const historyResult = currentState.history?.find(
      item =>
        item.date === date &&
        item.classroom === classroom &&
        !isCancelledStatus(item.status),
    );
    if (historyResult) {
      return { ...historyResult, type: 'record' };
    }

    return null;
  }

  /**
   * 指定されたステータスの予約/記録を検索します
   * @param {string} status - 検索対象のステータス
   * @param {object} state - stateManager.getState()の戻り値
   * @returns {Array} 条件に合致する予約/記録の配列
   */
  function findReservationsByStatus(status, state = null) {
    const currentState = state || window.stateManager?.getState();
    if (!currentState) return [];

    const results = [];

    // 「よやく」(myBookings)から検索
    if (currentState.myBookings) {
      currentState.myBookings
        .filter(item => item.status === status)
        .forEach(item => results.push({ ...item, type: 'booking' }));
    }

    // 「きろく」(history)から検索
    if (currentState.history) {
      currentState.history
        .filter(item => item.status === status)
        .forEach(item => results.push({ ...item, type: 'record' }));
    }

    return results;
  }

  /**
   * 新しい初期データを受け取り、クライアントサイドで処理してappStateを構築する
   * @param {object} data - getAppInitialDataから返されたデータオブジェクト (allStudents, accountingMaster, etc.)
   * @param {string} phone - ログイン試行された電話番号
   * @param {Array} availableSlots - バックエンドから取得済みの空席情報
   * @param {object | null} userReservations - ユーザーの予約と履歴データ {myBookings, myHistory}
   * @returns {object} setStateに渡すための新しい状態オブジェクト。ユーザーが見つからない場合は { currentUser: null }
   */
  function processInitialData(
    data,
    phone,
    availableSlots,
    userReservations = null,
  ) {
    const { allStudents, accountingMaster, cacheVersions, today, constants } =
      data;

    // 1. 電話番号でユーザーを検索
    const currentUser = Object.values(allStudents).find(
      student => student.phone === phone,
    );

    if (!currentUser) {
      return { currentUser: null }; // ユーザーが見つからない
    }

    // currentUserのdisplayNameをセット
    currentUser.displayName = currentUser.nickname || currentUser.realName;

    // 2. 個人予約データはバックエンドから取得済み
    const myBookings = userReservations ? userReservations.myBookings : [];
    const myHistory = userReservations ? userReservations.myHistory : [];

    // 3. 教室一覧は統合定数から取得（StateManagerで設定される）
    // availableSlots から取得する必要はなくなった
    const classroomsFromConstants = constants
      ? Object.values(constants.classrooms)
      : [];

    // 4. 空き枠バージョンを生成
    const slotsVersion = cacheVersions
      ? `${cacheVersions.allReservations || 0}-${cacheVersions.scheduleMaster || 0}`
      : null;

    // 5. appStateを構築
    return {
      view: 'dashboard',
      currentUser: currentUser,
      myBookings: myBookings,
      history: myHistory,
      slots: availableSlots,
      classrooms: classroomsFromConstants,
      accountingMaster: accountingMaster,
      today: today,
      constants: constants, // 統一定数を追加
      _allStudents: allStudents,
      _cacheVersions: cacheVersions,
      _slotsVersion: slotsVersion, // 空き枠バージョンを設定
    };
  }

  // =================================================================
  // --- Application State Management ---
  // -----------------------------------------------------------------
  // アプリケーション全体の動的な状態を一元管理します。
  // ユーザー情報、予約データ、現在の表示画面などが含まれます。
  // =================================================================

  // =================================================================
  // --- Environment Detection & Data Management ---
  // -----------------------------------------------------------------
  // 実行環境を自動検出し、適切なデータソースを選択します。
  // テスト環境: ブラウザ + モックデータ
  // 本番環境: Google Apps Script + 実データ
  // =================================================================

  /**
   * 実行環境の検出
   * @returns {string} 'test' | 'production'
   */
  const detectEnvironment = () => {
    try {
      // GAS環境の検出
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        return 'production';
      }
      return 'test';
    } catch (error) {
      return 'test';
    }
  };

  /**
   * 環境に応じたデータ取得
   * @param {string} dataType - データタイプ
   * @param {any} fallback - フォールバックデータ
   */
  const getEnvironmentData = (dataType, fallback = null) => {
    const env = detectEnvironment();

    if (env === 'test' && typeof MockData !== 'undefined') {
      return MockData[dataType] || fallback;
    }

    // GAS環境では初期値のみ返し、データは後でAPI呼び出しで取得
    return fallback;
  };

  // StateManagerの再初期化（依存関数が読み込まれた後）
  if (
    typeof window.initializeStateManager === 'function' &&
    !window.stateManager
  ) {
    console.log('🔄 StateManagerを再初期化中...');
    window.initializeStateManager();
  }

  // StateManagerが初期化された後にビューリスナーを設定
  // DOMContentLoadedまたはページ読み込み完了後に実行
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      if (window.stateManager && typeof setupViewListener === 'function') {
        setupViewListener();
      }
    });
  } else {
    // 既にDOMが読み込み済みの場合は即座に実行
    if (window.stateManager && typeof setupViewListener === 'function') {
      setupViewListener();
    }
  }

  // 注意: appStateオブジェクトは新しいStateManagerシステム（12_WebApp_StateManager.html）に移行されました
  // 下位互換性のため、appStateとsetStateは自動的にStateManagerにマッピングされます

  // 既存コード互換性のため、appStateは12_WebApp_StateManager.htmlで定義され、
  // window.appStateとして公開されています

  /**
   * モーダル管理オブジェクト
   * カプセル化された方式でモーダルのコールバック処理を管理する
   * グローバル変数の乱用を避けるための設計
   */
  const ModalManager = {
    onConfirmCallback: null,

    /**
     * モーダル確認時のコールバック関数を設定
     * @param {Function} callback - 確認ボタン押下時に実行する関数
     */
    setCallback: function (callback) {
      this.onConfirmCallback = callback;
    },

    /**
     * 設定されたコールバック関数をクリア
     */
    clearCallback: function () {
      this.onConfirmCallback = null;
    },

    /**
     * 設定されたコールバック関数を実行し、自動でクリアする
     * モーダル確認ボタンから呼び出される
     */
    executeCallback: function () {
      if (this.onConfirmCallback) {
        this.onConfirmCallback();
        this.clearCallback();
      }
    },
  };

  // =================================================================
  // --- Utility Functions ---
  // -----------------------------------------------------------------

  /**
   * 電話番号を正規化します（全角→半角、ハイフン削除、バリデーション）
   * サーバーサイドのnormalizePhoneNumber関数と同等の処理をフロントエンドで実行
   * @param {string} phoneInput - 入力された電話番号
   * @returns {{normalized: string, isValid: boolean, error?: string}} 正規化結果
   */
  window.normalizePhoneNumberFrontend = function (phoneInput) {
    if (!phoneInput || typeof phoneInput !== 'string') {
      return {
        normalized: '',
        isValid: false,
        error: '電話番号を入力してください',
      };
    }

    // 全角数字を半角に変換
    let normalized = phoneInput.replace(/[０-９]/g, s =>
      String.fromCharCode(s.charCodeAt(0) - 65248),
    );

    // 各種ハイフンを削除
    normalized = normalized.replace(/[‐－\-]/g, '');

    // 空白文字を削除
    normalized = normalized.replace(/\s/g, '');

    // 数字以外の文字をチェック
    if (!/^\d+$/.test(normalized)) {
      return {
        normalized: '',
        isValid: false,
        error: '電話番号は数字のみ入力してください',
      };
    }

    // 桁数チェック（日本の携帯・固定電話は11桁または10桁）
    if (normalized.length !== 11 && normalized.length !== 10) {
      return {
        normalized: '',
        isValid: false,
        error: '電話番号は10桁または11桁で入力してください',
      };
    }

    // 先頭番号チェック（日本の電話番号パターン）
    if (normalized.length === 11 && !normalized.startsWith('0')) {
      return {
        normalized: '',
        isValid: false,
        error: '11桁の電話番号は0から始まる必要があります',
      };
    }

    return { normalized, isValid: true };
  };

  // =================================================================
  // --- UI Components (Moved to 13_WebApp_Components.html) ---
  // -----------------------------------------------------------------
  // UIコンポーネント生成関数群は13_WebApp_Components.htmlに移動されました。
  //
  // 移行された内容:
  // - window.escapeHTML 関数
  // - Components オブジェクト（全コンポーネント）
  // - 新設計のシンプル化されたコンポーネント
  // - レガシー互換性サポート
  // =================================================================

  // =================================================================
  // --- Loading Message System ---
  // -----------------------------------------------------------------
  // UI-11: ローディングメッセージの多様化機能
  // 状況に応じたメッセージとユーモラスなメッセージをランダムに表示し、
  // 数秒ごとに自動で切り替える機能を提供します。
  // =================================================================
  let loadingMessageTimer = null;

  const LoadingMessages = {
    // ログイン時のメッセージ
    login: [
      'めいぼ を さがしています...',
      'めいぼ じたい を さがしています...',
      'めいぼ の うらの めも を かくにん しています...',
      'きろく を かくにん しています...',
      'しょるい を ひもといて しています...',
      'なまえ を かくにん しています...',
      'なまえ の よみかた を かくにん しています...',
      'かお を おもいだしています...',
      'おみやげ を おもいだしています...',
      'さくひん を おもいだしています...',
      'とうろく が あるか しらべています...',
      'でんわばんごう を かくにん しています...',
      'ひと と なり を そうぞう しています...',
      'にがお え を かいています...',
    ],

    // 申し込み時のメッセージ
    booking: [
      'よやく を もうしこみ ちゅうです...',
      'しんせいしょ を ていしゅつ しています...',
      'はんこ を さがしています...',
      'ひづけ を かくにん しています...',
      'かれんだー に かきこんでいます...',
      'せき を ようい しています...',
      'きぼう を かなえようとしています...',
      'いろいろな ちょうせい を しています...',
      'そうごうてきに ちょうせい を しています...',
      'しょるい の けいしき を かくにんしています...',
      'じゅんばん に ならべています...',
    ],

    // 予約キャンセル時のメッセージ
    cancel: [
      'よやく を とりけしています...',
      'けしごむ を さがしています...',
      'とりけしせん を ひいています...',
      'おだいじに と おもっています...',
      'また こんど を たのしみにしています...',
      'べつの ひ を かんがえています...',
    ],

    // 予約編集時のメッセージ
    edit: [
      'へんこう を ほぞんしています...',
      'あたらしい ないよう に かきかえています...',
      'まちがい が ないか かくにんしています...',
      'かんがえなおして みています...',
      'こだわり を ちょうせい しています...',
    ],

    // 会計時のメッセージ
    accounting: [
      'でんぴょう を おくっています...',
      'ちょうぼ を つけています...',
      'おかね を かぞえています...',
      'おつり を じゅんびしています...',
      'そろばん を はじいています...',
      'けいさんき を たたいています...',
      'ぽけっと を さがしています...',
      'けいりのひと を よんでいます...',
    ],

    // データ取得時のメッセージ
    dataFetch: [
      'いろいろなもの を ひっくりかえしています...',
      'さがしもの を さがしています...',
      'たいせつなこと を おもいだしています...',
      'むこうのほう を のぞいています...',
      'じょうほう を つかまえています...',
      'しょるい を ひっくりかえしています...',
    ],

    // デフォルトのメッセージ
    default: [
      'せんせい を さがしています...',
      'しょるい を せいり しています...',
      'しょるい を ながめています...',
      'しょるい の けいしき を かくにん しています...',
      'しょるい を ぶんるい しています...',
      'きくず を かたずけています...',
      'ことば を えらんでいます...',
      'ていさい を ととのえています...',
      'みぎ の もの を ひだり に うごかしています...',
      'ひだり の もの を みぎ に うごかしています...',
      'こーひー を いれています...',
      'すこし きゅうけい しています...',
      'ねこ の て を かりようとしています...',
      'はむすたー の て を かりようとしています...',
      'そう の はな を かりようとしています...',
      'めだか を ながめています...',
      'めだか を かぞえています...',
      'はもの を ととのえています...',
      'てん と てん を むすんでいます...',
      'あたま を かくにん しています...',
      'せんせい は しゅうちゅう しています...',
      'せんせい は いま むかっています...',
      'あぷり を かいりょう しています...',
      'ぜんたい と ぶぶん を かんがえています...',
      'やらないといけないこと を ながめています...',
      'あたらしい こと を かんがえています...',
      'できあがり を おもいえがいています...',
      'つくえ の うえ で しごとらしきこと を しています...',
      'まるい もの を しかくく しようとしています...',
      'しかくい もの を まるく しようとしています...',
      'しかくい もの を よりしかくく しようとしています...',
      'おもしろい かたち を かんがえています...',
      'じかん が ゆっくり すぎています...',
      'じかん が あっというまに すぎています...',
      'いい かたち を さがしています...',
      'それらしい ことば を さがしています...',
      'なにをしようとしていたのか を おもいだしています...',
      'かたち を ながめています...',
    ],
  };

  const getRandomMessage = (category = 'default') => {
    const messages = [
      ...(LoadingMessages[category] || []),
      ...LoadingMessages.default,
    ];
    return messages[Math.floor(Math.random() * messages.length)];
  };

  const updateLoadingMessage = (category = 'default') => {
    const messageElement = document.getElementById('loading-message');
    if (messageElement) {
      messageElement.textContent = getRandomMessage(category);
    }
  };

  const startLoadingMessageRotation = (category = 'default') => {
    // 初期メッセージを設定
    updateLoadingMessage(category);

    // 3秒ごとにメッセージを更新
    loadingMessageTimer = setInterval(() => {
      updateLoadingMessage(category);
    }, UI?.LOADING_MESSAGE_INTERVAL || 3000);
  };

  const stopLoadingMessageRotation = () => {
    if (loadingMessageTimer) {
      clearInterval(loadingMessageTimer);
      loadingMessageTimer = null;
    }
  };

  const showLoading = (category = 'default') => {
    const loadingElement = document.getElementById('loading');

    loadingElement.classList.remove('hidden');

    // フェードインアニメーション
    requestAnimationFrame(() => {
      loadingElement.classList.add('active');
    });

    startLoadingMessageRotation(category);
  };

  const hideLoading = () => {
    const loadingElement = document.getElementById('loading');

    loadingElement.classList.remove('active');

    // フェードアウト完了後に完全に非表示
    setTimeout(() => {
      loadingElement.classList.add('hidden');
      stopLoadingMessageRotation();
    }, 300); // CSS transitionと同じ時間
  };

  // =================================================================
  // --- General Utilities ---
  /**
   * 販売品マスタから物販チェックリスト（折り畳み可能）を生成する関数
   * @param {Array} accountingMaster - 販売品マスタ
   * @param {Array} checkedValues - チェック済み項目名配列（任意）
   * @param {string} [title='販売品リスト'] - 見出しタイトル
   * @returns {string} HTML文字列
   */
  function buildSalesChecklist(
    accountingMaster,
    checkedValues = [],
    title = '販売品リスト',
  ) {
    const salesList = (accountingMaster || []).filter(
      item => item['種別'] === '物販',
    );
    if (!salesList.length) return '';
    const checklistHtml = getSalesCheckboxListHtml(salesList, checkedValues);
    return `
      <details class="mt-4">
        <summary class="cursor-pointer font-bold text-base py-2 px-3 bg-ui-surface border border-ui-border rounded hover:bg-ui-hover">${title} <span class="ml-2 text-sm text-brand-subtle">（クリックで展開）</span></summary>
        <div class="pt-2">${checklistHtml}</div>
      </details>
    `;
  }
  /**
   * 物販リストをチェックボックスで表示するHTMLを返す（再利用可能）
   * @param {Array} salesList - 物販アイテム配列
   * @param {Array} checkedValues - チェック済み項目名配列（任意）
   * @returns {string} HTML文字列
   */
  function getSalesCheckboxListHtml(salesList, checkedValues = []) {
    if (!salesList || salesList.length === 0) return '';
    return `
      <div class="mt-4 pt-4 border-t">
        <label class="font-bold mb-2 block">購入希望（チェック可）</label>
        <div class="grid grid-cols-1 gap-2">
          ${salesList
            .map(
              item => `
            <label class="flex items-center space-x-2">
              <input type="checkbox" name="orderSales" value="${item[HEADERS.ACCOUNTING.ITEM_NAME]}" class="accent-action-primary-bg" ${checkedValues.includes(item[HEADERS.ACCOUNTING.ITEM_NAME]) ? 'checked' : ''}>
              <span>${item[HEADERS.ACCOUNTING.ITEM_NAME]}${item[HEADERS.ACCOUNTING.UNIT_PRICE] ? `（${item[HEADERS.ACCOUNTING.UNIT_PRICE]}円）` : ''}</span>
            </label>
          `,
            )
            .join('')}
        </div>
      </div>`;
  }
  // -----------------------------------------------------------------
  // 日付のフォーマット、モーダルダイアログなど、
  // アプリ全体で汎用的に使用されるヘルパー関数群です。
  // =================================================================

  // =================================================================
  // 統一エラーハンドリングシステム（08_ErrorHandler.jsから統合）
  // =================================================================

  /**
   * フロントエンド統一エラーハンドラー
   */
  class FrontendErrorHandler {
    /**
     * エラーを処理し、ユーザーに適切に通知
     * @param {Error} error - エラーオブジェクト
     * @param {string} context - エラーコンテキスト
     * @param {Object} additionalInfo - 追加情報
     */
    static handle(error, context = '', additionalInfo = {}) {
      hideLoading(); // 既存のローディング非表示処理

      const errorInfo = {
        message: error.message || 'Unknown error',
        stack: error.stack || 'No stack trace available',
        context: context,
        timestamp: new Date().toISOString(),
        userId:
          (window.stateManager &&
            window.stateManager.getState().currentUser?.studentId) ||
          'anonymous',
        userAgent: navigator.userAgent,
        url: window.location.href,
        additionalInfo: additionalInfo,
      };

      // コンソールログに出力
      console.error('[ERROR]', context, errorInfo);

      // ユーザーへの通知
      const userMessage = this.getUserFriendlyMessage(error, context);
      showInfo(userMessage, 'エラー');

      // 重要なエラーの場合は詳細ログを送信（将来的にSentryなどへ）
      if (this.isCriticalError(error)) {
        this.reportError(errorInfo);
      }
    }

    /**
     * ユーザーフレンドリーなエラーメッセージを生成
     * @param {Error} error - エラーオブジェクト
     * @param {string} context - エラーコンテキスト
     * @returns {string} ユーザー向けメッセージ
     */
    static getUserFriendlyMessage(error, context) {
      // コンテキストに基づいて適切なメッセージを返す
      const contextMessages = {
        login:
          'ログイン処理中にエラーが発生しました。電話番号を確認してもう一度お試しください。',
        booking:
          '予約処理中にエラーが発生しました。時間をおいてもう一度お試しください。',
        cancel:
          'キャンセル処理中にエラーが発生しました。時間をおいてもう一度お試しください。',
        accounting:
          '会計処理中にエラーが発生しました。入力内容を確認してもう一度お試しください。',
        'data-load':
          'データの読み込み中にエラーが発生しました。ページを更新してもう一度お試しください。',
      };

      return (
        contextMessages[context] ||
        `エラーが発生しました: ${error.message}\n\n時間をおいてもう一度お試しください。`
      );
    }

    /**
     * 重要なエラーかどうかを判定
     * @param {Error} error - エラーオブジェクト
     * @returns {boolean}
     */
    static isCriticalError(error) {
      const criticalMessages = [
        'Script runtime exceeded',
        'Service invoked too many times',
        'Network error',
        'Timeout',
      ];

      return criticalMessages.some(
        msg => error.message && error.message.includes(msg),
      );
    }

    /**
     * エラーレポート送信（将来的にSentryなどの監視サービスへ）
     * @param {Object} errorInfo - エラー情報
     */
    static reportError(errorInfo) {
      // 現在はコンソールログのみ
      // 将来的にSentry、Bugsnag、LogRocketなどに送信
      console.log('[CRITICAL ERROR REPORT]', errorInfo);

      // 管理者への緊急通知も検討
      // この部分は将来的に実装予定
    }
  }

  /**
   * 既存のhandleServerError関数との互換性を保つラッパー関数
   * 段階的移行のため既存コードとの互換性を維持
   * @param {Error} err - サーバーから返されたエラーオブジェクト
   */
  function handleServerError(err) {
    FrontendErrorHandler.handle(err, 'server-error');
  }

  // グローバルエラーハンドラーの設定
  window.addEventListener('error', event => {
    FrontendErrorHandler.handle(event.error, 'global-error', {
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    });
  });

  // Promise拒否エラーのハンドリング
  window.addEventListener('unhandledrejection', event => {
    FrontendErrorHandler.handle(
      new Error(event.reason),
      'unhandled-promise-rejection',
    );
  });

  const formatDate = dStr => {
    if (!dStr) return '';
    const d = new Date(dStr);
    if (isNaN(d)) return '';
    d.setMinutes(d.getMinutes() + d.getTimezoneOffset());
    const day = d.getDay();
    const wd = ['日', '月', '火', '水', '木', '金', '土'];
    return `${d.getMonth() + 1}/${d.getDate()} <span class="font-bold ${day === 0 ? 'text-ui-weekend-sunday' : day === 6 ? 'text-ui-weekend-saturday' : ''}">${wd[day]}</span>`;
  };
  const showModal = c => {
    // モーダル表示時にスクロール位置を保存
    if (window.pageTransitionManager) {
      window.pageTransitionManager.onModalOpen();
    }

    const m = document.getElementById('custom-modal'),
      b = document.getElementById('modal-buttons');
    b.innerHTML = '';
    if (c.showCancel) {
      b.innerHTML += Components.createButton({
        text:
          c.cancelText ||
          window.stateManager.getState().constants?.messages?.CANCEL ||
          'キャンセル',
        action: 'modalCancel',
        colorClass: DesignConfig.colors.secondary,
        widthClass: DesignConfig.buttons.auto,
      });
    }
    if (c.confirmText) {
      b.innerHTML += `<div class="w-3"></div>${Components.createButton({ text: c.confirmText, action: 'modalConfirm', colorClass: c.confirmColorClass, widthClass: DesignConfig.buttons.auto, disabled: c.disableConfirm })}`;
    }
    ModalManager.setCallback(c.onConfirm);
    document.getElementById('modal-title').textContent = c.title;
    document.getElementById('modal-message').innerHTML = c.message;
    m.classList.add('active');
  };
  const hideModal = () => {
    document.getElementById('custom-modal').classList.remove('active');
    ModalManager.clearCallback();

    // モーダル非表示時にスクロール位置を復元
    if (window.pageTransitionManager) {
      window.pageTransitionManager.onModalClose();
    }
  };
  const showInfo = (msg, t = '情報', cb = null) =>
    showModal({
      title: t,
      message: msg,
      confirmText: 'OK',
      confirmColorClass: DesignConfig.colors.primary,
      onConfirm: cb,
    });
  const showConfirm = c => showModal({ ...c, showCancel: true });

  // =================================================================
  // --- Computed Data Management ---
  // -----------------------------------------------------------------
  // stateManager.getState().computedの計算・更新処理を管理します。
  // =================================================================

  /**
   * 注意: updateComputedData()関数はStateManagerシステムに統合されました
   * 計算済みデータは状態変更時に自動的に更新されます
   *
   * 下位互換性のためのラッパー関数
   * @deprecated 新しいコードではstateManager.dispatch()を使用してください
   */
  function updateComputedData() {
    if (window.stateManager) {
      window.stateManager.updateComputedData();
    } else {
      console.warn('updateComputedData: StateManagerが初期化されていません');
    }
  }

  // =================================================================
  // --- Legacy Utilities (Backward Compatibility) ---
  // -----------------------------------------------------------------
  // 既存コードとの互換性のための関数群です。
  // =================================================================

  /**
   * 指定された教室の、今日以降の空きスロットをフィルタリングします。
   * @param {Array} slots - 全スロットの配列（未使用、互換性のため残存）
   * @param {string} classroom - 教室名
   * @returns {Array} フィルタリングされたスロット配列
   * @deprecated StateManagerのcomputed dataを直接参照してください
   */
  const filterFutureSlots = (slots, classroom) => {
    // StateManagerの計算済みデータから取得
    if (window.stateManager) {
      const computed = window.stateManager.state.computed;
      return computed.slotsByClassroom[classroom] || [];
    }
    // フォールバック（StateManager未初期化時）
    updateComputedData();
    return stateManager.getState().computed.slotsByClassroom[classroom] || [];
  };

  /**
   * スロットを月別にグループ化します。
   * @param {Array} slots - スロットの配列（未使用、互換性のため残存）
   * @returns {Object} 月をキーとしたスロットのオブジェクト
   * @deprecated StateManagerのcomputed dataを直接参照してください
   */
  const groupSlotsByMonth = slots => {
    // StateManagerの計算済みデータから取得
    if (window.stateManager) {
      const computed = window.stateManager.state.computed;
      return computed.slotsByMonth;
    }
    // フォールバック（StateManager未初期化時）
    updateComputedData();
    return stateManager.getState().computed.slotsByMonth;
  };

  // =================================================================
  // --- Accounting Cache Utilities ---
  // -----------------------------------------------------------------
  // FE-14: 会計入力内容をlocalStorageに一時保存する機能
  // =================================================================

  /**
   * 会計入力のキャッシュデータをlocalStorageに保存する
   * @param {string} reservationId - 予約ID
   * @param {object} accountingData - 保存する会計データオブジェクト
   */
  function saveAccountingCache(reservationId, accountingData) {
    if (!reservationId || !accountingData) return;
    const cacheKey = `accounting_cache_${reservationId}`;
    try {
      localStorage.setItem(cacheKey, JSON.stringify(accountingData));
    } catch (e) {
      console.error('Failed to save accounting cache:', e);
    }
  }

  /**
   * localStorageから会計入力のキャッシュデータを読み込む
   * @param {string} reservationId - 予約ID
   * @returns {object|null} - 読み込んだ会計データオブジェクト、またはnull
   */
  function loadAccountingCache(reservationId) {
    if (!reservationId) return null;

    const cacheKey = `accounting_cache_${reservationId}`;
    try {
      const cachedData = localStorage.getItem(cacheKey);
      if (!cachedData) return null;

      const parsed = JSON.parse(cachedData);

      // 現在のマスターデータと照合して、存在しない項目を除外
      return filterValidCacheData(parsed);
    } catch (e) {
      console.error('Failed to load accounting cache:', e);
      return null;
    }
  }

  /**
   * キャッシュデータの基本的な検証
   * @param {object} cachedData - キャッシュされたデータ
   * @returns {object} - 検証済みデータ
   */
  function filterValidCacheData(cachedData) {
    if (!cachedData || typeof cachedData !== 'object') return {};
    return cachedData;
  }

  /**
   * localStorageから会計入力のキャッシュデータを削除する
   * @param {string} reservationId - 予約ID
   */
  function clearAccountingCache(reservationId) {
    if (!reservationId) return;
    const cacheKey = `accounting_cache_${reservationId}`;
    try {
      localStorage.removeItem(cacheKey);
    } catch (e) {
      console.error('Failed to clear accounting cache:', e);
    }
  }

  // =================================================================
  // --- Accounting Utilities ---
  // -----------------------------------------------------------------

  /**
   * 料金マスタから、指定された教室と項目名に合致する授業料ルールを取得します。
   * @param {Array} master - 料金マスタ (stateManager.getState().accountingMaster)
   * @param {string} classroom - 教室名
   * @param {string} itemName - 項目名
   * @returns {object|undefined} - 該当する授業料ルールオブジェクト
   */
  const getTuitionItemRule = (master, classroom, itemName) => {
    if (!master || !classroom || !itemName) return undefined;
    return master.find(
      item =>
        item['種別'] === C.itemTypes.TUITION &&
        item[HEADERS.ACCOUNTING.ITEM_NAME] === itemName &&
        item[HEADERS.ACCOUNTING.TARGET_CLASSROOM] &&
        item[HEADERS.ACCOUNTING.TARGET_CLASSROOM].includes(classroom),
    );
  };

  // =================================================================
  // --- Schedule Master Helper Functions ---
  // -----------------------------------------------------------------
  // 日程マスタデータから情報を取得するヘルパー関数群
  // フェーズ1: tuitionItemRule依存からの脱却のための新機能
  // =================================================================

  /**
   * 日程マスタから教室形式を取得します
   * @param {object} scheduleData - 日程マスタのデータオブジェクト
   * @returns {string} 教室形式 ('時間制' | '回数制' | '材料制')
   */
  function getClassroomTypeFromSchedule(scheduleData) {
    if (!scheduleData) return null;
    return scheduleData.classroomType || scheduleData['教室形式'] || null;
  }

  /**
   * 日程マスタから教室の開講時間情報を取得します
   * @param {object} scheduleData - 日程マスタのデータオブジェクト
   * @returns {object} 時間情報 {firstStart, firstEnd, secondStart?, secondEnd?}
   */
  function getClassroomTimesFromSchedule(scheduleData) {
    if (!scheduleData) return null;

    return {
      firstStart: scheduleData.firstStart || scheduleData['1部開始'] || null,
      firstEnd: scheduleData.firstEnd || scheduleData['1部終了'] || null,
      secondStart: scheduleData.secondStart || scheduleData['2部開始'] || null,
      secondEnd: scheduleData.secondEnd || scheduleData['2部終了'] || null,
    };
  }

  /**
   * 教室形式が時間制かどうかを判定します
   * @param {object} scheduleData - 日程マスタのデータオブジェクト
   * @returns {boolean} 時間制の場合true
   */
  function isTimeBasedClassroom(scheduleData) {
    const classroomType = getClassroomTypeFromSchedule(scheduleData);
    // 時間制の教室形式をすべてチェック（時間制・2部制、時間制・全日）
    return classroomType && classroomType.includes('時間制');
  }

  /**
   * 教室が2部制かどうかを判定します（2部開始・2部終了の両方が設定されている場合）
   * @param {object} scheduleData - 日程マスタのデータオブジェクト
   * @returns {boolean} 2部制の場合true
   */
  function isTwoSessionClassroom(scheduleData) {
    const times = getClassroomTimesFromSchedule(scheduleData);
    if (!times) return false;
    return !!(times.secondStart && times.secondEnd);
  }

  /**
   * バックエンドから特定の日程マスタ情報を取得
   * @param {string} date - 日付 (YYYY-MM-DD)
   * @param {string} classroom - 教室名
   * @returns {Promise<object|null>} 日程マスタ情報またはnull
   */
  function getScheduleInfoFromCache(date, classroom) {
    return new Promise(resolve => {
      google.script.run
        .withSuccessHandler(response => {
          if (response.success && response.data) {
            console.log(
              '✅ getScheduleInfoFromCache: 日程マスタ情報取得成功',
              response.data.scheduleInfo,
            );
            resolve(response.data.scheduleInfo);
          } else {
            console.warn(
              '⚠️ getScheduleInfoFromCache: 日程マスタ情報が見つかりません',
              { date, classroom },
            );
            resolve(null);
          }
        })
        .withFailureHandler(error => {
          console.error('❌ getScheduleInfoFromCache: API呼び出しエラー', error);
          resolve(null);
        })
        .getScheduleInfo({ date, classroom });
    });
  }

  /**
   * 予約データから対応する日程マスタ情報を取得
   * @param {object} reservation - 予約データ (date, classroom を含む)
   * @returns {object|null} 日程マスタ情報またはnull (slots経由の場合)
   */
  function getScheduleDataFromSlots(reservation) {
    if (!reservation || !reservation.date || !reservation.classroom) {
      console.warn('⚠️ getScheduleDataFromSlots: 予約データが不正', reservation);
      return null;
    }

    const state = stateManager.getState();
    const slots = state.slots;

    if (!slots || !Array.isArray(slots)) {
      console.warn('⚠️ getScheduleDataFromSlots: slotsが存在しません', slots);
      return null;
    }

    console.log('🔍 getScheduleDataFromSlots: 検索対象', {
      date: reservation.date,
      classroom: reservation.classroom,
      slotsLength: slots.length,
    });

    // 予約の日付と教室に対応するスロットを検索
    const matchingSlot = slots.find(
      slot =>
        slot.date === reservation.date &&
        slot.classroom === reservation.classroom,
    );

    if (!matchingSlot) {
      console.warn(
        '⚠️ getScheduleDataFromSlots: 一致するスロットが見つかりません',
        {
          date: reservation.date,
          classroom: reservation.classroom,
          availableSlots: slots.map(s => ({
            date: s.date,
            classroom: s.classroom,
          })),
        },
      );
      return null;
    }

    console.log('✅ getScheduleDataFromSlots: スロット発見', matchingSlot);

    // 日程マスタ形式の情報を返す
    return {
      classroomType: matchingSlot.classroomType || matchingSlot['教室形式'],
      firstStart: matchingSlot.firstStart || matchingSlot['1部開始'],
      firstEnd: matchingSlot.firstEnd || matchingSlot['1部終了'],
      secondStart: matchingSlot.secondStart || matchingSlot['2部開始'],
      secondEnd: matchingSlot.secondEnd || matchingSlot['2部終了'],
    };
  }

  // =================================================================
  // --- Accounting Calculation Logic ---
  // -----------------------------------------------------------------
  // 会計画面での複雑な料金計算ロジックです。
  // 授業料、材料費、割引などを動的に計算し、合計金額を算出します。
  // =================================================================

  /**
   * 会計計算を実行し、stateManager.getState().computed.accountingCalculationに結果を保存します。
   * @returns {object} 計算結果詳細
   */
  function calculateAccountingDetails() {
    if (!stateManager.getState().accountingMaster) return null;

    const details = calculateAccountingDetailsFromForm();

    // stateManager.getState().computedに結果を保存
    stateManager.getState().computed.accountingCalculation = details;

    // UI要素の更新
    updateAccountingUI(details);

    return details;
  }

  /**
   * フォームの内容から会計計算を実行します（appState独立）。
   * @returns {object} 計算結果詳細
   */
  function calculateAccountingDetailsFromForm() {
    let tuitionSubtotal = 0;
    let salesSubtotal = 0;
    const details = {
      tuition: { items: [] },
      sales: { items: [] },
      grandTotal: 0,
      paymentMethod: '',
      items: [],
    };
    const form = document.getElementById('accounting-form');
    if (!form) return details;

    const r = stateManager.getState().accountingReservation;
    const tuitionItemRule = getTuitionItemRule(
      stateManager.getState().accountingMaster,
      r.classroom,
      C.items.MAIN_LECTURE,
    );
    const isTimeBased =
      tuitionItemRule && tuitionItemRule['単位'] === C.units.THIRTY_MIN;

    // 時間制授業料計算
    if (isTimeBased) {
      const timeBasedResult = calculateTimeBasedTuition(tuitionItemRule);
      if (timeBasedResult) {
        tuitionSubtotal += timeBasedResult.price;
        details.tuition.items.push(timeBasedResult.item);
      }
    }

    // チェックボックス項目計算
    const checkboxResult = calculateCheckboxItems();
    tuitionSubtotal += checkboxResult.tuitionSubtotal;
    salesSubtotal += checkboxResult.salesSubtotal;
    details.tuition.items.push(...checkboxResult.tuitionItems);
    details.sales.items.push(...checkboxResult.salesItems);
    details.items.push(...checkboxResult.allItems);

    // 割引計算
    const discountResult = calculateDiscount();
    if (discountResult) {
      tuitionSubtotal -= discountResult.amount;
      details.tuition.items.push(discountResult.item);
    }

    // 材料費計算
    const materialResult = calculateMaterials();
    salesSubtotal += materialResult.subtotal;
    details.sales.items.push(...materialResult.items);

    // その他販売品計算
    const otherSalesResult = calculateOtherSales();
    salesSubtotal += otherSalesResult.subtotal;
    details.sales.items.push(...otherSalesResult.items);

    // 合計計算
    details.tuition.subtotal = tuitionSubtotal;
    details.sales.subtotal = salesSubtotal;
    details.grandTotal = tuitionSubtotal + salesSubtotal;
    details.paymentMethod =
      form.querySelector('input[name="payment-method"]:checked')?.value || '現金';

    return details;
  }

  /**
   * 時間制授業料を計算する
   * 開始時間・終了時間・休憩時間から実際の受講時間を算出し、30分単位で料金を計算
   * @param {Object} tuitionItemRule - 会計マスタの授業料ルールオブジェクト（単価を含む）
   * @returns {Object|null} 計算結果 { price: number, item: {name: string, price: number} } または null
   */
  function calculateTimeBasedTuition(tuitionItemRule) {
    // 時刻データを適切に取得（ヘルパー関数使用）
    const accountingReservation = stateManager.getState().accountingReservation;
    const startTime = getTimeValue(
      'start-time',
      accountingReservation,
      'startTime',
    );
    const endTime = getTimeValue('end-time', accountingReservation, 'endTime');
    const breakMinutes = parseInt(
      document.getElementById('break-time')?.value || 0,
      10,
    );

    if (startTime && endTime && startTime < endTime) {
      const start = new Date(`1900-01-01T${startTime}:00`);
      const end = new Date(`1900-01-01T${endTime}:00`);
      let diffMinutes = (end - start) / 60000 - breakMinutes;

      if (diffMinutes > 0) {
        const billableUnits = Math.ceil(diffMinutes / 30);
        const price =
          billableUnits * Number(tuitionItemRule[HEADERS.ACCOUNTING.UNIT_PRICE]);
        return {
          price: price,
          item: { name: `授業料 (${startTime} - ${endTime})`, price: price },
          billableUnits: billableUnits,
        };
      }
    }
    return null;
  }

  /**
   * 会計画面で時刻変更時に計算を更新する
   */
  function updateAccountingCalculation() {
    // 会計合計を再計算
    const accountingResult = calculateAccountingDetailsFromForm();

    // 合計金額表示を更新
    const totalElement = document.getElementById('total-amount');
    if (totalElement && accountingResult) {
      totalElement.textContent = `¥${accountingResult.grandTotal.toLocaleString()}`;
    }

    // 詳細表示も更新（存在する場合）
    const detailsElement = document.getElementById('calculation-details');
    if (detailsElement && accountingResult) {
      // 詳細計算結果を表示
      detailsElement.innerHTML = `
        <div class="text-sm text-gray-600 space-y-1">
          <div>授業料小計: ¥${accountingResult.tuition.subtotal.toLocaleString()}</div>
          <div>物販小計: ¥${accountingResult.materials.subtotal.toLocaleString()}</div>
          <div class="font-semibold border-t pt-1">合計: ¥${accountingResult.grandTotal.toLocaleString()}</div>
        </div>`;
    }
  }

  /**
   * 会計画面の時刻選択にイベントリスナーを追加する
   */
  function setupAccountingEventListeners() {
    // 時刻選択要素にchangeイベントを追加
    ['start-time', 'end-time', 'break-time'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', updateAccountingCalculation);
      }
    });

    // チェックボックス項目にもchangeイベントを追加
    document
      .querySelectorAll('input[type="checkbox"].accounting-item')
      .forEach(checkbox => {
        checkbox.addEventListener('change', updateAccountingCalculation);
      });

    // 割引チェックボックスにもchangeイベントを追加
    const discountCheckbox = document.getElementById('discount-checkbox');
    if (discountCheckbox) {
      discountCheckbox.addEventListener('change', updateAccountingCalculation);
    }
  }

  /**
   * フォーム内のチェックボックス項目の料金を計算する
   * 授業料項目と物販項目を区別して集計し、両方の小計を算出
   * @returns {Object} 計算結果 { tuitionSubtotal: number, salesSubtotal: number, tuitionItems: Array, salesItems: Array, allItems: Array }
   */
  function calculateCheckboxItems() {
    let tuitionSubtotal = 0;
    let salesSubtotal = 0;
    const tuitionItems = [];
    const salesItems = [];
    const allItems = [];

    const form = document.getElementById('accounting-form');
    form
      .querySelectorAll('input[type="checkbox"].accounting-item')
      .forEach(cb => {
        if (cb.checked || cb.disabled) {
          const itemName = cb.dataset.itemName;
          const itemType = cb.dataset.itemType;
          const masterItem = stateManager
            .getState()
            .accountingMaster.find(
              m =>
                m[HEADERS.ACCOUNTING.ITEM_NAME] === itemName &&
                m['種別'] === itemType,
            );
          if (!masterItem) return;

          const price = Number(masterItem[HEADERS.ACCOUNTING.UNIT_PRICE]);
          const itemDetail = { name: itemName, price: price };
          allItems.push(itemDetail);

          if (itemType === C.itemTypes.TUITION) {
            tuitionSubtotal += price;
            tuitionItems.push(itemDetail);
          } else {
            salesSubtotal += price;
            salesItems.push(itemDetail);
          }
        }
      });

    return {
      tuitionSubtotal,
      salesSubtotal,
      tuitionItems,
      salesItems,
      allItems,
    };
  }

  /**
   * 初回者同時割引を計算する
   * 固定の¥500引きを適用
   * @returns {Object|null} 割引計算結果 { discountAmount: number, discountItem: {name: string, price: number} } または null
   */
  function calculateDiscount() {
    const discountCheckbox = document.getElementById('discount-checkbox');
    if (discountCheckbox && discountCheckbox.checked) {
      const discountAmount = 500; // 固定の¥500引き
      return {
        amount: discountAmount,
        item: {
          name: `${C.items.DISCOUNT}`,
          price: -discountAmount,
        },
      };
    }
    return null;
  }

  /**
   * 材料費を計算する
   * 立体材料の場合はサイズ(長さ×幅×高さ)から体積を計算し、単価を掛けて算出
   * その他の材料は固定単価で計算
   * @returns {Object} 計算結果 { subtotal: number, items: Array<{name: string, price: number}> }
   */
  function calculateMaterials() {
    let subtotal = 0;
    const items = [];

    const materialContainer = document.getElementById('materials-container');
    if (materialContainer) {
      const materialRows = materialContainer.querySelectorAll(
        'div[data-material-row-index]',
      );
      materialRows.forEach((row, index) => {
        const type = document.getElementById(`material-type-${index}`)?.value;
        const masterItem = stateManager
          .getState()
          .accountingMaster.find(m => m[HEADERS.ACCOUNTING.ITEM_NAME] === type);
        const priceEl = document.getElementById(`material-price-${index}`);

        if (!masterItem) {
          if (priceEl) priceEl.textContent = '0円';
          return;
        }

        const unitPrice = Number(masterItem[HEADERS.ACCOUNTING.UNIT_PRICE]);
        let finalName = type;
        let price = 0;

        if (masterItem['単位'] === stateManager.getState().constants.units.CM3) {
          const l = document.getElementById(`material-l-${index}`)?.value || 0;
          const w = document.getElementById(`material-w-${index}`)?.value || 0;
          const h = document.getElementById(`material-h-${index}`)?.value || 0;
          if (l > 0 && w > 0 && h > 0) {
            const volumeCm = (l / 10) * (w / 10) * (h / 10);
            let calculatedPrice = Math.round((volumeCm * unitPrice) / 100) * 100;
            price = Math.max(100, calculatedPrice);
            finalName = `${type} (${l}x${w}x${h}mm)`;
          }
        } else {
          if (type) price = unitPrice;
        }

        if (priceEl) priceEl.textContent = `${price.toLocaleString()}円`;
        if (price > 0) {
          const itemDetail = { name: finalName, price: price };
          subtotal += price;
          items.push(itemDetail);
        }
      });
    }

    return { subtotal, items };
  }

  /**
   * その他販売品を計算する
   * 動的に追加された販売品項目の名前と価格から小計を算出
   * @returns {Object} 計算結果 { subtotal: number, items: Array<{name: string, price: number}> }
   */
  function calculateOtherSales() {
    let subtotal = 0;
    const items = [];

    const otherSalesContainer = document.getElementById('other-sales-container');
    if (otherSalesContainer) {
      const otherSalesRows = otherSalesContainer.querySelectorAll(
        'div[data-other-sales-row]',
      );
      otherSalesRows.forEach((row, index) => {
        const name = document
          .getElementById(`other-sales-name-${index}`)
          ?.value.trim();
        const priceInput = document.getElementById(`other-sales-price-${index}`);
        let priceValue = priceInput.value
          .replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xfee0))
          .replace(/[^0-9.-]/g, '');
        priceInput.value = priceValue;
        const price = Number(priceValue || 0);

        if (name && price !== 0) {
          const itemDetail = { name: name, price: price };
          subtotal += price;
          items.push(itemDetail);
        }
      });
    }

    return { subtotal, items };
  }

  /**
   * 会計フォームのUI要素を計算結果に基づいて更新する
   * 授業料・物販の小計、合計金額、内訳表示などを動的に更新
   * @param {Object} details - calculateAccountingDetailsFromForm()の計算結果
   */
  function updateAccountingUI(details) {
    const tuitionBreakdownEl = document.getElementById('tuition-breakdown');
    const calculatedHoursEl = document.getElementById('calculated-hours');
    const tuitionSubtotalEl = document.getElementById('tuition-subtotal');
    const salesSubtotalEl = document.getElementById('sales-subtotal');
    const grandTotalEl = document.getElementById('grand-total-amount');

    // 時間制授業料の表示更新
    if (tuitionBreakdownEl) {
      const tuitionBreakdownHtml = details.tuition.items
        .map(
          item =>
            `<div class="flex justify-between${item.price < 0 ? ' text-red-600' : ''}"><span>${item.name}</span><span>${item.price.toLocaleString()}円</span></div>`,
        )
        .join('');
      tuitionBreakdownEl.innerHTML = tuitionBreakdownHtml;
    }

    // 受講時間表示の更新
    if (
      calculatedHoursEl &&
      stateManager.getState().computed.accountingCalculation
    ) {
      const timeBasedItems = details.tuition.items.filter(item =>
        item.name.includes('授業料 ('),
      );
      if (timeBasedItems.length > 0) {
        const r = stateManager.getState().accountingReservation;
        const tuitionItemRule = getTuitionItemRule(
          stateManager.getState().accountingMaster,
          r.classroom,
          C.items.MAIN_LECTURE,
        );
        if (tuitionItemRule) {
          const billableUnits = Math.ceil(
            timeBasedItems[0].price /
              Number(tuitionItemRule[HEADERS.ACCOUNTING.UNIT_PRICE]),
          );
          calculatedHoursEl.textContent = `受講時間: ${billableUnits * 0.5}時間 × ${2.0 * tuitionItemRule[HEADERS.ACCOUNTING.UNIT_PRICE]}円`;
        }
      } else {
        calculatedHoursEl.textContent = '';
      }
    }

    // 小計・合計の表示更新
    if (tuitionSubtotalEl)
      tuitionSubtotalEl.textContent = `小計: ${details.tuition.subtotal.toLocaleString()}円`;
    if (salesSubtotalEl)
      salesSubtotalEl.textContent = `小計: ${details.sales.subtotal.toLocaleString()}円`;
    if (grandTotalEl)
      grandTotalEl.textContent = `合計: ${details.grandTotal.toLocaleString()}円`;
  }

  // =================================================================
  // --- Event Listener Management ---
  // -----------------------------------------------------------------
  // イベントリスナーの登録・解除を追跡管理するヘルパー関数群
  // メモリリーク防止のため、ビュー切り替え時に古いリスナーを確実に解除する
  // =================================================================

  let activeListeners = [];

  /**
   * 登録されたイベントリスナーを全て解除する
   */
  function teardownAllListeners() {
    activeListeners.forEach(({ element, type, listener, options }) => {
      if (element) {
        element.removeEventListener(type, listener, options);
      }
    });
    activeListeners = [];
  }

  /**
   * イベントリスナーを登録し、解除できるように追跡するヘルパー関数
   * @param {Element} element - 対象要素
   * @param {string} type - イベントタイプ
   * @param {Function} listener - リスナー関数
   * @param {object} [options] - addEventListenerのオプション
   */
  function addTrackedListener(element, type, listener, options) {
    if (!element) {
      console.warn(
        `Attempted to add listener to a null element for event: ${type}`,
      );
      return;
    }
    element.addEventListener(type, listener, options);
    activeListeners.push({ element, type, listener, options });
  }

  /**
   * StateManagerの初期化後に追加する関数
   * ビュー変更時のイベントリスナー管理を設定
   */
  function setupViewListener() {
    if (!window.stateManager) {
      console.error('StateManager not initialized. Cannot set up view listener.');
      return;
    }

    window.stateManager.subscribe((newState, oldState) => {
      // ビューが変更された場合のみ処理
      if (newState.view !== oldState.view) {
        // 古いビューのリスナーを全て解除
        teardownAllListeners();

        // 新しいビューに応じたリスナーを登録
        // requestAnimationFrameでDOMの描画を待つ
        requestAnimationFrame(() => {
          if (newState.view === 'accounting') {
            // 会計画面が表示された際の初期化処理
            // イベントリスナーは14_WebApp_Handlers.htmlのイベント委譲で処理されます。
            // ここでは、DOM描画後に初回計算を実行します。
            if (typeof calculateAccountingDetails === 'function') {
              calculateAccountingDetails();
            }
          }
          // 他のビューでリスナーが必要な場合はここに追加
          // else if (newState.view === 'someOtherView') {
          //   setupSomeOtherViewListeners();
          // }
        });
      }
    });
  }


  // =================================================================
  // 12_WebApp_StateManager.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 12_WebApp_StateManager.js
   * 【バージョン】: 2.1 (JavaScript分離開発版)
   * 【役割】: シンプルで確実な状態管理システム
   * - 無限ループの完全回避
   * - JavaScript分離開発環境対応
   * - 完全なTypeScript型チェック対応
   * =================================================================
   */

  /**
   * シンプルな状態管理システム
   */
  class SimpleStateManager {
    constructor() {
      this.state = {
        // --- User & Session Data ---
        /** @type {{studentId: string, realName: string, displayName: string, phone: string} | null} */
        currentUser: null,
        /** @type {string} */
        loginPhone: '',
        /** @type {boolean} */
        isFirstTimeBooking: false,
        /** @type {Object} */
        registrationData: {},
        /** @type {string | null} */
        registrationPhone: null,

        // --- Core Application Data ---
        /** @type {Array<Object>} */
        slots: [],
        /** @type {Array<Object>} */
        myBookings: [],
        /** @type {Array<Object>} */
        history: [],
        /** @type {Array<Object>} */
        accountingMaster: [],
        /** @type {Array<string>} */
        classrooms: [],
        /** @type {Object | null} */
        constants: null,

        // --- UI State ---
        /** @type {string} */
        view: 'login',
        /** @type {string | null} */
        selectedClassroom: null,
        /** @type {Object | null} */
        selectedSlot: null,
        /** @type {Object | null} */
        editingReservationDetails: null,
        /** @type {Object | null} - 会計画面の基本予約情報 (ID, 教室, 日付など) */
        accountingReservation: null,
        /** @type {Object} - 予約固有の詳細情報 (開始時刻, レンタル, 割引など) */
        accountingReservationDetails: {},
        /** @type {Object | null} - 講座固有情報 (教室形式, 開講時間など) */
        accountingScheduleInfo: null,
        /** @type {string} */ completionMessage: '',
        /** @type {number} */ recordsToShow: 10,
        /** @type {Array<Object>} */
        searchedUsers: [],
        /** @type {boolean} */
        searchAttempted: false,

        // --- Navigation History ---
        /** @type {Array<{view: string, context: Object}>} */
        navigationHistory: [],

        // --- System State ---
        /** @type {boolean} */
        isDataFresh: false,
        /** @type {boolean} */
        _dataUpdateInProgress: false,
        /** @type {string | null} */
        _slotsVersion: null,

        // --- Computed Data ---
        computed: {
          /** @type {Array<Object>} */ sortedBookings: [],
          /** @type {Array<Object>} */ sortedHistory: [],
          /** @type {Array<Object>} */ displayHistory: [],
        },
      };

      this.isUpdating = false; // 無限ループ防止フラグ
      this.subscribers = []; // 状態変更の購読者リスト

      // フォールバック統一定数を即座に設定（エラー回避）
      this.initializeFallbackConstants();
    }

    /**
     * アクションをディスパッチして状態を更新し、UIを自動再描画
     * @param {Object} action - アクションオブジェクト { type: 'ACTION_NAME', payload: { ... } }
     */
    dispatch(action) {
      if (this.isUpdating) {
        console.warn('状態更新中のため処理をスキップ');
        return;
      }

      if (!window.isProduction) {
        console.log(
          '🎯 Action dispatched:',
          action.type,
          action.payload ? Object.keys(action.payload) : 'no payload',
        );
      }

      // 現在のビューを記録（ページ遷移判定用）
      const previousView = this.state.view;

      // アクションに基づいて状態更新
      let newState = {};
      switch (action.type) {
        case 'SET_STATE':
          newState = action.payload || {};
          break;
        case 'UPDATE_STATE':
          newState = action.payload || {};
          break;
        case 'CHANGE_VIEW':
          newState = { view: action.payload.view };
          break;
        case 'NAVIGATE':
          newState = this._handleNavigate(action.payload);
          break;
        default:
          console.warn('未知のアクションタイプ:', action.type);
          return;
      }

      // 内部の状態更新メソッドを呼び出し
      this._updateState(newState);

      // ページ遷移が発生した場合のスクロール管理
      if (
        newState.view &&
        newState.view !== previousView &&
        window.pageTransitionManager
      ) {
        window.pageTransitionManager.onPageTransition(newState.view);
      }

      // 最終的な状態更新（画面遷移を伴う）でのみローディング非表示を実行
      const isViewChange = newState.view && newState.view !== previousView;
      const hasSubstantialData =
        newState.slots || newState.myBookings || newState.currentUser;
      const isFinalUpdate =
        action.type === 'SET_STATE' && (isViewChange || hasSubstantialData);

      if (isFinalUpdate) {
        this._shouldHideLoadingAfterRender = true;
      }

      // UI を自動で再描画
      this._scheduleRender();
    }

    /**
     * 状態を更新（内部メソッド）
     * @param {Object} newState - 新しい状態
     */
    _updateState(newState) {
      if (this.isUpdating) {
        console.warn('状態更新中のため処理をスキップ');
        return;
      }

      this.isUpdating = true;

      try {
        // 変更前の状態を保存（subscriber用）
        const oldState = { ...this.state };

        // 状態を直接更新
        Object.assign(this.state, newState);

        // 統一定数が設定された場合、グローバル短縮参照を初期化
        // window.Cがフォールバックで空オブジェクト{}で初期化されるため、
        // !window.Cでは正しく判定できない。
        // オブジェクトが空かどうかもチェックする。
        if (
          newState.constants &&
          (!window.C || Object.keys(window.C).length === 0)
        ) {
          this.initializeGlobalConstants();
        }

        // 基本的な計算済みデータ更新
        this.updateComputed();

        // subscriberに変更を通知
        this._notifySubscribers(this.state, oldState);

        if (!window.isProduction) {
          if (typeof DEBUG_ENABLED !== 'undefined' && DEBUG_ENABLED)
            console.log('✅ 状態更新完了:', Object.keys(newState));
        }
      } catch (error) {
        console.error('❌ 状態更新エラー:', error);
      } finally {
        this.isUpdating = false;
      }
    }

    /**
     * グローバル統一定数の短縮参照を初期化
     */
    initializeGlobalConstants() {
      if (!this.state.constants) return;

      const constants = this.state.constants;

      // 必要な配列データを状態に設定
      if (constants.classrooms && !this.state.classrooms.length) {
        this.state.classrooms = Object.values(constants.classrooms);
        if (!window.isProduction) {
          console.log('📋 教室一覧を状態に設定:', this.state.classrooms);
        }
      }

      // UI設定の初期化
      if (!this.state.recordsToShow && constants.ui?.HISTORY_INITIAL_RECORDS) {
        this.state.recordsToShow = constants.ui.HISTORY_INITIAL_RECORDS;
        if (!window.isProduction) {
          console.log('📋 履歴表示件数を初期化:', this.state.recordsToShow);
        }
      }

      // グローバル短縮参照を設定
      window.C = constants;
      window.STATUS = constants.status || {};
      window.UI = constants.ui || {};
      window.MESSAGES = constants.messages || {};
      window.BANK = constants.bankInfo || {};
      window.PAYMENT = constants.paymentDisplay || {};
      window.HEADERS = constants.headers || {}; // 統合ヘッダー定数をフロントエンドで利用可能に

      if (!window.isProduction) {
        console.log('📋 統一定数グローバル参照を初期化:', Object.keys(constants));
      }
    }

    /**
     * 計算済みデータの基本更新
     */
    updateComputed() {
      if (!this.state.myBookings || !this.state.history) return;

      // isFirstTimeBooking の計算を追加
      this.state.isFirstTimeBooking =
        (!this.state.myBookings || this.state.myBookings.length === 0) &&
        (!this.state.history || this.state.history.length === 0);

      // 基本的なソート処理
      this.state.computed.sortedBookings = [...this.state.myBookings].sort(
        (a, b) => new Date(b.date) - new Date(a.date),
      );

      // すべての完了ステータス予約を含む統合履歴を作成
      const completedBookings = this.state.myBookings.filter(
        booking => booking.status === window.STATUS?.COMPLETED || booking.status === '完了'
      );
      const allHistoryRecords = [...this.state.history, ...completedBookings];

      this.state.computed.sortedHistory = allHistoryRecords.sort(
        (a, b) => new Date(b.date) - new Date(a.date),
      );

      // 表示する履歴の数を recordsToShow に基づいて動的に計算
      this.state.computed.displayHistory =
        this.state.computed.sortedHistory.slice(0, this.state.recordsToShow);
    }

    /**
     * フォールバック用のグローバル定数を初期化する
     * サーバーから本物の定数が読み込まれるまでの間のエラーを回避する
     */
    initializeFallbackConstants() {
      if (window.C && Object.keys(window.C).length > 0) return; // 既に設定済みなら何もしない

      window.C = {};
      window.STATUS = {
        CANCELED: '取消',
        WAITLISTED: '待機',
        CONFIRMED: '確定',
        COMPLETED: '完了',
      };
      window.UI = {
        HISTORY_INITIAL_RECORDS: 10,
        HISTORY_LOAD_MORE_RECORDS: 10,
        LOADING_MESSAGE_INTERVAL: 2000,
        MODAL_FADE_DURATION: 300,
      };
      window.MESSAGES = {
        CANCEL: 'キャンセル',
        SAVE: '保存する',
        EDIT: '編集',
        SUCCESS: '成功',
        ERROR: 'エラー',
      };
      window.BANK = {};
      window.PAYMENT = { CASH: '現金' };
      console.log('📋 フォールバック定数を初期化しました');
    }

    /**
     * requestAnimationFrameを使ったレンダリングスケジューリング
     */
    _scheduleRender() {
      if (this._renderScheduled) {
        return; // 既にスケジュール済み
      }

      this._renderScheduled = true;
      requestAnimationFrame(() => {
        this._renderScheduled = false;
        if (typeof window.render === 'function') {
          console.log('🎨 Auto-rendering UI...');
          window.render();
          // 特定のaction.typeでのみローディングを非表示（最終的な状態更新のみ）
          if (this._shouldHideLoadingAfterRender) {
            if (typeof hideLoading === 'function') hideLoading();
            this._shouldHideLoadingAfterRender = false;
          }
        } else {
          console.warn('render関数が見つかりません');
        }
      });
    }

    /**
     * 現在の状態を取得
     */
    getState() {
      return this.state;
    }

    /**
     * 状態変更を購読する
     * @param {Function} callback - 状態変更時に呼び出される関数 (newState, oldState) => void
     * @returns {Function} unsubscribe関数
     */
    subscribe(callback) {
      this.subscribers.push(callback);

      // unsubscribe関数を返す
      return () => {
        const index = this.subscribers.indexOf(callback);
        if (index > -1) {
          this.subscribers.splice(index, 1);
        }
      };
    }

    /**
     * subscriberに状態変更を通知する
     * @param {Object} newState - 新しい状態
     * @param {Object} oldState - 古い状態
     */
    _notifySubscribers(newState, oldState) {
      this.subscribers.forEach(callback => {
        try {
          callback(newState, oldState);
        } catch (error) {
          console.error('subscriber callback error:', error);
        }
      });
    }

    /**
     * ナビゲーションアクションを処理し、履歴を管理する
     * @param {Object} payload - { to: string, context?: Object, saveHistory?: boolean }
     * @returns {Object} 新しい状態
     */
    _handleNavigate(payload) {
      const { to, context = {}, saveHistory = true } = payload;
      const currentView = this.state.view;

      // 現在のビューを履歴に保存（戻る履歴として）
      if (saveHistory && currentView !== to) {
        const currentContext = this._extractCurrentContext();
        const historyEntry = { view: currentView, context: currentContext };

        // 同じビューの連続エントリを避ける
        const lastEntry =
          this.state.navigationHistory[this.state.navigationHistory.length - 1];
        if (!lastEntry || lastEntry.view !== currentView) {
          const newHistory = [...this.state.navigationHistory, historyEntry];
          // 履歴を最大10件に制限
          if (newHistory.length > 10) {
            newHistory.shift();
          }
          return {
            view: to,
            ...context,
            navigationHistory: newHistory,
          };
        }
      }

      return {
        view: to,
        ...context,
      };
    }

    /**
     * 現在のビューのコンテキストを抽出する
     * @returns {Object} コンテキストオブジェクト
     */
    _extractCurrentContext() {
      const context = {};

      // ビューに応じて重要な状態を保存
      switch (this.state.view) {
        case 'booking':
          if (this.state.selectedClassroom) {
            context.selectedClassroom = this.state.selectedClassroom;
          }
          break;
        case 'newReservation':
        case 'editReservation':
          if (this.state.selectedSlot) {
            context.selectedSlot = this.state.selectedSlot;
            context.selectedClassroom = this.state.selectedClassroom;
          }
          if (this.state.editingReservationDetails) {
            context.editingReservationDetails =
              this.state.editingReservationDetails;
          }
          break;
        case 'accounting':
          if (this.state.accountingReservation) {
            context.accountingReservation = this.state.accountingReservation;
          }
          break;
        default:
          break;
      }

      return context;
    }

    /**
     * 前のビューに戻る
     * @returns {Object} 新しい状態、または戻れない場合はnull
     */
    goBack() {
      const history = this.state.navigationHistory;
      if (history.length === 0) {
        console.log('ナビゲーション履歴が空です - ホームに戻ります');
        return { view: 'dashboard' };
      }

      const previousEntry = history[history.length - 1];
      const newHistory = history.slice(0, -1); // 最後のエントリを削除

      return {
        view: previousEntry.view,
        ...previousEntry.context,
        navigationHistory: newHistory,
      };
    }

    /**
     * データの整合性チェック（デバッグ用）
     * @param {Object} dataObj - チェック対象のオブジェクト
     * @param {string} dataType - データタイプ ('reservations', 'schedule' など)
     */
    validateDataStructure(dataObj, dataType = 'reservations') {
      if (!window.HEADERS || !dataObj) return true;

      const expectedHeaders =
        dataType === 'schedule'
          ? window.HEADERS.SCHEDULE
          : window.HEADERS.RESERVATIONS;

      if (!expectedHeaders) return true;

      // 重要なプロパティの存在チェック
      const requiredProperties = ['date', 'classroom'];
      const missingProperties = requiredProperties.filter(prop => !dataObj[prop]);

      if (missingProperties.length > 0) {
        console.warn(`データ整合性チェック: 必須プロパティが不足`, {
          dataType,
          missing: missingProperties,
          data: dataObj,
        });
        return false;
      }

      return true;
    }
  }

  // グローバルインスタンスを作成
  window.stateManager = new SimpleStateManager();


  // =================================================================
  // 13_WebApp_Components.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 13_WebApp_Components.js
   * 【バージョン】: 2.0 (シンプル化設計版)
   * 【役割】: WebAppのUIコンポーネント生成関数を集約します。
   * - 再利用可能なUIコンポーネントの定義
   * - シンプル化されたパラメータ設計
   * - 3層構造: Atomic → Molecular → Organisms
   * 【構成】: 14ファイル構成のうちの13番目（新規追加）
   * 【設計原則】:
   * - 単一責任原則: 1コンポーネント = 1つの明確な責任
   * - 最小パラメータ: 本質的なデータのみ受け取る
   * - 関心の分離: UIコンポーネントとビジネスデータを分離
   * - 組み合わせ可能: 小さな部品の組み合わせで複雑な画面を構築
   */

  // =================================================================
  // --- HTML Escape Utility ---
  // -----------------------------------------------------------------
  // HTMLエスケープ機能（12_WebApp_Core.htmlから移動）
  // =================================================================

  /**
   * HTML文字列をエスケープします。
   * @param {string} str エスケープする文字列
   * @returns {string} エスケープされた文字列
   */
  window.escapeHTML = str => {
    if (typeof str !== 'string') {
      return str;
    }
    return str.replace(/[&<>"']/g, function (match) {
      return {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
      }[match];
    });
  };

  // =================================================================
  // --- Level 1: 基本要素（Atomic Components） ---
  // -----------------------------------------------------------------
  // 最小単位のUIコンポーネント。単一責任でパラメータ最小化。
  // =================================================================

  const Components = {
    /**
     * 進化版ボタンコンポーネント
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.action - data-action属性の値
     * @param {string} config.text - ボタンテキスト
     * @param {string} [config.style='primary'] - ボタンスタイル ('primary'|'secondary'|'danger')
     * @param {string} [config.size='normal'] - ボタンサイズ ('normal'|'full'|'small')
     * @param {boolean} [config.disabled=false] - 無効状態
     * @param {string} [config.customClass=''] - 追加のCSSクラス
     * @param {Object} [config.dataAttributes={}] - 追加のdata-*属性 (例: { classroomName: '東京' })
     * @returns {string} HTML文字列
     */
    button: ({
      action,
      text,
      style = 'primary',
      size = 'normal',
      disabled = false,
      customClass = '',
      dataAttributes = {},
    }) => {
      // スタイルマッピング
      const styleClasses = {
        primary: DesignConfig.colors.primary,
        secondary: DesignConfig.colors.secondary,
        danger: DesignConfig.colors.danger,
      };

      const sizeClasses = {
        normal: '',
        full: DesignConfig.buttons.full,
        small: 'text-sm px-3 py-1.5',
      };

      // データ属性をHTML文字列に変換
      const dataAttrs = Object.entries(dataAttributes)
        .map(
          ([key, value]) =>
            `data-${key.replace(/([A-Z])/g, '-$1').toLowerCase()}="${escapeHTML(value)}"`,
        )
        .join(' ');

      // スタイルが'none'の場合は基本クラスを最小限にする
      const baseClass = style === 'none' ? '' : DesignConfig.buttons.base;
      const styleClass = style === 'none' ? '' : styleClasses[style] || '';

      return `<button type="button"
          data-action="${escapeHTML(action || '')}"
          class="${[baseClass, styleClass, sizeClasses[size] || '', customClass || ''].filter(Boolean).join(' ')}"
          ${dataAttrs}
          ${disabled ? 'disabled' : ''}
        >${escapeHTML(text)}</button>`;
    },

    /**
     * シンプル化された入力フィールドコンポーネント
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.id - input要素のid
     * @param {string} config.label - ラベルテキスト
     * @param {string} [config.type='text'] - input要素のtype
     * @param {string} [config.value=''] - 初期値
     * @param {string} [config.placeholder=''] - プレースホルダー
     * @param {boolean} [config.required=false] - 必須項目かどうか
     * @returns {string} HTML文字列
     */
    input: ({
      id,
      label,
      type = 'text',
      value = '',
      placeholder = '',
      required = false,
    }) => {
      return `<div class="mb-4">
          <label
            for="${id}"
            class="${DesignConfig.text.labelBlock}"
          >${escapeHTML(label)}</label>
          <input
            type="${type}"
            id="${id}"
            value="${escapeHTML(value)}"
            class="${DesignConfig.inputs.base}"
            placeholder="${escapeHTML(placeholder)}"
            ${required ? 'required' : ''}
            autocomplete="off"
          >
        </div>`;
    },

    /**
     * シンプル化されたセレクトボックスコンポーネント
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.id - select要素のid
     * @param {string} config.label - ラベルテキスト
     * @param {string} config.options - option要素のHTML文字列
     * @returns {string} HTML文字列
     */
    select: ({ id, label, options }) => {
      return `<div class="mb-4">
          <label for="${id}" class="${DesignConfig.text.labelBlock}">${escapeHTML(label)}</label>
          <select
            id="${id}"
            class="${DesignConfig.inputs.base}"
          >${options}</select>
        </div>`;
    },

    /**
     * テキストエリアコンポーネント
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.id - textarea要素のid
     * @param {string} config.label - ラベルテキスト
     * @param {string} [config.value=''] - 初期値
     * @param {string} [config.placeholder=''] - プレースホルダー
     * @returns {string} HTML文字列
     */
    textarea: ({ id, label, value = '', placeholder = '' }) => {
      return `<div class="mb-4">
          <label for="${id}" class="${DesignConfig.text.labelBlock}">${escapeHTML(label)}</label>
          <textarea
            id="${id}"
            class="${DesignConfig.inputs.textarea}"
            placeholder="${escapeHTML(placeholder)}"
          >${escapeHTML(value)}</textarea>
        </div>`;
    },

    /**
     * チェックボックスコンポーネント
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.id - input要素のid
     * @param {string} config.label - ラベルテキスト
     * @param {boolean} [config.checked=false] - チェック状態
     * @returns {string} HTML文字列
     */
    checkbox: ({ id, label, checked = false }) => {
      return `<label class="flex items-center space-x-2 ${DesignConfig.colors.text}">
          <input
            type="checkbox"
            id="${id}"
            ${checked ? 'checked' : ''}
            class="accent-action-primary-bg"
          >
          <span>${escapeHTML(label)}</span>
        </label>`;
    },

    // =================================================================
    // --- 新設計コンポーネント ---
    // -----------------------------------------------------------------

    /**
     * 情報表示カード
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.title - カードタイトル
     * @param {Array<string>} config.items - 表示項目の配列
     * @returns {string} HTML文字列
     */
    infoCard: ({ title, items }) => {
      const itemsHtml = items
        .map(item => `<p class="text-brand-text">${escapeHTML(item)}</p>`)
        .join('');
      return `<div class="bg-ui-surface border border-ui-border p-3 rounded-lg">
          <h3 class="font-bold text-brand-text mb-2">${escapeHTML(title)}</h3>
          ${itemsHtml}
        </div>`;
    },

    /**
     * ステータスバッジ
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.type - バッジタイプ ('success'|'warning'|'error'|'info')
     * @param {string} config.text - バッジテキスト
     * @returns {string} HTML文字列
     */
    statusBadge: ({ type, text }) => {
      const typeClasses = {
        success: 'bg-state-success-bg text-state-success-text',
        warning: 'bg-ui-warning-bg text-ui-warning-text',
        error: 'bg-ui-error-bg text-ui-error-text',
        info: 'bg-action-secondary-bg text-action-secondary-text',
      };

      return `<span class="inline-block px-2 py-1 text-sm font-bold rounded ${typeClasses[type] || typeClasses.info}">${escapeHTML(text)}</span>`;
    },

    /**
     * 料金表示コンポーネント
     * @param {Object} config - 設定オブジェクト
     * @param {number|string} config.amount - 金額
     * @param {string} [config.label=''] - ラベル
     * @returns {string} HTML文字列
     */
    priceDisplay: ({ amount, label = '' }) => {
      const formattedAmount =
        typeof amount === 'number' ? amount.toLocaleString() : amount;
      return `<div class="text-right">
          ${label ? `<span class="text-brand-subtle text-sm">${escapeHTML(label)}: </span>` : ''}
          <span class="font-bold text-brand-text">${formattedAmount}円</span>
        </div>`;
    },

    // =================================================================
    // --- 会計系専用コンポーネント ---
    // -----------------------------------------------------------------

    /**
     * ナビゲーションヘッダー
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.title - ページタイトル
     * @param {string} config.backAction - 戻るボタンのaction
     * @returns {string} HTML文字列
     */
    navigationHeader: ({ title, backAction }) => {
      return `<div class="flex justify-between items-center">
          <h1 class="text-2xl font-bold text-brand-text">${escapeHTML(title)}</h1>
          <button data-action="${backAction}" class="text-sm bg-action-secondary-bg text-action-secondary-text px-3 py-1.5 rounded-md active:bg-action-secondary-hover mobile-button">戻る</button>
        </div>`;
    },

    /**
     * 会計項目行（チェックボックス付き）
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.name - 項目名
     * @param {string} config.itemType - アイテムタイプ
     * @param {number} config.price - 単価
     * @param {boolean} [config.checked=false] - チェック状態
     * @param {boolean} [config.disabled=false] - 無効化状態
     * @returns {string} HTML文字列
     */
    accountingRow: ({
      name,
      itemType,
      price,
      checked = false,
      disabled = false,
    }) => {
      return `<div class="flex items-center justify-between mb-2">
          <label class="flex items-center space-x-2 text-brand-text">
            <input type="checkbox"
                   name="${name}"
                   data-item-type="${itemType}"
                   data-item-name="${name}"
                   class="accounting-item h-5 w-5 rounded border-ui-border text-brand-text focus:ring-brand-text accent-action-primary-bg"
                   ${checked ? 'checked' : ''}
                   ${disabled ? 'disabled' : ''}>
            <span>${escapeHTML(name)}</span>
          </label>
          <span class="text-brand-subtle">${price.toLocaleString()}円</span>
        </div>`;
    },

    /**
     * 材料入力行
     * @param {Object} config - 設定オブジェクト
     * @param {number} config.index - 行のインデックス
     * @param {Object} [config.values] - 初期値
     * @returns {string} HTML文字列
     */
    materialRow: ({ index, values = {} }) => {
      const { type = '', l = '', w = '', h = '' } = values;

      // マスターデータから材料オプションを動的に生成
      let materialOptions = '';
      try {
        const master = window.stateManager?.getState?.()?.accountingMaster;
        if (master && Array.isArray(master)) {
          materialOptions = master
            .filter(m => m['種別'] === C.itemTypes.MATERIAL)
            .map(
              m =>
                `<option value="${escapeHTML(m[HEADERS.ACCOUNTING.ITEM_NAME])}" ${type === m[HEADERS.ACCOUNTING.ITEM_NAME] ? 'selected' : ''}>${escapeHTML(m[HEADERS.ACCOUNTING.ITEM_NAME])}</option>`,
            )
            .join('');
        }
      } catch (e) {
        // フォールバック: 静的オプション
        const staticOptions = ['桂', 'シナ', '檜', '楠', '桜', '朴', 'その他'];
        materialOptions = staticOptions
          .map(
            option =>
              `<option value="${option}" ${type === option ? 'selected' : ''}>${option}</option>`,
          )
          .join('');
      }

      return `<div data-material-row-index="${index}">
          <div class="grid grid-cols-1 gap-y-2">
            <select id="material-type-${index}" name="materialType${index}" class="${DesignConfig.inputs.base} accounting-item">
              <option value="">-- 樹種を選択 --</option>
              ${materialOptions}
            </select>
          </div>
          <div class="grid grid-cols-4 gap-2 mt-2 items-center">
            <input type="number" id="material-l-${index}" name="materialL${index}" value="${l || ''}" placeholder="縦(mm)" step="5" class="${DesignConfig.inputs.base} accounting-item custom-placeholder">
            <input type="number" id="material-w-${index}" name="materialW${index}" value="${w || ''}" placeholder="横(mm)" step="5" class="${DesignConfig.inputs.base} accounting-item custom-placeholder">
            <input type="number" id="material-h-${index}" name="materialH${index}" value="${h || ''}" placeholder="厚(mm)" step="5" class="${DesignConfig.inputs.base} accounting-item custom-placeholder">
            <div id="material-price-${index}" class="text-right text-base text-brand-subtle">0円</div>
          </div>
        </div>`;
    },

    /**
     * その他販売項目行
     * @param {Object} config - 設定オブジェクト
     * @param {number} config.index - 行のインデックス
     * @param {Object} [config.values] - 初期値
     * @returns {string} HTML文字列
     */
    otherSalesRow: ({ index, values = {} }) => {
      const { name = '', price = '' } = values;
      return `<div data-other-sales-row="${index}" class="mt-2 pt-2 border-t border-ui-border grid grid-cols-3 gap-2 items-center">
          <input type="text" id="other-sales-name-${index}" name="otherSalesName${index}" value="${escapeHTML(name)}" placeholder="商品名" class="col-span-2 ${DesignConfig.inputs.base} accounting-item">
          <input type="text" inputmode="decimal" id="other-sales-price-${index}" name="otherSalesPrice${index}" value="${price}" placeholder="金額" class="${DesignConfig.inputs.base} accounting-item">
        </div>`;
    },

    /**
     * 会計済み表示
     * @param {Object} config - 設定オブジェクト
     * @param {Object} config.details - 会計詳細データ
     * @param {Object} config.reservation - 予約データ
     * @returns {string} HTML文字列
     */
    accountingCompleted: ({ details, reservation }) => {
      const tuitionItemsHtml = details.tuition.items
        .map(
          i =>
            `<div class="flex justify-between"><span>${escapeHTML(i.name)}</span><span>${i.price.toLocaleString()}円</span></div>`,
        )
        .join('');
      const salesItemsHtml = details.sales.items
        .map(
          i =>
            `<div class="flex justify-between"><span>${escapeHTML(i.name)}</span><span>${i.price.toLocaleString()}円</span></div>`,
        )
        .join('');
      const v = reservation.venue ? `（${reservation.venue}）` : '';

      return `<div class="text-center py-4">
          <h1 class="text-2xl font-bold text-brand-text mt-4 mb-2">会計済み</h1>
          <p class="text-brand-subtle mb-6"><b>${formatDate(reservation.date)}</b><br>${reservation.classroom}${v}</p>
        </div>
        <div class="p-4 bg-ui-surface border border-ui-border rounded-lg text-left space-y-4">
          <div><h3 class="font-bold text-brand-text border-b border-ui-border mb-1 pb-1">授業料</h3><div class="space-y-1 text-brand-text">${tuitionItemsHtml || 'なし'}</div></div>
          <div><h3 class="font-bold text-brand-text border-b border-ui-border mb-1 pb-1">販売</h3><div class="space-y-1 text-brand-text">${salesItemsHtml || 'なし'}</div></div>
          <div class="text-right font-bold text-xl pt-2 border-t border-ui-border text-brand-text">合計: ${details.grandTotal.toLocaleString()}円</div>
          <div class="text-right text-base pt-2 text-brand-subtle">支払方法: ${escapeHTML(details.paymentMethod)}</div>
        </div>
        <div class="mt-4 flex flex-col space-y-3">
          ${Components.button({ action: 'editAccountingRecord', text: '会計内容を修正する', style: 'secondary', size: 'full' })}
        </div>`;
    },

    /**
     * 会計フォーム全体
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.type - フォームタイプ ('timeBased' | 'fixed')
     * @param {Object} config.master - 会計マスターデータ
     * @param {Object} config.reservation - 予約データ
     * @param {Object} config.reservationDetails - 予約固有情報
     * @param {Object} config.scheduleInfo - 講座固有情報
     * @returns {string} HTML文字列
     */
    accountingForm: ({
      type,
      master,
      reservation,
      reservationDetails,
      scheduleInfo,
    }) => {
      // 授業料セクション
      let tuitionHtml;
      if (type === 'timeBased') {
        const tuitionItemRule = getTuitionItemRule(
          master,
          reservation.classroom,
          C.items.MAIN_LECTURE,
        );
        tuitionHtml = Components.timeBasedTuition({
          tuitionItemRule,
          reservationDetails,
          scheduleInfo,
        });
      } else {
        tuitionHtml = Components.fixedTuitionSection({
          master,
          reservation,
          reservationDetails,
        });
      }

      // 販売セクション
      const salesHtml = Components.salesSection({ master, reservationDetails });

      return `<div class="text-center py-4">
          <p class="text-brand-subtle mb-6"><b>${formatDate(reservation.date)}</b><br>${reservation.classroom}${reservation.venue ? `（${reservation.venue}）` : ''}</p>
        </div>
        <form id="accounting-form" class="space-y-6">
          ${tuitionHtml}
          ${salesHtml}
          <div class="text-right text-2xl font-bold py-4 border-t-2 border-ui-border flex flex-col items-end">
            <span id="grand-total-amount" class="text-brand-text">合計: 0円</span>
          </div>
          <div class="mt-4 text-center">
            <p class="text-base text-state-danger-text font-bold mb-2">金額を、先生に確認してもらってください</p>
            <div class="space-y-3">
              ${Components.button({ action: 'showAccountingConfirmation', text: '先生の確認が完了しました', style: 'primary', size: 'full' })}
            </div>
          </div>
        </form>`;
    },

    /**
     * 時間制授業料セクション
     * @param {Object} config - 設定オブジェクト
     * @param {Object} config.tuitionItemRule - 授業料ルール
     * @param {Object} config.reservationDetails - 予約固有情報
     * @param {Object} config.scheduleInfo - 講座固有情報
     * @returns {string} HTML文字列
     */
    timeBasedTuition: ({ tuitionItemRule, reservationDetails, scheduleInfo }) => {
      return getTimeBasedTuitionHtml(
        tuitionItemRule,
        reservationDetails,
        scheduleInfo,
      );
    },

    /**
     * 固定制授業料セクション
     * @param {Object} config - 設定オブジェクト
     * @param {Object} config.master - 会計マスター
     * @param {Object} config.reservation - 予約データ
     * @param {Object} config.reservationDetails - 予約固有情報
     * @returns {string} HTML文字列
     */
    fixedTuitionSection: ({ master, reservation, reservationDetails }) => {
      // isFirstTimeBooking をstateManagerから取得
      const isFirstTimeBooking = stateManager.getState().isFirstTimeBooking;

      // 使用する授業料項目を決定（初回授業料 or 基本授業料）
      const targetItemName = isFirstTimeBooking
        ? C.items.FIRST_LECTURE
        : C.items.MAIN_LECTURE;
      const tuitionItem = master.find(
        item =>
          item[HEADERS.ACCOUNTING.TYPE] === C.itemTypes.TUITION &&
          item[HEADERS.ACCOUNTING.ITEM_NAME] === targetItemName &&
          (item[HEADERS.ACCOUNTING.TARGET_CLASSROOM] === '共通' ||
            item[HEADERS.ACCOUNTING.TARGET_CLASSROOM]?.includes(
              reservation.classroom,
            )),
      );

      // 授業料の表示内容を生成
      let tuitionDisplayHtml = '';
      if (tuitionItem) {
        const price = tuitionItem[HEADERS.ACCOUNTING.UNIT_PRICE] || 0;
        const bgColor = isFirstTimeBooking
          ? 'bg-green-50 border-green-400'
          : 'bg-blue-50 border-blue-400';
        const textColor = isFirstTimeBooking ? 'text-green-800' : 'text-blue-800';
        const label = isFirstTimeBooking
          ? C.items.FIRST_LECTURE
          : C.items.MAIN_LECTURE;

        tuitionDisplayHtml = `<div class="mb-4 p-3 ${bgColor} rounded border-l-4">
            <div class="text-base ${textColor}">
              <span class="font-semibold">${label}:</span> ¥${price.toLocaleString()}
            </div>
          </div>`;
      }

      const tuitionItems = master.filter(
        item =>
          item[HEADERS.ACCOUNTING.TYPE] === C.itemTypes.TUITION &&
          (item[HEADERS.ACCOUNTING.TARGET_CLASSROOM] === '共通' ||
            item[HEADERS.ACCOUNTING.TARGET_CLASSROOM]?.includes(
              reservation.classroom,
            )),
      );

      const tuitionRowsHtml = tuitionItems
        .map(item => {
          const itemName = item[HEADERS.ACCOUNTING.ITEM_NAME];

          // メイン授業料項目の処理（初回参加時は差し替え）
          if (itemName === targetItemName) {
            return Components.accountingRow({
              name: itemName,
              itemType: C.itemTypes.TUITION,
              price: item[HEADERS.ACCOUNTING.UNIT_PRICE],
              checked: true,
              disabled: true,
            });
          }

          // 使わない授業料項目をスキップ
          if (
            (itemName === C.items.FIRST_LECTURE && !isFirstTimeBooking) ||
            (itemName === C.items.MAIN_LECTURE && isFirstTimeBooking)
          ) {
            return '';
          }

          // その他の項目（彫刻刀レンタルなど）
          const isChecked = !!(
            reservationDetails[itemName] ||
            (itemName === C.items.CHISEL_RENTAL &&
              reservationDetails.chiselRental)
          );

          return Components.accountingRow({
            name: itemName,
            itemType: C.itemTypes.TUITION,
            price: item[HEADERS.ACCOUNTING.UNIT_PRICE],
            checked: isChecked,
            disabled: false,
          });
        })
        .filter(html => html !== '')
        .join('');

      return `<div class="p-4 bg-ui-surface border border-ui-border rounded-lg">
          <h3 class="text-xl font-bold mb-3 text-brand-text">授業料</h3>
          ${tuitionDisplayHtml}
          <div class="space-y-3">${tuitionRowsHtml}</div>
          <div id="tuition-breakdown" class="mt-4 pt-4 border-t border-ui-border space-y-1 text-base text-brand-subtle"></div>
          <div class="text-right font-bold mt-2 text-brand-text" id="tuition-subtotal">小計: 0円</div>
        </div>`;
    },

    // =================================================================
    // --- Level 3: 画面セクション（Organisms） ---
    // -----------------------------------------------------------------
    // 複合的なUIセクション（ホーム、予約一覧等）
    // =================================================================

    /**
     * ホームセクション（予約または履歴）
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.title - セクションタイトル
     * @param {Array} config.items - 表示項目の配列（HTMLカード文字列の配列）
     * @param {boolean} [config.showNewButton=false] - 新規追加ボタンの表示制御
     * @param {string} [config.newAction] - 新規追加ボタンのaction
     * @param {boolean} [config.showMoreButton=false] - もっとみるボタンの表示制御
     * @param {string} [config.moreAction] - もっとみるボタンのaction
     * @returns {string} HTML文字列
     */
    dashboardSection: ({
      title,
      items,
      showNewButton = false,
      newAction,
      showMoreButton = false,
      moreAction,
    }) => {
      let newButtonHtml = '';
      if (showNewButton && newAction) {
        newButtonHtml = Components.newReservationCard({ action: newAction });
      }

      const itemsHtml = items.join('');

      let moreButtonHtml = '';
      if (showMoreButton && moreAction) {
        moreButtonHtml = `<div class="text-center mt-4">
            ${Components.button({ action: moreAction, text: 'もっとみる', style: 'secondary', size: 'small' })}
          </div>`;
      }

      return `
          <div class="mb-8 w-full">
            <div class="bg-ui-surface border border-ui-border p-3 rounded-lg space-y-3">
              <h2 class="text-xl font-medium text-brand-text text-center mb-2">${escapeHTML(title)}</h2>
              ${newButtonHtml}
              ${itemsHtml}
              ${moreButtonHtml}
            </div>
          </div>
        `;
    },

    /**
     * 新規予約カード（ホーム用）
     * @param {Object} config - 設定オブジェクト
     * @param {string} config.action - data-action属性の値
     * @returns {string} HTML文字列
     */
    newReservationCard: ({ action }) => {
      return `
          <div data-action="${action}" class="w-full p-4 rounded-lg border-2 border-dashed border-action-primary-border bg-action-primary-light cursor-pointer mobile-card touch-friendly">
            <div class="text-center">
              <span class="text-xl font-bold text-action-primary-bg">+ あたらしく よやく する</span>
            </div>
          </div>
        `;
    },

    /**
     * 統一カードレイアウト（予約・履歴共通）
     * @param {Object} config - 設定オブジェクト
     * @param {Object} config.item - 予約または履歴データ
     * @param {Array} config.buttons - ボタン配列（{action, text, style, details?}の形式）
     * @param {string} [config.type='booking'] - カードタイプ ('booking' | 'history')
     * @param {Date} [config.today] - 今日の日付（予約用）
     * @returns {string} HTML文字列
     */
    listCard: ({ item, buttons, type = 'booking', today }) => {
      // ボタンスタイルのマッピング（Viewsからの抽象的なstyleを具体的なCSSクラスに変換）
      const styleMapping = {
        paid: `${DesignConfig.colors.paid} text-base font-bold px-3 py-1.5 rounded`,
        accounting: `text-base ${DesignConfig.colors.accounting} font-bold px-3 py-1.5 rounded mobile-button`,
        edit: 'text-base bg-action-secondary-bg text-action-secondary-text font-medium px-3 py-1.5 rounded active:bg-action-secondary-hover focus:bg-action-secondary-hover mobile-button',
        record:
          'text-sm bg-action-paid-bg text-action-paid-text font-bold px-3 py-1.5 rounded',
        'edit-small':
          'text-sm bg-action-secondary-bg text-action-secondary-text font-bold px-3 py-1.5 rounded active:bg-action-secondary-hover focus:bg-action-secondary-hover mobile-button',
      };

      // ボタン配列を旧形式に変換
      const legacyButtons = buttons.map(btn => ({
        action: btn.action,
        text: btn.text,
        colorClass: styleMapping[btn.style] || styleMapping['edit'],
        details: btn.details, // 会計記録用
      }));

      return createReservationCard({
        type: type,
        item: item,
        today: today,
        buttons: legacyButtons,
      });
    },

    /**
     * 販売セクション
     * @param {Object} config - 設定オブジェクト
     * @param {Object} config.master - 会計マスター
     * @param {Object} config.reservationDetails - 予約固有情報
     * @returns {string} HTML文字列
     */
    salesSection: ({ master, reservationDetails }) => {
      const salesItems = master.filter(
        item => item['種別'] === C.itemTypes.SALES,
      );
      const salesItemsHtml = salesItems
        .map(item => {
          // truthy値でチェック状態を判定（より柔軟）
          const isChecked =
            !!reservationDetails[item[HEADERS.ACCOUNTING.ITEM_NAME]];

          return Components.accountingRow({
            name: item[HEADERS.ACCOUNTING.ITEM_NAME],
            itemType: C.itemTypes.SALES,
            price: item[HEADERS.ACCOUNTING.UNIT_PRICE],
            checked: isChecked,
          });
        })
        .join('');

      return `<div class="p-4 bg-ui-surface border border-ui-border rounded-lg">
          <h3 class="text-xl font-bold mb-3 text-left text-brand-text">販売</h3>
          <div class="mb-3 space-y-4">
            <label class="block text-brand-text text-base font-bold">材料代</label>
            <div id="materials-container">
              ${Components.materialRow({
                index: 0,
                values: {
                  type: reservationDetails.materialType0,
                  l: reservationDetails.materialL0,
                  w: reservationDetails.materialW0,
                  h: reservationDetails.materialH0,
                },
              })}
            </div>
          </div>
          ${Components.button({ action: 'addMaterialRow', text: '+ 材料を追加', style: 'secondary', size: 'full' })}
          <details class="mt-4">
            <summary class="font-bold text-brand-text flex items-center">
              <span class="arrow mr-2">▶</span> その他の販売品
            </summary>
            <div class="mt-2 space-y-2 pt-2 border-t border-ui-border">
              ${salesItemsHtml}
              <div id="other-sales-container" class="mt-2 pt-2 border-t border-ui-border">
                ${Components.otherSalesRow({
                  index: 0,
                  values: {
                    name: reservationDetails.otherSalesName0,
                    price: reservationDetails.otherSalesPrice0,
                  },
                })}
              </div>
            </div>
            ${Components.button({ action: 'addOtherSalesRow', text: '+ 自由入力欄を追加', style: 'secondary', size: 'full' })}
          </details>
          <div class="text-right font-bold mt-2 text-brand-text" id="sales-subtotal">小計: 0円</div>
        </div>`;
    },
  };

  // =================================================================
  // --- Specialized Components ---
  // -----------------------------------------------------------------
  // 特定用途に特化したコンポーネント
  // =================================================================

  /**
   * 右上固定配置の戻るボタンを生成します
   * @param {string} action - アクション名（デフォルト: 'smartGoBack'）
   * @param {string} text - ボタンテキスト（デフォルト: '戻る'）
   * @returns {string} HTML文字列
   */
  Components.createBackButton = (action = 'smartGoBack', text = '戻る') => {
    return `
        <div class="back-button-container fixed top-4 right-4 z-30">
          <button
            data-action="${escapeHTML(action)}"
            class="bg-action-secondary-bg text-action-secondary-text active:bg-action-secondary-hover font-bold py-2 px-4 rounded-md transition-all duration-150 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-offset-2 mobile-button touch-friendly shadow-lg"
          >
            ${escapeHTML(text)}
          </button>
        </div>`;
  };

  /**
   * 現在のビューに応じて適切な戻るボタンを生成します
   * @param {string} currentView - 現在のビュー名
   * @param {object} appState - アプリケーション状態
   * @returns {string} HTML文字列
   */
  Components.createSmartBackButton = (currentView, appState = null) => {
    const state =
      appState || (window.stateManager ? window.stateManager.getState() : {});
    let action = 'smartGoBack';
    let text = '戻る';

    // ビューに応じて適切なアクションとテキストを設定
    switch (currentView) {
      case 'login':
        // ログイン画面では戻るボタンを表示しない
        return '';

      case 'register':
        text = 'ログインへ';
        action = 'goBackToLogin';
        break;

      case 'registrationStep2':
        text = '前へ';
        action = 'backToStep1';
        break;

      case 'registrationStep3':
        text = '前へ';
        action = 'backToStep2';
        break;

      case 'registrationStep4':
        text = '前へ';
        action = 'backToStep3';
        break;

      case 'userSearch':
        text = 'ログインへ';
        action = 'goBackToLogin';
        break;

      case 'dashboard':
        // ダッシュボードでは戻るボタンを表示しない
        return '';

      case 'bookingSlots':
        text = 'ホーム';
        action = 'goBackToDashboard';
        break;

      case 'newReservation':
        text = '予約一覧';
        action = 'goBackToBooking';
        break;

      case 'editReservation':
        text = 'ホーム';
        action = 'goBackToDashboard';
        break;

      case 'accounting':
        text = 'ホーム';
        action = 'goBackToDashboard';
        break;

      case 'complete':
        text = 'ホーム';
        action = 'goBackToDashboard';
        break;

      default:
        // デフォルトはスマート戻る
        break;
    }

    return Components.createBackButton(action, text);
  };

  // =================================================================
  // --- レガシー互換性サポート ---
  // -----------------------------------------------------------------
  // 既存のコード互換性を維持するための旧式コンポーネント
  // 段階的移行期間中のみ使用
  // =================================================================

  /**
   * レガシー createButton (既存コード互換用)
   * 新規コードではComponents.button()を使用してください
   */
  Components.createButton = config => {
    // 旧形式を新形式にマッピング
    let style = 'primary';
    if (config.colorClass) {
      if (config.colorClass.includes('secondary')) style = 'secondary';
      if (config.colorClass.includes('danger')) style = 'danger';
    }

    let size = 'normal';
    if (config.widthClass && config.widthClass.includes('full')) size = 'full';

    // 旧式パラメータをHTMLに埋め込み（actionHandlers互換性のため）
    const dataAttributes = {};
    if (config.classroom) dataAttributes.classroom = config.classroom;
    if (config.date) dataAttributes.date = config.date;
    if (config.reservationId) dataAttributes.reservationId = config.reservationId;
    if (config.sheetName) dataAttributes.sheetName = config.sheetName;
    if (config.copyText) dataAttributes.copyText = config.copyText;
    if (config.details) dataAttributes.details = config.details;
    if (config.studentId) dataAttributes.studentId = config.studentId;
    if (config.realName) dataAttributes.realName = config.realName;
    if (config.nickname) dataAttributes.nickname = config.nickname;
    if (config.classroomName) dataAttributes.classroomName = config.classroomName;

    return Components.button({
      action: config.action,
      text: config.text,
      style: style,
      size: size,
      disabled: config.disabled,
      customClass: config.colorClass, // カスタムクラスを渡す
      dataAttributes: dataAttributes,
    });
  };

  /**
   * レガシー createInput (既存コード互換用)
   */
  Components.createInput = config => {
    // 複雑な旧形式をサポート
    let inputHtml = `<div class="${config.containerClass || ''} mb-4">
        <label
          for="${config.id}"
          class="${config.labelClass || DesignConfig.text.labelBlock} ${config.isSrOnly ? 'sr-only' : ''}"
        >${escapeHTML(config.label)}</label>
        ${config.caption ? `<p class="${DesignConfig.text.caption} mb-2">${escapeHTML(config.caption)}</p>` : ''}
        <input
          type="${config.type}"
          id="${config.id}"
          value="${escapeHTML(config.value || '')}"
          class="${DesignConfig.inputs.base} ${config.inputClass || ''}"
          placeholder="${escapeHTML(config.placeholder || '')}"
          ${config.required ? 'required' : ''}
          autocomplete="${config.autocomplete || 'off'}"
          ${config.step ? `step="${config.step}"` : ''}
          ${config.inputmode ? `inputmode="${config.inputmode}"` : ''}
          ${config.pattern ? `pattern="${config.pattern}"` : ''}
        >
      </div>`;

    return inputHtml;
  };

  /**
   * レガシー createTextArea (既存コード互換用)
   */
  Components.createTextArea = config => {
    return `<div class="${config.containerClass || ''} mb-4">
        <label for="${config.id}" class="${DesignConfig.text.labelBlock}">${escapeHTML(config.label)}</label>
        ${config.caption ? `<p class="${DesignConfig.text.caption} mb-2">${escapeHTML(config.caption)}</p>` : ''}
        <textarea
          id="${config.id}"
          class="${DesignConfig.inputs.textarea}"
          placeholder="${escapeHTML(config.placeholder || '')}"
        >${escapeHTML(config.value || '')}</textarea>
      </div>`;
  };

  /**
   * レガシー createSelect (既存コード互換用)
   */
  Components.createSelect = config => {
    return `<div class="${config.containerClass || ''}">
        ${config.label ? `<label for="${config.id}" class="${DesignConfig.text.labelBlock}">${escapeHTML(config.label)}</label>` : ''}
        ${config.caption ? `<p class="${DesignConfig.text.caption} mb-2">${escapeHTML(config.caption)}</p>` : ''}
        <select
          id="${config.id}"
          class="${DesignConfig.inputs.base} ${config.sizeClass || ''} accounting-item"
          ${config.name ? `name="${config.name}"` : ''}
        >${config.options}</select>
      </div>`;
  };

  /**
   * レガシー createCheckbox (既存コード互換用)
   */
  Components.createCheckbox = config => {
    return `<label class="flex items-center space-x-2 ${DesignConfig.colors.text}">
        <input
          type="checkbox"
          id="${config.id}"
          ${config.checked ? 'checked' : ''}
          class="accent-action-primary-bg"
        >
        <span>${escapeHTML(config.label)}</span>
      </label>`;
  };

  // =================================================================
  // --- モーダルコンポーネント ---
  // -----------------------------------------------------------------
  // 汎用モーダル機能
  // =================================================================

  /**
   * 汎用モーダルコンポーネントを生成します
   * @param {Object} config - 設定オブジェクト
   * @param {string} config.id - モーダルのID
   * @param {string} config.title - モーダルのタイトル
   * @param {string} config.content - モーダルの内容（HTML文字列）
   * @param {string} [config.maxWidth] - 最大幅のCSSクラス（デフォルト: 'max-w-sm'）
   * @param {boolean} [config.showCloseButton] - 右上の×ボタンを表示するか（デフォルト: true）
   * @returns {string} HTML文字列
   */
  Components.modal = config => {
    const maxWidth = config.maxWidth || 'max-w-sm';
    const showCloseButton = config.showCloseButton !== false;

    return `
        <div id="${escapeHTML(config.id)}" class="modal-fade fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden" onclick="Components.closeModalOnBackdrop(event, '${escapeHTML(config.id)}')">
          <div class="bg-white rounded-lg ${maxWidth} mx-4 max-h-[90vh] overflow-y-auto" onclick="Components.handleModalContentClick(event)" data-modal-content="true">
            <div class="flex justify-between items-center p-4 border-b border-ui-border">
              <h2 class="text-xl font-bold text-brand-text">${escapeHTML(config.title)}</h2>
              ${showCloseButton ? `<button onclick="Components.closeModal('${escapeHTML(config.id)}')" class="text-gray-500 hover:text-gray-700 text-2xl font-bold leading-none">&times;</button>` : ''}
            </div>
            <div class="p-4">
              ${config.content}
            </div>
          </div>
        </div>`;
  };

  /**
   * モーダルを表示します（フェードインアニメーション付き）
   * @param {string} modalId - モーダルのID
   */
  Components.showModal = modalId => {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.classList.remove('hidden');
      // フェードインアニメーションのための遅延
      requestAnimationFrame(() => {
        modal.classList.add('active');
      });
      // フォーカストラップの設定
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
      );
      if (focusableElements.length > 0) {
        focusableElements[0].focus();
      }
    }
  };

  /**
   * モーダルを非表示にします（フェードアウトアニメーション付き）
   * @param {string} modalId - モーダルのID
   */
  Components.closeModal = modalId => {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.classList.remove('active');
      // フェードアウトアニメーション完了後に完全に非表示にする
      setTimeout(() => {
        modal.classList.add('hidden');
      }, 300); // CSS transitionと同じ時間
    }
  };

  /**
   * 背景クリックでモーダルを閉じる処理
   * @param {Event} event - クリックイベント
   * @param {string} modalId - モーダルのID
   */
  Components.closeModalOnBackdrop = (event, modalId) => {
    if (event.target === event.currentTarget) {
      Components.closeModal(modalId);
    }
  };

  /**
   * モーダルコンテンツ内のクリック処理
   * ボタンなどのインタラクティブ要素はイベントを継続し、その他では伝播を停止
   * @param {Event} event - クリックイベント
   */
  Components.handleModalContentClick = event => {
    // ボタンまたはdata-action要素の場合はイベントを継続
    const actionElement = event.target.closest('button, [data-action]');
    if (actionElement) {
      // ボタンクリックの場合は伝播を継続（外側のハンドラーで処理）
      return;
    }
    // それ以外の場合は伝播を停止
    event.stopPropagation();
  };


  // =================================================================
  // 13_WebApp_Views.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 13_WebApp_Views.js
   * 【バージョン】: 1.9
   * 【役割】: WebAppの各画面（ビュー）のHTML構造を生成する関数群を集約します。
   * - 各関数は特定の画面（ログイン、予約一覧など）のUI構築を担当します。
   * - appStateの現在の状態に基づき、動的にHTMLを生成します。
   * 【構成】: 14ファイル構成でのビュー管理
   * 【v1.9での変更点】:
   * - FE-14: 会計画面の入力保持機能を実装。
   *   - getAccountingViewでキャッシュされたデータをフォームの初期値として設定するよう修正。
   * =================================================================
   */

  // =================================================================
  // --- View Helper Components ---
  // -----------------------------------------------------------------
  // 各ビューを構成するための、より小さな部品を生成するヘルパー関数群。
  // =================================================================

  /**
   * 当日かどうかを判定します。
   * @param {string} dateString - 日付文字列 (YYYY-MM-DD)
   * @returns {boolean} 当日の場合true
   */
  const _isToday = dateString => {
    const itemDate = new Date(dateString);
    const today = new Date();
    return itemDate.toDateString() === today.toDateString();
  };

  /**
   * 時刻選択用の<option>タグ群を生成します。
   * @param {number} startHour - 開始時刻（時）
   * @param {number} endHour - 終了時刻（時）
   * @param {number} step - 間隔（分）
   * @param {string | null} selectedValue - 事前に選択する時刻 (HH:mm)
   * @returns {string} HTMLの<option>タグ文字列
   */
  const getTimeOptionsHtml = (startHour, endHour, step, selectedValue) => {
    let options = [];
    for (let h = startHour; h <= endHour; h++) {
      for (let m = 0; m < 60; m += step) {
        const time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        options.push(
          `<option value="${time}" ${time === selectedValue ? 'selected' : ''}>${time}</option>`,
        );
      }
    }
    return options.join('');
  };

  /**
   * 割引選択用のUIを生成します。
   * @param {object} discountRule - 料金マスタから取得した割引ルールオブジェクト
   * @param {string} selectedValue - 選択済みの値
   * @returns {string} HTML文字列
   */
  const getDiscountHtml = (discountRule, selectedValue) => {
    if (!discountRule) return '';
    const isChecked =
      selectedValue && parseInt(selectedValue, 10) > 0 ? 'checked' : '';
    return `
          <div class="mt-4 pt-4 border-t border-ui-border-light">
              <label class="flex items-center space-x-2">
                  <input type="checkbox" id="discount-checkbox" name="discountApplied" ${isChecked} class="accounting-item accent-action-primary-bg">
                  <span class="${DesignConfig.text.labelBlock}">${discountRule[HEADERS.ACCOUNTING.ITEM_NAME]} (¥500引き)</span>
              </label>
          </div>`;
  };

  /**
   * 支払い情報（ことら送金、振込先）の表示UIを生成します。
   * @returns {string} HTML文字列
   */
  const getPaymentInfoHtml = () => {
    return `
          <div class="bg-ui-surface border border-ui-border p-3 rounded-md">
              <div class="flex justify-between items-center">
                  <div class="${DesignConfig.text.body}"><span class="font-bold">${PAYMENT.COTRA}:</span><span class="ml-2">${BANK.COTRA_PHONE}</span></div>
                  <button data-action="copyToClipboard" data-copy-text="${BANK.COTRA_PHONE}" class="flex-shrink-0 text-sm bg-action-secondary-bg active:bg-action-secondary-hover text-action-secondary-text font-bold px-2 py-1 rounded mobile-button">コピー</button>
              </div>
          </div>
          <div class="bg-ui-surface border border-ui-border p-3 rounded-md">
              <div class="text-brand-text"><span class="font-bold">振込先:</span><span class="ml-2">${BANK.NAME}</span></div>
              <div class="mt-1 flex justify-between items-center">
                  <div class="text-base text-brand-text">店番: ${BANK.BRANCH}</div>
                  <button data-action="copyToClipboard" data-copy-text="${BANK.BRANCH}" class="text-sm bg-action-secondary-bg active:bg-action-secondary-hover text-action-secondary-text font-bold px-2 py-1 rounded mobile-button">コピー</button>
              </div>
              <div class="mt-1 flex justify-between items-center">
                  <div class="text-base text-brand-text">普通: ${BANK.ACCOUNT}</div>
                  <button data-action="copyToClipboard" data-copy-text="${BANK.ACCOUNT}" class="text-sm bg-action-secondary-bg active:bg-action-secondary-hover text-action-secondary-text font-bold px-2 py-1 rounded mobile-button">コピー</button>
              </div>
          </div>`;
  };

  /**
   * 支払い方法の選択肢（ラジオボタン）UIを生成します。
   * @param {string} selectedValue - 選択済みの支払い方法
   * @returns {string} HTML文字列
   */
  const getPaymentOptionsHtml = selectedValue => {
    const cotraDetails = `
          <details class="mt-2 ml-6">
              <summary class="inline-block px-2 py-1 bg-ui-warning-light text-ui-warning-text text-sm font-semibold rounded-md active:bg-ui-warning-bg">
                  ことら送金とは？ <span class="arrow">▼</span>
              </summary>
              <p class="mt-2 p-2 bg-ui-warning-bg rounded-md text-sm text-left text-brand-subtle">
                  電話番号だけで銀行口座間で送金できるサービスです。手数料無料。対応の銀行アプリから利用できます。<br>
                  (例：ゆうちょ通帳アプリ、三井住友銀行アプリ、住信SBIネット銀行アプリなど)
                  <a href="https://www.cotra.ne.jp/member/" target="_blank" class="text-ui-link-text">対応アプリ一覧</a>
              </p>
          </details>`;
    const options = [
      {
        value: PAYMENT.CASH,
        text: PAYMENT.CASH,
        details: '',
      },
      {
        value: PAYMENT.COTRA,
        text: PAYMENT.COTRA,
        details: cotraDetails,
      },
      {
        value: PAYMENT.BANK_TRANSFER,
        text: PAYMENT.BANK_TRANSFER,
        details: '',
      },
    ];
    return (
      options
        .map(
          (opt, i) => `
          <div>
              <label class="flex items-center space-x-2 text-brand-text">
                  <input type="radio" name="payment-method" value="${opt.value}" class="accounting-item accent-action-primary-bg" ${opt.value === selectedValue ? 'checked' : ''}>
                  <span>${opt.text}</span>
              </label>
              ${opt.details}
          </div>`,
        )
        .join('') +
      `
          <div class="mt-4 space-y-2 text-base">${getPaymentInfoHtml()}</div>`
    );
  };

  /**
   * 予約・履歴カード用の新レイアウトカード構造を生成します。
   * 仕様: 上部に教室情報（左）+編集ボタン（右）、中央に制作メモエリア、下部に当日のみ会計ボタン
   * @param {object} config - カード設定オブジェクト
   * @returns {string} HTML文字列
   */
  const createReservationCard = config => {
    const {
      type, // 'booking' | 'history'
      item,
      today,
      buttons = [],
    } = config;

    const isBooking = type === 'booking';
    const venueText = item.venue || '';
    const isPastOrToday = isBooking
      ? new Date(item.date).getTime() <= today.getTime()
      : true;
    const isToday =
      today && new Date(item.date).toDateString() === today.toDateString();

    // 時刻表示の生成
    let timeText = '';
    if (item.startTime && item.endTime) {
      timeText = `${item.startTime} - ${item.endTime}`;
    }

    // 日時表示（教室情報部分）
    const dateTimeDisplay = `${formatDate(item.date || '')}${timeText ? ` ${timeText}` : ''}`;
    const venueDisplay = `${item.classroom || ''}${venueText ? ` ${venueText}` : ''}`;

    let cardColorClass = 'reservation-card bg-ui-surface border border-ui-border';
    if (isBooking) {
      const cardColor = item.isWaiting
        ? DesignConfig.cards.state.waitlist
        : DesignConfig.cards.state.booked;
      cardColorClass = `reservation-card ${cardColor.card}`;
    } else if (type === 'history') {
      cardColorClass = `record-card ${DesignConfig.cards.state.history.card}`;
    }

    // ステータスバッジ（初回、キャンセル待ち）
    let statusBadges = '';
    if (isBooking) {
      if (item.firstLecture) {
        statusBadges += `<span class="inline-block bg-action-attention-bg text-action-attention-text text-xs font-bold px-2 py-1 rounded-full ml-2">初回</span>`;
      }
      if (item.status === STATUS.WAITLISTED || item.isWaiting) {
        statusBadges += `<span class="inline-block bg-state-waitlist-bg text-state-waitlist-text text-xs font-bold px-2 py-1 rounded-full ml-2">⏳ キャンセル待ち</span>`;
      }
    }

    // 編集/確認ボタンの抽出（会計ボタン以外）
    const editButtons = buttons.filter(
      btn => !btn.text.includes('会計') && !btn.text.includes('記録'),
    );
    const editButtonsHtml = editButtons
      .map(btn =>
        Components.createButton({
          action: btn.action,
          classroom: btn.classroom || item.classroom,
          reservationId: btn.reservationId || item.reservationId,
          date: btn.date || item.date,
          sheetName: btn.sheetName || item.sheetName,
          details: btn.details,
          text: btn.text,
          colorClass: btn.colorClass,
        }),
      )
      .join('');

    // 会計ボタンの抽出（当日のみ表示）
    const accountingButtons = buttons.filter(
      btn => btn.text.includes('会計') || btn.text.includes('記録'),
    );
    const showAccountingButtons = isToday && accountingButtons.length > 0;
    const accountingButtonsHtml = showAccountingButtons
      ? accountingButtons
          .map(btn =>
            Components.createButton({
              action: btn.action,
              classroom: btn.classroom || item.classroom,
              reservationId: btn.reservationId || item.reservationId,
              date: btn.date || item.date,
              sheetName: btn.sheetName || item.sheetName,
              details: btn.details,
              text: btn.text,
              colorClass: btn.colorClass,
            }),
          )
          .join('')
      : '';

    // 制作メモの内容（元の表示方式に戻す）
    const memoContent =
      item.workInProgress != null && item.workInProgress !== ''
        ? item.workInProgress
        : `<span class="text-brand-muted">制作メモ</span>`;
    const memoDisplay = `<p class="text-base text-brand-text whitespace-pre-wrap break-words w-full leading-relaxed">${memoContent}</p>`;

    return `
        <div class="${cardColorClass || 'bg-ui-surface border border-ui-border'} p-3 rounded-lg flex flex-col space-y-3">
          <!-- 教室情報 -->
          <div class="flex-shrink-0">
            <div>
              <span class="text-brand-text font-bold text-base sm:text-xl">${formatDate(item.date || '')} </span>
              <span class="text-brand-text text-base time-display">${timeText || ''}</span>
            </div>
            <p class="text-brand-text font-bold text-base break-words">${item.classroom || ''} ${venueText || ''}</p>
            ${statusBadges || ''}
          </div>

          <!-- 制作メモ -->
          <div class="bg-ui-surface p-3 rounded-md w-full border border-ui-border">
            <div class="w-full min-h-[3rem] flex items-start">
              ${memoDisplay}
            </div>
          </div>

          <!-- ボタン配置（元の配置に戻す：編集ボタン+当日のみ会計ボタン） -->
          ${editButtonsHtml || accountingButtonsHtml ? `<div class="flex flex-wrap justify-center sm:justify-end items-center gap-2 flex-shrink-0 mt-3">${editButtonsHtml}${showAccountingButtons ? accountingButtonsHtml : ''}</div>` : ''}
        </div>
      `;
  };

  /**
   * 参加記録編集用のモーダルウィンドウの中身を生成します。
   * @param {object} item - 編集対象の履歴オブジェクト
   * @returns {string} HTML文字列
   */
  const buildMemoEditModal = item => {
    return `
          <p class="text-base ${DesignConfig.colors.textSubtle} mb-4">${formatDate(item.date)}  ${item.classroom}</p>
          <textarea id="memo-edit-textarea" class="${DesignConfig.inputs.textarea} h-32" placeholder="制作メモを入力…">${item.workInProgress || ''}</textarea>
      `;
  };

  /**
   * 時間制教室の授業料計算UIを生成します。
   * @param {object} rule - 料金マスタから取得した教室ルール
   * @param {object} reservationDetails - 予約固有情報（開始時刻、レンタル等）
   * @param {object} scheduleInfo - 講座固有情報（教室形式、開講時間等）
   * @returns {string} HTML文字列
   */
  const getTimeBasedTuitionHtml = (rule, reservationDetails, scheduleInfo) => {
    // 講座固有情報から時間設定を取得
    let classStart, classEnd;

    if (scheduleInfo && scheduleInfo.firstStart && scheduleInfo.firstEnd) {
      // 日程マスタから時間を取得
      const startParts = scheduleInfo.firstStart.split(':');
      const endParts = scheduleInfo.firstEnd.split(':');
      classStart = parseInt(startParts[0] || '0');
      classEnd = parseInt(endParts[0] || '0');
    } else {
      return `<div class="text-ui-error-text p-4 bg-ui-error-bg rounded-lg">エラー: この教室の講座時間が設定されていません。</div>`;
    }
    const endBuffer = 3;

    const breakOptions = [...Array(5).keys()]
      .map(
        i =>
          `<option value="${i * 30}" ${String(i * 30) === (reservationDetails.breakTime || '0') ? 'selected' : ''}>${i * 30}分</option>`,
      )
      .join('');

    const startTimeOptions = getTimeOptionsHtml(
      classStart,
      classEnd + endBuffer,
      30,
      reservationDetails[window.HEADERS?.RESERVATIONS?.START_TIME] ||
        reservationDetails.startTime,
    );
    const endTimeOptions = getTimeOptionsHtml(
      classStart,
      classEnd + endBuffer,
      30,
      reservationDetails[window.HEADERS?.RESERVATIONS?.END_TIME] ||
        reservationDetails.endTime,
    );

    const rentalChecked =
      reservationDetails.chiselRental ||
      reservationDetails['彫刻刀レンタル'] === true
        ? 'checked'
        : '';

    const discountRule = stateManager
      .getState()
      .accountingMaster.find(
        item => item[HEADERS.ACCOUNTING.ITEM_NAME] === C.items.DISCOUNT,
      );
    // 割引ルールが見つからない場合でも、常に割引チェックボックスを表示
    const discountHtml = `<div class="mt-4 pt-4 border-t border-gray-200">${getDiscountHtml({ 項目名: C.items.DISCOUNT }, reservationDetails.discountApplied ? '1' : '0')}<p class="text-sm ${DesignConfig.colors.textSubtle} mt-2 text-left">初回参加者と同時刻に参加の場合、¥500割引</p></div>`;

    // 基本授業料の表示を追加
    const basicTuitionRule = stateManager
      .getState()
      .accountingMaster.find(
        item =>
          item[HEADERS.ACCOUNTING.ITEM_NAME] === C.items.MAIN_LECTURE &&
          item[HEADERS.ACCOUNTING.TARGET_CLASSROOM] &&
          item[HEADERS.ACCOUNTING.TARGET_CLASSROOM].includes(
            scheduleInfo.classroom || reservationDetails.classroom,
          ),
      );

    const basicTuitionDisplay = basicTuitionRule
      ? `<div class="mb-3 p-3 bg-blue-50 rounded border-l-4 border-blue-400">
             <div class="text-base text-blue-800">
               <span class="font-semibold">${C.items.MAIN_LECTURE}:</span> ¥${basicTuitionRule[HEADERS.ACCOUNTING.UNIT_PRICE]?.toLocaleString() || 0} / 30分
             </div>
           </div>`
      : '';

    return `
          <div class="p-4 ${DesignConfig.cards.background} rounded-lg space-y-3">
              <h3 class="${DesignConfig.text.heading} mb-2">授業料</h3>
              ${basicTuitionDisplay}
              <div class="grid grid-cols-3 gap-2 items-end">
                  ${Components.createSelect({
                    id: 'start-time',
                    name: 'startTime',
                    label: '開始時刻',
                    containerClass: 'col-span-1',
                    options: startTimeOptions,
                  })}
                  ${Components.createSelect({
                    id: 'end-time',
                    name: 'endTime',
                    label: '終了時刻',
                    containerClass: 'col-span-1',
                    options: endTimeOptions,
                  })}
                  ${Components.createSelect({
                    id: 'break-time',
                    name: 'breakTime',
                    label: '休憩時間',
                    containerClass: 'col-span-1',
                    options: breakOptions,
                  })}
              </div>
              <div id="calculated-hours" class="text-left text-base ${DesignConfig.colors.textSubtle} mt-2"></div>
              <div class="pt-3 mt-3 border-t border-gray-200">
                  <label class="flex items-center justify-between">
                      <span class="text-brand-text">${C.items.CHISEL_RENTAL}</span>
                      <input type="checkbox" name="chiselRental" data-item-type="${C.itemTypes.TUITION}" data-item-name="${C.items.CHISEL_RENTAL}" class="accounting-item h-5 w-5 rounded border-ui-border text-brand-text focus:ring-brand-text" ${rentalChecked}>
                  </label>
              </div>
              ${discountHtml}
              <div id="tuition-breakdown" class="mt-4 pt-4 border-t border-ui-border space-y-1 text-base ${DesignConfig.colors.textSubtle}"></div>
              <div class="text-right font-bold mt-2" id="tuition-subtotal">小計: 0円</div>
          </div>`;
  };

  // =================================================================
  // --- Main Application Views ---
  // -----------------------------------------------------------------
  // アプリケーションの各画面の完全なHTML構造を生成する関数群。
  // =================================================================

  /**
   * ログイン画面のUIを生成します。
   * @returns {string} HTML文字列
   */
  const getLoginView = () => {
    const phoneValue = stateManager.getState().loginPhone || '';
    return `
        <div class="text-center pt-8 pb-4">
            <h1 class="text-3xl font-bold text-brand-text tracking-tight">きぼりの<br>よやく・きろく</h1>
            <h2 class="text-xl text-brand-subtle mt-2 mb-10">川崎誠二 木彫り教室</h2>
        </div>
        ${Components.createInput({ id: 'phone', label: '電話番号', type: 'tel', placeholder: '090 1234 5678', containerClass: DesignConfig.inputs.container, autocomplete: 'tel', isSrOnly: false, labelClass: `block text-brand-subtle text-sm text-center mb-1`, inputClass: 'text-center', inputmode: 'numeric', pattern: '[0-9]*', value: phoneValue })}
        <div class="mt-6 flex justify-center">
            <div class="${DesignConfig.inputs.container}">
                ${Components.createButton({ text: 'ログイン または 新規登録', action: 'login', colorClass: DesignConfig.colors.primary, widthClass: DesignConfig.buttons.full })}
            </div>
        </div>`;
  };

  /**
   * ユーザー情報入力フォーム（新規登録・プロフィール編集共通）
   * 【統合設計】新規登録と編集を1つの関数で処理する効率的な実装
   * @param {Object} config - 設定オブジェクト
   * @param {string} config.mode - 'register'（新規登録）または 'edit'（編集）
   * @param {string} [config.phone] - 電話番号（新規登録時のみ）
   * @returns {string} HTML文字列
   */
  const getUserFormView = config => {
    const { mode, phone } = config;
    const isEdit = mode === 'edit';
    const u = stateManager.getState().currentUser || {};

    // 入力値の保持: 新規登録Step1ではstateManager.getState().registrationDataを参照
    let regData = stateManager.getState().registrationData || {};
    const realNameValue = isEdit ? u.realName || '' : regData.realName || '';
    const nicknameValue = isEdit ? u.displayName || '' : regData.nickname || '';
    const phoneValue = isEdit
      ? stateManager.getState().registrationPhone || u.phone || ''
      : regData.phone || phone || '';

    // 電話番号表示の判定
    const isPhoneInputNeeded =
      isEdit && (stateManager.getState().registrationPhone || !u.phone);

    // タイトルと説明文
    const title = isEdit ? 'プロフィール編集' : '新規登録';
    const description = isEdit
      ? ''
      : '<p class="text-brand-subtle mb-6">お名前を登録してください。</p>';

    // 電話番号セクション
    let phoneSection = '';
    if (!isEdit) {
      // 新規登録時：電話番号を表示のみ
      phoneSection = `
          <div class="mb-4">
              <label class="block text-brand-text text-base font-bold mb-2">電話番号</label>
              <input type="tel" id="reg-phone" value="${phoneValue}" class="${DesignConfig.inputs.base}" placeholder="090 1234 5678" autocomplete="tel" inputmode="numeric" pattern="[0-9]*">
          </div>`;
    } else if (isPhoneInputNeeded) {
      // プロフィール編集時：電話番号入力が必要
      phoneSection = `
          <div class="mb-4">
              <label for="edit-phone" class="block text-brand-text text-base font-bold mb-2">電話番号</label>
              <input type="tel" id="edit-phone" value="${phoneValue}"
                     class="${DesignConfig.inputs.base}" placeholder="090 1234 5678"
                     autocomplete="tel" inputmode="numeric" pattern="[0-9]*">
              <p class="text-sm text-brand-subtle mt-1">電話番号を登録すると次回からスムーズにログインできます。</p>
          </div>`;
    } else {
      // プロフィール編集時：電話番号表示のみ
      phoneSection = `
          <div class="mb-4">
              <label class="block text-brand-text text-base font-bold mb-2">電話番号</label>
              <p class="font-semibold p-3 bg-ui-surface text-brand-text rounded-lg w-auto inline-block">${phoneValue}</p>
          </div>`;
    }

    // メール設定セクション（プロフィール編集時のみ）
    const emailSection = isEdit
      ? `
          <div class="space-y-4">
            ${Components.createInput({
              id: 'edit-email',
              label: 'メールアドレス',
              type: 'email',
              value: u.email || '',
              placeholder: 'example@email.com',
              containerClass: '',
              autocomplete: 'email',
            })}
            <div class="p-3 bg-ui-surface rounded-md">
              <label class="flex items-center space-x-3">
                <input type="checkbox" id="edit-wants-email"
                       class="h-5 w-5 accent-action-primary-bg"
                       ${u.wantsEmail ? 'checked' : ''}>
                <span class="text-brand-text text-sm">メール連絡を希望します（教室日程、予約受付、など）**初回予約時は、すべての方へ連絡します**</span>
              </label>
            </div>
          </div>
        `
      : '';

    // ボタン設定
    const buttons = isEdit
      ? [
          {
            text: '戻る',
            action: 'smartGoBack',
            colorClass: DesignConfig.colors.secondary,
          },
          {
            text: 'この内容で更新',
            action: 'saveProfile',
            colorClass: DesignConfig.colors.primary,
          },
        ]
      : [
          {
            text: '戻る',
            action: 'goBackToLogin',
            colorClass: DesignConfig.colors.secondary,
          },
          {
            text: '次へ進む',
            action: 'goToStep2',
            colorClass: DesignConfig.colors.primary,
          },
        ];

    const nameIdPrefix = isEdit ? 'edit' : 'reg';

    return `
          <div class="max-w-md mx-auto">
              <h1 class="text-xl font-bold text-brand-text mb-4">${title}</h1>
              ${description}
              <div class="space-y-4">
                ${Components.createInput({
                  id: `${nameIdPrefix}-realname`,
                  label: 'お名前 *必須項目*',
                  type: 'text',
                  required: true,
                  value: realNameValue,
                  containerClass: '',
                  autocomplete: 'name',
                })}
                ${Components.createInput({
                  id: `${nameIdPrefix}-nickname`,
                  label: 'ニックネーム（表示名）',
                  caption: '他の生徒さんにも表示されます',
                  type: 'text',
                  value: nicknameValue,
                  placeholder: '空欄の場合はお名前',
                  containerClass: '',
                })}
                ${phoneSection}
                ${emailSection}
              </div>

              <div class="mt-8 grid grid-cols-2 gap-3">
              ${buttons
                .map(btn =>
                  Components.createButton({
                    text: btn.text,
                    action: btn.action,
                    colorClass: btn.colorClass,
                    widthClass: DesignConfig.buttons.full,
                  }),
                )
                .join('')}
              </div>
          </div>`;
  };

  /**
   * 新規登録画面のUIを生成します。
   * @param {string} p - ログイン試行時に入力された電話番号
   * @returns {string} HTML文字列
   */
  const getRegisterView = p => getUserFormView({ mode: 'register', phone: p });

  /**
   * 新規登録フローのステップ2（プロフィール詳細）
   * 【設計方針】ステップ式登録により、ユーザー負担を軽減
   * @returns {string} プロフィール詳細フォームのHTML文字列
   */
  const getRegistrationStep2View = () => {
    const data = stateManager.getState().registrationData;
    const genderOptions = ['女性', '男性', 'その他']
      .map(
        opt =>
          `<label class="flex items-center space-x-2"><input type="radio" name="gender" value="${opt}" ${data.gender === opt ? 'checked' : ''}><span class="text-brand-text">${opt}</span></label>`,
      )
      .join('');
    const handOptions = ['右利き', '左利き', '両利き']
      .map(
        opt =>
          `<label class="flex items-center space-x-2"><input type="radio" name="dominantHand" value="${opt}" ${data.dominantHand === opt ? 'checked' : ''}><span class="text-brand-text">${opt}</span></label>`,
      )
      .join('');
    const ageOptions = [
      '----',
      '10代（16歳以上）',
      '20代',
      '30代',
      '40代',
      '50代',
      '60代',
      '70代',
      '80代以上',
      'ひみつ',
    ]
      .map(
        opt =>
          `<option value="${opt}" ${data.ageGroup === opt ? 'selected' : ''}>${opt}</option>`,
      )
      .join('');

    return `
      <div class="max-w-md mx-auto text-left">
        <h1 class="text-xl font-bold text-brand-text mb-4 text-center">プロフィール</h1>
        <form id="step2-form" class="space-y-6">
          ${Components.createInput({ id: 'q-email', label: 'メールアドレス *必須項目*', type: 'email', value: data.email || '', required: true })}
          <div class="p-3 bg-ui-surface rounded-md">
            <label class="flex items-center space-x-3">
              <input type="checkbox" id="q-wants-email" name="wantsEmail" class="h-5 w-5 accent-action-primary-bg" ${data.wantsEmail ? 'checked' : ''}>
              <span class="text-brand-text text-sm">メール連絡を希望します（教室日程、予約受付、など）</span>
            </label>
          </div>
          ${Components.createSelect({ id: 'q-age-group', label: 'お年頃', options: ageOptions })}
          <div><label class="block text-brand-text text-base font-bold mb-2">性別</label><div class="flex space-x-4">${genderOptions}</div></div>
          <div><label class="block text-brand-text text-base font-bold mb-2">利き手</label><div class="flex space-x-4">${handOptions}</div></div>
          ${Components.createInput({ id: 'q-address', label: '住所（市区町村まででOK！）', type: 'text', value: data.address || '' })}
        </form>
        <div class="mt-8 grid grid-cols-2 gap-3">
          ${Components.createButton({ text: '前に戻る', action: 'backToStep1', colorClass: DesignConfig.colors.secondary })}
          ${Components.createButton({ text: '次へ進む', action: 'goToStep3', colorClass: DesignConfig.colors.primary })}
        </div>
      </div>
    `;
  };

  /**
   * 新規登録フローのステップ3（木彫り関連情報）
   * 【UX配慮】動的表示制御により、経験者には詳細質問を表示
   * @returns {string} 木彫りアンケートフォームのHTML文字列
   */
  const getRegistrationStep3View = () => {
    const data = stateManager.getState().registrationData;
    const experienceOptions = ['はじめて！', 'ちょっと', 'そこそこ', 'かなり！']
      .map(
        opt =>
          `<label class="flex items-center space-x-2"><input type="radio" name="experience" value="${opt}" ${data.experience === opt ? 'checked' : ''}><span class="text-brand-text">${opt}</span></label>`,
      )
      .join('');

    return `
      <div class="max-w-md mx-auto text-left">
        <h1 class="text-xl font-bold text-brand-text mb-4 text-center">木彫りについて</h1>
        <form id="step3-form" class="space-y-6">
          <div>
            <label class="block text-brand-text text-base font-bold mb-2">木彫りの経験はありますか？</label>
            <div class="space-y-2" id="experience-radio-group">${experienceOptions}</div>
          </div>
          <div id="past-work-container" class="${data.experience === 'はじめて！' ? 'hidden' : ''}">
            ${Components.createTextArea({
              id: 'q-past-work',
              label: 'いつ頃、どこで、何を作りましたか？',
              caption: 'だいたいでOK！',
              value: data.pastWork || '',
            })}
          </div>
          ${Components.createTextArea({
            id: 'q-future-goal',
            label: '将来的に制作したいものはありますか？',
            caption: '曖昧な内容でも大丈夫！',
            value: data.futureGoal || '',
          })}
        </form>
        <div class="mt-8 grid grid-cols-2 gap-3">
          ${Components.createButton({ text: '前に戻る', action: 'backToStep2', colorClass: DesignConfig.colors.secondary, widthClass: DesignConfig.buttons.full })}
          ${Components.createButton({ text: '次へ', action: 'proceedToStep4', colorClass: DesignConfig.colors.primary, widthClass: DesignConfig.buttons.full })}
        </div>
      </div>
    `;
  };

  /**
   * 新規登録フローのステップ4（アンケート）
   * 【設計方針】最終ステップでユーザーの参加意向とフィードバックを収集
   * @returns {string} アンケートフォームのHTML文字列
   */
  const getRegistrationStep4View = () => {
    const data = stateManager.getState().registrationData;
    const participationOptions = [
      '毎月通いたい！',
      '2,3ヶ月ごとくらいで通いたい！',
      'これるときにたまに通いたい！',
      '1回やってみたい！',
      '通いたいがむずかしい…',
    ]
      .map(
        opt =>
          `<label class="flex items-center space-x-2 p-2 rounded hover:bg-ui-surface cursor-pointer">
              <input type="radio" name="futureParticipation" value="${opt}" ${data.futureParticipation === opt ? 'checked' : ''} class="text-action-primary-bg focus:ring-action-primary-bg">
              <span class="text-brand-text">${opt}</span>
            </label>`,
      )
      .join('');

    return `
      <div class="max-w-md mx-auto text-left">
        <h1 class="text-xl font-bold text-brand-text mb-4 text-center">アンケート</h1>
        <form id="step4-form" class="space-y-6">
          <div>
            <label class="block text-brand-text text-base font-bold mb-3">今後のご参加について</label>
            <div class="space-y-2" id="participation-radio-group">${participationOptions}</div>
          </div>

          ${Components.createTextArea({
            id: 'q-trigger',
            label: 'この教室を知ったきっかけは？参加しようと思ったきっかけは？',
            caption: '',
            value: data.trigger || '',
            rows: 4,
          })}

          ${Components.createTextArea({
            id: 'q-first-message',
            label: 'メッセージ',
            caption: 'その他コメント・要望・意見など、あればどうぞ〜',
            value: data.firstMessage || '',
            rows: 4,
          })}
        </form>
        <div class="mt-8 grid grid-cols-2 gap-3">
          ${Components.createButton({ text: '前に戻る', action: 'backToStep3', colorClass: DesignConfig.colors.secondary, widthClass: DesignConfig.buttons.full })}
          ${Components.createButton({ text: '登録して予約へ進む', action: 'submitRegistration', colorClass: DesignConfig.colors.primary, widthClass: DesignConfig.buttons.full })}
        </div>
      </div>
    `;
  };

  /**
   * 電話番号未登録ユーザーの検索・選択画面
   * 【機能】NF-01 対応：名前検索によるアカウント発見機能
   * @returns {string} HTML文字列
   */
  const getUserSearchView = () => {
    const users = stateManager.getState().searchedUsers;
    // NF-01: 検索が実行され、結果が0件の場合にメッセージを表示
    const hasSearchedAndNoResults =
      stateManager.getState().searchAttempted && users.length === 0;

    return `
          <h1 class="text-xl font-bold text-brand-text mb-4">アカウントを探す</h1>
          <p class="text-brand-subtle mb-6">お名前（本名）またはニックネームを入力して、あなたのアカウントを見つけてください。<br>
          <span class="text-sm text-brand-muted">（漢字が異なる場合や、姓と名の間が開いている場合でも、スペースを入れずに、苗字だけでも試してみてください）</span></p>

          <div class="${DesignConfig.inputs.container} mb-4">
              ${Components.createInput({
                id: 'nickname-search-input',
                label: 'お名前（本名）またはニックネーム', // ラベルを変更
                type: 'text',
                placeholder: 'お名前またはニックネーム', // プレースホルダーを変更
                inputClass: 'text-center',
                autocomplete: 'off',
              })}
              <div class="mt-4 flex justify-center">
                  ${Components.createButton({
                    text: '検索',
                    action: 'searchUserByName',
                    colorClass: DesignConfig.colors.primary,
                    widthClass: DesignConfig.buttons.full,
                  })}
              </div>
          </div>

          <div class="mt-8 space-y-3">
              ${
                users.length > 0
                  ? `
                  <h2 class="text-lg font-bold ${DesignConfig.colors.text} text-center mb-2">見つかったアカウント</h2>
                  ${users
                    .map(
                      user => `
                      <div class="${DesignConfig.cards.background} p-3 rounded-lg flex justify-between items-center">
                          <p class="text-base font-semibold">${user.realName}（${user.nickname}）</p> // 本名とニックネームを両方表示
                          ${Components.createButton({
                            text: 'これだ！',
                            action: 'selectSearchedUser',
                            studentId: user.studentId,
                            realName: user.realName,
                            nickname: user.nickname,
                            colorClass:
                              'bg-state-success-bg text-state-success-text text-sm py-1 px-3 rounded active:bg-state-success-hover focus:bg-state-success-hover mobile-button',
                          })}
                      </div>
                  `,
                    )
                    .join('')}
              `
                  : hasSearchedAndNoResults
                    ? `
                  <p class="text-center ${DesignConfig.colors.textSubtle}">一致するアカウントが見つかりませんでした。</p>
              `
                    : ''
              }
          </div>

          <div class="mt-8 pt-4 border-t border-gray-200 flex flex-col space-y-3">
              <h2 class="text-lg font-bold ${DesignConfig.colors.text} text-center mb-2">見つからない場合</h2>
              ${Components.createButton({
                text: '自分のアカウントが見つからないので、新規登録する',
                action: 'goToRegisterFromUserSearch',
                colorClass: DesignConfig.colors.primary,
                widthClass: DesignConfig.buttons.full,
              })}
              ${Components.createButton({
                text: 'ログイン画面に戻る',
                action: 'goBackToLogin',
                colorClass: DesignConfig.colors.secondary,
                widthClass: DesignConfig.buttons.full,
              })}
          </div>
      `;
  };

  /**
   * ホーム予約カードのボタン配列を生成します（新仕様）。
   * @param {object} booking - 予約データ
   * @returns {Array} ボタン設定配列
   */
  const _buildBookingButtons = booking => {
    const buttons = [];
    const isBookingToday = _isToday(booking.date);

    // 会計関連ボタン（新仕様）
    if (booking.status === STATUS.CONFIRMED && isBookingToday) {
      // よやく かつ 当日 → 「会計」ボタン
      buttons.push({
        action: 'goToAccounting',
        text: '会計',
        style: 'accounting',
      });
    }

    // 確認/編集ボタン
    if (
      booking.status === STATUS.CONFIRMED ||
      booking.status === STATUS.WAITLISTED
    ) {
      // よやく → 「確認/編集」ボタン
      buttons.push({
        action: 'goToEditReservation',
        text: '確認/編集',
        style: 'edit',
      });
    }

    return buttons;
  };

  /**
   * ホーム履歴カードのボタン配列を生成します（新仕様）。
   * @param {object} historyItem - 履歴データ
   * @returns {Array} ボタン設定配列
   */
  const _buildHistoryButtons = historyItem => {
    const buttons = [];
    const isHistoryToday = _isToday(historyItem.date);

    // 会計関連ボタン（新仕様）
    if (historyItem.status === STATUS.COMPLETED) {
      if (isHistoryToday) {
        // きろく かつ 当日 → 「会計を修正」ボタン
        buttons.push({
          action: 'editAccountingRecord',
          text: '会計を修正',
          style: 'accounting',
        });
      } else {
        // きろく → 「会計詳細」ボタン
        buttons.push({
          action: 'showHistoryAccounting',
          details: historyItem.accountingDetails,
          text: '会計詳細',
          style: 'record',
        });
      }
    }

    // メモ編集ボタン
    buttons.push({
      action: 'editHistoryMemo',
      text: window.stateManager.getState().constants?.messages?.EDIT || '編集',
      style: 'edit-small',
    });

    return buttons;
  };

  /**
   * メインのホーム画面のUIを生成します。
   * 【改善】ビジネスロジックをヘルパー関数に分離して可読性向上
   * @returns {string} HTML文字列
   */
  const getDashboardView = () => {
    // 計算済みデータを使用（setState()で自動更新済み）
    const sortedBookings = stateManager.getState().computed.sortedBookings;
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // 予約セクション用のカード配列を構築（新仕様：「よやく」表示条件）
    const bookingCards = sortedBookings
      .filter(b => [STATUS.WAITLISTED, STATUS.CONFIRMED].includes(b.status))
      .map(b => {
        const buttons = _buildBookingButtons(b);
        return Components.listCard({
          type: 'booking',
          item: b,
          today: today,
          buttons: buttons,
        });
      });

    // 予約セクションを生成（Componentsに構造生成を委任）
    const yourBookingsHtml = Components.dashboardSection({
      title: 'よやく',
      items: bookingCards,
      showNewButton: true,
      newAction: 'showClassroomModal',
    });

    // 履歴セクションを生成（新仕様：「きろく」表示条件）
    let historyHtml = '';
    // すべての完了ステータス予約を「きろく」として表示（myBookings内のCOMPLETEDも含む）
    const sortedHistory = stateManager.getState().computed.sortedHistory;
    const completedRecords = sortedHistory.filter(
      r => r.status === STATUS.COMPLETED,
    );

    if (completedRecords.length > 0) {
      // 「きろく」は COMPLETED ステータスのみ表示
      const historyCards = completedRecords.map(h => {
        const buttons = _buildHistoryButtons(h);
        return Components.listCard({
          type: 'history',
          item: h,
          today: null, // 履歴では不要
          buttons: buttons,
        });
      });

      const showMore =
        (stateManager.getState().recordsToShow || 10) < completedRecords.length;

      // Componentsに構造生成を委任
      historyHtml = Components.dashboardSection({
        title: 'きろく',
        items: historyCards,
        showMoreButton: showMore,
        moreAction: 'loadMoreHistory',
      });
    }

    return `
          <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-2">
              <h1 class="text-base sm:text-xl font-bold ${DesignConfig.colors.text} mr-4 mb-1 sm:mb-0">ようこそ <span class="text-xl whitespace-nowrap">${stateManager.getState().currentUser.displayName} <span class="text-base">さん</span></span></h1>
              <button data-action="goToEditProfile" class="${DesignConfig.colors.info} self-end sm:self-auto text-sm text-action-secondary-text px-3 py-0.5 rounded-md active:bg-action-secondary-hover">Profile 編集</button>
          </div>
          ${yourBookingsHtml}
          ${historyHtml}
      `;
  };

  /**
   * 教室名に応じた色クラスを取得します
   * @param {string} classroomName - 教室名
   * @returns {string} 色クラス文字列
   */
  const getClassroomColorClass = classroomName => {
    if (classroomName.includes('東京')) {
      return DesignConfig.classroomColors.tokyo.colorClass;
    } else if (classroomName.includes('沼津')) {
      return DesignConfig.classroomColors.numazu.colorClass;
    } else if (classroomName.includes('つくば')) {
      return DesignConfig.classroomColors.tsukuba.colorClass;
    } else {
      return DesignConfig.classroomColors.default.colorClass;
    }
  };

  /**
   * 教室選択モーダル用のコンテンツを生成します。
   * @returns {string} HTML文字列
   */
  const getClassroomSelectionModalContent = () => {
    const classrooms = Object.values(stateManager.getState().classrooms || {});

    if (!classrooms.length) {
      return `<div class="text-center"><p class="text-brand-subtle mb-4">現在、予約可能な教室がありません。</p></div>`;
    }

    // 指定された順序で教室を並べ替え（東京、つくば、沼津）
    const desiredOrder = ['東京教室', 'つくば教室', '沼津教室'];
    const sortedClassrooms = classrooms.sort((a, b) => {
      const indexA = desiredOrder.indexOf(a);
      const indexB = desiredOrder.indexOf(b);

      // 指定された順序にない教室は最後に配置
      if (indexA === -1 && indexB === -1) return a.localeCompare(b);
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;

      return indexA - indexB;
    });

    const classroomButtonsHtml = sortedClassrooms
      .map(classroomName => {
        const colorClass = getClassroomColorClass(classroomName);
        const fullButtonClass = `w-full h-16 text-center px-6 py-4 rounded-xl mobile-card touch-friendly flex items-center justify-center text-xl font-bold border-2 transition-all duration-200 hover:scale-105 hover:shadow-lg active:scale-95 ${colorClass}`;

        const buttonHtml = Components.button({
          action: 'selectClassroom',
          text: classroomName,
          style: 'none', // デフォルトスタイルを無効化
          customClass: fullButtonClass,
          dataAttributes: {
            classroomName: classroomName,
            classroom: classroomName, // フォールバック用
          },
        });

        // デバッグ用: 生成されたHTMLを確認
        if (!window.isProduction && typeof console !== 'undefined') {
          console.log(
            `🔘 ${classroomName}ボタンHTML:`,
            buttonHtml.substring(0, 300),
          );
          console.log(`🔘 ${classroomName}カラークラス:`, colorClass);
        }

        return buttonHtml;
      })
      .join('');

    return `
        <div class="text-center mb-6">
          <p class="text-brand-subtle text-lg mb-2">教室 を おえらびください</p>
        </div>
        <div class="space-y-4">
          ${classroomButtonsHtml}
        </div>
      `;
  };

  /**
   * 教室選択モーダル全体のHTMLを生成します。
   * @returns {string} HTML文字列
   */
  const getClassroomSelectionModal = () => {
    return Components.modal({
      id: 'classroom-selection-modal',
      title: '',
      content: getClassroomSelectionModalContent(),
      maxWidth: 'max-w-md', // より大きなサイズに変更
    });
  };

  /**
   * プロフィール編集画面のUIを生成します。
   * @returns {string} HTML文字列
   */
  const getEditProfileView = () => getUserFormView({ mode: 'edit' });

  /**
   * 予約スロットのリストからHTMLを生成します。
   * この関数は getBookingView と getCompleteView で共有されます。
   * @param {Array<object>} slots - 表示する予約スロットの配列
   * @returns {string} HTML文字列
   */
  const renderBookingSlots = slots => {
    if (!slots || slots.length === 0) {
      return '';
    }

    // 受け取ったslotsを月別にグループ化
    const slotsByMonth = slots.reduce((acc, slot) => {
      const month = new Date(slot.date).getMonth() + 1;
      if (!acc[month]) acc[month] = [];
      acc[month].push(slot);
      return acc;
    }, {});

    return Object.keys(slotsByMonth)
      .sort((a, b) => a - b)
      .map(month => {
        const monthHeader = `<h4 class="text-lg font-medium ${DesignConfig.colors.textSubtle} mt-4 mb-2 text-center">${month}月</h4>`;

        const slotsHtml = slotsByMonth[month]
          .map(sl => {
            const iB = stateManager
              .getState()
              .computed.sortedBookings.some(
                b => b.date === sl.date && b.classroom === sl.classroom,
              );
            let cC, sB, act;
            const tag = iB ? 'div' : 'button';

            // 初回者・経験者別の表示制御
            const isFirstTimeBooking = stateManager.getState().isFirstTimeBooking;
            let statusText;

            // デバッグ情報（開発時のみ）
            if (!window.isProduction && isFirstTimeBooking) {
              console.log('🔍 初回者スロット情報:', {
                date: sl.date,
                classroom: sl.classroom,
                firstLectureSlots: sl.firstLectureSlots,
                isFirstTimeBooking,
              });
            }

            if (isFirstTimeBooking) {
              // 初回者（はじめての方）の場合
              if (sl.beginnerCapacity > 0) {
                // 初回者の定員が1以上の日程：初回者枠に基づく空席情報を提示
                statusText = `初回者 空き ${sl.firstLectureSlots}`;
              } else {
                // 初回者の定員が0の日程：「経験者のみ」として表示
                statusText = '経験者のみ';
              }
            } else {
              // 経験者の場合：全体（本講座）の参加者数に基づく表示
              if (
                typeof sl.morningSlots !== 'undefined' &&
                typeof sl.afternoonSlots !== 'undefined'
              ) {
                // ２部制の場合の例「空き 午前3 午後 4」
                const morningLabel =
                  stateManager.getState().constants?.sessions?.MORNING || '午前';
                const afternoonLabel =
                  stateManager.getState().constants?.sessions?.AFTERNOON ||
                  '午後';
                statusText = `空き ${morningLabel}${sl.morningSlots} ${afternoonLabel}${sl.afternoonSlots}`;
              } else if (typeof sl.availableSlots !== 'undefined') {
                // セッション制、全日制の場合の例「空き 3」
                statusText = `空き ${sl.availableSlots}`;
              } else {
                // フォールバック
                statusText = '空き状況不明';
              }
              // 経験者には初回者の空き情報は提示しない（既存のコメントアウト）
            }

            if (iB) {
              // 【修正】予約済み・記録済みの場合（統一検索関数を使用）
              const reservationData = findReservationByDateAndClassroom(
                sl.date,
                sl.classroom,
              );

              console.log(
                `🔍 Slot検索結果 - ${sl.date} ${sl.classroom}:`,
                reservationData
                  ? {
                      status: reservationData.status,
                      type: reservationData.type,
                    }
                  : 'なし',
              );

              if (
                reservationData &&
                reservationData.status === STATUS.COMPLETED
              ) {
                // 完了済みの記録の場合
                cC = `${DesignConfig.cards.base} ${DesignConfig.cards.state.booked.card}`;
                sB = `<span class="text-sm font-bold ${DesignConfig.cards.state.booked.text}">受講済み</span>`;
                act = '';
              } else if (
                reservationData &&
                reservationData.status === STATUS.WAITLISTED
              ) {
                // キャンセル待ちの場合
                cC = `${DesignConfig.cards.base} ${DesignConfig.cards.state.waitlist.card}`;
                sB = `<span class="text-sm font-bold ${DesignConfig.cards.state.waitlist.text}">キャンセル待ち 登録済</span>`;
                act = '';
              } else {
                // 確定予約の場合
                cC = `${DesignConfig.cards.base} ${DesignConfig.cards.state.booked.card}`;
                sB = `<span class="text-sm font-bold ${DesignConfig.cards.state.booked.text}">予約済み</span>`;
                act = '';
              }
            } else {
              // 初回者・経験者別の満席判定とUI状態決定
              let isSlotFull = false;
              let canBook = true;

              if (isFirstTimeBooking) {
                // 初回者の場合：初回者枠に基づく判定
                if (sl.beginnerCapacity <= 0) {
                  // 初回講習枠が0の場合は「経験者のみ」でクリック不可
                  canBook = false;
                }
                // 初回講習枠が満席の場合はキャンセル待ち
                isSlotFull = sl.firstLectureIsFull;
              } else {
                // 経験者の場合：全体枠に基づく判定
                isSlotFull = sl.isFull;
              }

              if (!canBook) {
                // 初回者で初回講習枠が0の場合（経験者のみ）：クリック不可
                cC = `${DesignConfig.cards.base} ${DesignConfig.cards.state.waitlist.card} opacity-50`;
                sB = `<span class="text-sm font-bold ${DesignConfig.cards.state.waitlist.text}">${statusText}</span>`;
                act = '';
              } else if (isSlotFull) {
                // 満席（キャンセル待ち）の場合
                cC = `${DesignConfig.cards.base} ${DesignConfig.cards.state.waitlist.card}`;
                sB = `<span class="text-sm font-bold ${DesignConfig.cards.state.waitlist.text}">満席（キャンセル待ち申込み）</span>`;
                act = `data-action="bookSlot" data-classroom="${sl.classroom}" data-date="${sl.date}"`;
              } else {
                // 予約可能な場合
                cC = `${DesignConfig.cards.base} ${DesignConfig.cards.state.available.card}`;
                sB = `<span class="text-sm font-bold ${DesignConfig.cards.state.available.text}">${statusText}</span>`;
                act = `data-action="bookSlot" data-classroom="${sl.classroom}" data-date="${sl.date}"`;
              }
            }

            const venueDisplay = sl.venue ? ` ${sl.venue}` : '';
            const text = `<div class="flex justify-between items-center w-full"><span class="${DesignConfig.colors.text}">${formatDate(sl.date)}${venueDisplay}</span>${sB}</div>`;

            // getBookingViewのロジックをベースに、buttonとdivを使い分ける
            return `<${tag} ${act} class="${cC}">${text}</${tag}>`;
          })
          .join('');

        return monthHeader + slotsHtml;
      })
      .join('');
  };

  /**
   * 特定の教室の予約枠一覧画面のUIを生成します。
   * @param {string} classroom - 教室名
   * @returns {string} HTML文字列
   */
  const getBookingView = classroom => {
    // バックエンドで計算済みの空き情報を直接使用
    const relevantSlots = stateManager.getState().slots
      ? stateManager.getState().slots.filter(slot => slot.classroom === classroom)
      : [];

    const bookingSlotsHtml = renderBookingSlots(relevantSlots);

    if (!bookingSlotsHtml) {
      return `
          <div class="max-w-md mx-auto">
              <h1 class="text-xl font-bold ${DesignConfig.colors.text} mb-2">${classroom}</h1>
              <p class="${DesignConfig.colors.textSubtle} mb-6">現在、予約可能な日がありません。</p>
              <div class="mt-6">
                  ${Components.createButton({ text: 'ホームに戻る', action: 'goBackToDashboard', colorClass: DesignConfig.colors.secondary, widthClass: DesignConfig.buttons.full })}
              </div>
          </div>`;
    } else {
      return `
          <div class="max-w-md mx-auto">
              <h1 class="text-xl font-bold ${DesignConfig.colors.text} mb-4">${classroom}</h1>
              <div class="${DesignConfig.cards.container}">${bookingSlotsHtml}</div>
              <div class="mt-6">
                  ${Components.createButton({ text: 'ホームに戻る', action: 'goBackToDashboard', colorClass: DesignConfig.colors.secondary, widthClass: DesignConfig.buttons.full })}
              </div>
          </div>`;
    }
  };

  /**
   * 予約の詳細入力・編集画面のUIを生成します。
   * @param {string} mode - 'new' または 'edit'
   * @returns {string} HTML文字列
   */
  const getReservationFormView = (mode = 'new') => {
    const isEdit = mode === 'edit';

    // --- 1. データの準備 ---
    // 編集時は editingReservationDetails から、新規作成時は selectedSlot からデータを取得
    const sourceData = isEdit
      ? stateManager.getState().editingReservationDetails
      : stateManager.getState().selectedSlot;
    if (!sourceData) return 'エラー: 予約情報が見つかりません。';

    const {
      classroom,
      date,
      venue,
      isWaiting,
      firstLecture,
      chiselRental,
      workInProgress,
      materialInfo,
      order,
      messageToTeacher,
    } = sourceData;

    // 時間情報は統合定数を使用して取得
    const startTime =
      sourceData[window.HEADERS?.RESERVATIONS?.START_TIME] ||
      sourceData.startTime;
    const endTime =
      sourceData[window.HEADERS?.RESERVATIONS?.END_TIME] || sourceData.endTime;
    const {
      currentUser,
      accountingMaster: master,
      isFirstTimeBooking,
    } = window.stateManager.getState();

    // 日程マスタベースの教室形式判定に変更
    const isTimeBased = isTimeBasedClassroom(sourceData);

    // デバッグ情報（開発時のみ）
    if (!window.isProduction) {
      console.log('🔍 getReservationFormView デバッグ情報:', {
        mode,
        isEdit,
        sourceData: sourceData
          ? {
              classroom: sourceData.classroom,
              date: sourceData.date,
              classroomType: sourceData.classroomType,
              firstStart: sourceData.firstStart,
              firstEnd: sourceData.firstEnd,
            }
          : null,
        isTimeBased,
        scheduleInfoExists: !!(sourceData?.firstStart && sourceData?.firstEnd),
      });
    }

    // 新規作成時のみ利用するデータ
    const {
      availableSlots,
      morningSlots,
      afternoonSlots,
      firstLectureSlots,
      isFull,
      firstLectureIsFull,
    } = stateManager.getState().selectedSlot || {};

    // --- 2. モードに応じた設定 ---
    const title = isEdit
      ? '予約内容の編集'
      : isFull || (isFirstTimeBooking && firstLectureIsFull)
        ? 'キャンセル待ち申込み'
        : '予約詳細の入力';
    const submitAction = isEdit ? 'updateReservation' : 'confirmBooking';
    const submitButtonText = isEdit
      ? 'この内容で更新する'
      : isFull
        ? 'キャンセル待ちで登録する'
        : 'この内容で予約する';

    // --- 3. UI生成ヘルパー関数 ---
    /**
     * 予約状況の表示を生成します。
     */
    const _renderStatusHtml = () => {
      if (isEdit) {
        return sourceData.isWaiting ? 'キャンセル待ち' : '予約済み';
      }

      if (isFirstTimeBooking) {
        if (firstLectureIsFull) {
          return '初回者枠 満席（キャンセル待ち申込み）';
        }
        return `初回者枠 空き ${firstLectureSlots}`;
      }

      if (isFull) return '満席（キャンセル待ち申込み）';

      if (typeof morningSlots !== 'undefined') {
        const morningLabel =
          stateManager.getState().constants?.sessions?.MORNING || '午前';
        const afternoonLabel =
          stateManager.getState().constants?.sessions?.AFTERNOON || '午後';
        return `${morningLabel}空き ${morningSlots} | ${afternoonLabel}空き ${afternoonSlots}`;
      }

      return `空き ${availableSlots}`;
    };

    /**
     * 授業料表示セクションを生成します。
     */
    const _renderTuitionDisplaySection = () => {
      // 教室形式の判定
      if (isTimeBased) {
        // 時間制の場合：基本授業料を表示
        const basicTuitionRule = master.find(
          item =>
            item[HEADERS.ACCOUNTING.ITEM_NAME] === C.items.MAIN_LECTURE &&
            item[HEADERS.ACCOUNTING.TARGET_CLASSROOM] &&
            item[HEADERS.ACCOUNTING.TARGET_CLASSROOM].includes(classroom),
        );

        if (basicTuitionRule) {
          const price = basicTuitionRule[HEADERS.ACCOUNTING.UNIT_PRICE] || 0;
          return `
              <div class="mt-4 pt-4 border-t">
                <h4 class="font-bold ${DesignConfig.colors.text} mb-2">授業料</h4>
                <div class="mb-3 p-3 bg-blue-50 rounded border-l-4 border-blue-400">
                  <div class="text-base text-blue-800">
                    <span class="font-semibold">${C.items.MAIN_LECTURE}:</span> ¥${price.toLocaleString()} / 30分
                  </div>
                </div>
              </div>`;
        }
      } else {
        // 固定制の場合：初回授業料または基本授業料を表示
        const targetItemName = isFirstTimeBooking
          ? C.items.FIRST_LECTURE
          : C.items.MAIN_LECTURE;
        const tuitionItem = master.find(
          item =>
            item[HEADERS.ACCOUNTING.TYPE] === C.itemTypes.TUITION &&
            item[HEADERS.ACCOUNTING.ITEM_NAME] === targetItemName &&
            (item[HEADERS.ACCOUNTING.TARGET_CLASSROOM] === '共通' ||
              item[HEADERS.ACCOUNTING.TARGET_CLASSROOM]?.includes(classroom)),
        );

        if (tuitionItem) {
          const price = tuitionItem[HEADERS.ACCOUNTING.UNIT_PRICE] || 0;
          const bgColor = isFirstTimeBooking
            ? 'bg-green-50 border-green-400'
            : 'bg-blue-50 border-blue-400';
          const textColor = isFirstTimeBooking
            ? 'text-green-800'
            : 'text-blue-800';
          const label = targetItemName;

          return `
              <div class="mt-4 pt-4 border-t">
                <h4 class="font-bold ${DesignConfig.colors.text} mb-2">授業料</h4>
                <div class="mb-3 p-3 ${bgColor} rounded border-l-4">
                  <div class="text-base ${textColor}">
                    <span class="font-semibold">${label}:</span> ¥${price.toLocaleString()}
                  </div>
                </div>
              </div>`;
        }
      }
      return '';
    };

    /**
     * 予約時間選択のUIを生成します。
     */
    const _renderTimeOptionsSection = () => {
      // 時間制の教室の場合
      if (isTimeBased) {
        const times = getClassroomTimesFromSchedule(sourceData);
        if (!times || !times.firstStart || !times.firstEnd) {
          return `<div class="text-ui-error-text p-4 bg-ui-error-bg rounded-lg">エラー: この教室の時間設定が不正です</div>`;
        }

        const startParts = times.firstStart.split(':');
        const endParts =
          !times.secondStart || !times.secondEnd
            ? times.firstEnd.split(':') // 1部制の場合
            : times.secondEnd.split(':'); // 2部制の場合
        const classStartHour = parseInt(startParts[0] || '0');
        const classEndHour = parseInt(endParts[0] || '0');
        const classEndMinutes = parseInt(endParts[1] || '0');

        // 初回者の場合は開始時刻を固定（日程マスタのBEGINNER_START項目を使用）
        let fixedStartTime = startTime;
        let isTimeFixed = false;
        if (isFirstTimeBooking && sourceData.beginnerStart) {
          fixedStartTime = sourceData.beginnerStart;
          isTimeFixed = true;
        }

        // デバッグ情報（開発時のみ）
        if (!window.isProduction && isFirstTimeBooking) {
          console.log('🔍 初回者用時刻設定:', {
            isFirstTimeBooking,
            isEdit,
            firstStart: times.firstStart,
            secondStart: times.secondStart,
            beginnerStart: sourceData.beginnerStart,
            fixedStartTime,
            isTimeFixed,
          });
        }

        // 初回者の場合は固定時刻のオプションのみ、経験者は通常の選択肢
        let startTimeOptions;
        if (isTimeFixed) {
          // 初回者：固定時刻のオプションのみ
          startTimeOptions = `
              <option value="${fixedStartTime}"'selected'>
                ${fixedStartTime}
              </option>`;
        } else {
          // 経験者：通常の選択肢
          startTimeOptions = getTimeOptionsHtml(
            classStartHour,
            classEndHour,
            C.frontendUi.TIME_SETTINGS.STEP_MINUTES,
            startTime,
          );
        }
        let endTimeOptions = getTimeOptionsHtml(
          classStartHour,
          classEndHour,
          C.frontendUi.TIME_SETTINGS.STEP_MINUTES,
          endTime,
        );
        if (classEndMinutes > 0) {
          const finalEndTime = `${String(classEndHour).padStart(2, '0')}:${String(classEndMinutes).padStart(2, '0')}`;
          endTimeOptions += `<option value="${finalEndTime}">${finalEndTime}</option>`;
        }

        const discountRule = master.find(
          item =>
            item[HEADERS.ACCOUNTING.ITEM_NAME] === C.items.DISCOUNT &&
            item[HEADERS.ACCOUNTING.TARGET_CLASSROOM] &&
            item[HEADERS.ACCOUNTING.TARGET_CLASSROOM].includes(classroom),
        );
        let discountHtml = '';
        if (discountRule && !isFirstTimeBooking) {
          discountHtml = `<p class="${DesignConfig.text.caption}">${discountRule[HEADERS.ACCOUNTING.ITEM_NAME]}: 初回参加者と同時刻に参加の場合、¥500割引</p>`;
        }

        // 初回者の場合の開始時刻固定メッセージ
        const timeFixedMessage = isTimeFixed
          ? `<p class="${DesignConfig.text.caption} mb-2">初回の方は ${fixedStartTime} より開始です。昼をまたぐ場合は、1時間休憩を挟みます</p>`
          : '';

        return `
            <div class="mt-4 pt-4 border-t">
              <h4 class="font-bold ${DesignConfig.colors.text} mb-2">予約時間</h4>
              ${timeFixedMessage}
              <div class="grid grid-cols-2 gap-4 mb-2">
                ${Components.select({
                  id: 'res-start-time',
                  label: '開始予定',
                  options: startTimeOptions,
                })}
                ${Components.select({
                  id: 'res-end-time',
                  label: '終了予定',
                  options: endTimeOptions,
                })}
              </div>
              ${discountHtml}
            </div>`;
      }
      return ''; // 上記以外の場合は時間選択なし
    };

    /**
     * 予約オプションのUIを生成します。
     */
    const _renderBookingOptionsSection = () => {
      let optionsHtml = '';

      const firstLectureChecked =
        firstLecture || isFirstTimeBooking ? 'checked' : '';
      const firstLectureDisabled = isFirstTimeBooking ? 'disabled' : '';
      const chiselRentalChecked = chiselRental ? 'checked' : '';

      // デバッグ情報（開発時のみ）
      if (!window.isProduction) {
        console.log('🔍 オプションセクション - 教室タイプ判定:', {
          classroomType: sourceData.classroomType,
          expectedSessionBased: C.classroomTypes?.SESSION_BASED,
          isMatch: sourceData.classroomType === C.classroomTypes?.SESSION_BASED,
          constantsAvailable: !!C.classroomTypes,
          allConstants: Object.keys(C),
        });
      }

      if (sourceData.classroomType === C.classroomTypes.SESSION_BASED) {
        const firstLectureLabel = isFirstTimeBooking
          ? `<span>${C.items.FIRST_LECTURE}</span><span class="${DesignConfig.text.caption} ml-2"></span>`
          : `<span>${C.items.FIRST_LECTURE}</span>`;
        optionsHtml += `<label class="flex items-center space-x-2"><input type="checkbox" id="option-first-lecture" ${firstLectureChecked} ${firstLectureDisabled}>${firstLectureLabel}</label>`;
      }
      optionsHtml += `<div class="mt-2"><label class="flex items-center space-x-2"><input type="checkbox" id="option-rental" ${chiselRentalChecked}><span>${C.items.CHISEL_RENTAL} 1回 ¥500</span></label></div>`;

      // 割引の説明を追加
      optionsHtml += `<div class="mt-3 pt-2 border-t border-ui-border-light"><p class="${DesignConfig.text.caption}">${C.items.DISCOUNT}: 初回参加者と同時刻に参加の場合、¥500割引</p></div>`;

      return `
          <div class="mt-4 pt-4 border-t">
            <h4 class="font-bold text-left mb-2">オプション</h4>
            ${optionsHtml}
          </div>`;
    };

    /**
     * 詳細入力欄のUIを生成します。
     * 購入希望欄を折り畳み物販チェックリスト＋自由記入欄に変更
     */
    const _renderDetailsInputSection = () => {
      // 物販チェックリスト（折り畳み）
      const salesChecklistHtml =
        typeof buildSalesChecklist === 'function'
          ? buildSalesChecklist(stateManager.getState().accountingMaster)
          : '';

      return `
          <div class="mt-4 pt-4 border-t space-y-4">
            ${Components.createTextArea({
              id: 'wip-input',
              label:
                isFirstTimeBooking && !isEdit
                  ? '今回つくりたいもの/やりたいこと'
                  : 'つくりたいもの/やりたいこと/作業予定',
              caption:
                isFirstTimeBooking && !isEdit
                  ? '最初に作る「だるま」の木彫り以外に、作りたいものがある方はご記入ください（仮でもOK!）。教室サイトの作例などは作りやすいです。ただし１回の参加では完成しない可能性があります。ご自身の作り途中の作品や、材料の持ち込みも可です！'
                  : '',
              placeholder: 'あとからでも記入できます。当日に相談でも大丈夫！',
              value: workInProgress || '',
            })}
            ${Components.createTextArea({
              id: 'material-input',
              label: '材料のサイズや樹種の希望',
              caption:
                'ご希望があればご記入ください。大体でも大丈夫！作れる大きさは 【豆粒】〜【手のひら】くらい',
              placeholder:
                '例：30×30×40mmくらい」「高さが6cmくらい」「たまごぐらい」 など',
              value: materialInfo || '',
            })}
          </div>
          <div class="mt-4 pt-4 border-t space-y-4">
            ${salesChecklistHtml}
            ${Components.createTextArea({ id: 'order-input', label: '購入希望（自由記入）', placeholder: '（任意）例：彫刻刀セット、テキスト', value: order || '' })}
            ${Components.createTextArea({ id: 'message-input', label: 'その他の連絡事項や要望など', placeholder: '', value: messageToTeacher || '' })}
          </div>`;
    };
    // 予約送信時にチェックされた物販をorderに渡す処理を追加
    const _getSelectedSalesOrder = () => {
      const checked = Array.from(
        document.querySelectorAll('input[name="orderSales"]:checked'),
      );
      return checked.map(cb => cb.value).join(', ');
    };

    // 送信ボタンのクリック時にorder値をセット
    setTimeout(() => {
      const submitBtn = document.querySelector(
        '[data-action="confirmBooking"], [data-action="updateReservation"]',
      );
      if (submitBtn) {
        submitBtn.addEventListener('click', () => {
          const selectedOrder = _getSelectedSalesOrder();
          const orderInput = document.getElementById('order-input');
          if (orderInput) {
            // 既存の自由記入とチェックリストを合成
            const freeText = orderInput.value.trim();
            orderInput.value = selectedOrder
              ? freeText
                ? selectedOrder + ', ' + freeText
                : selectedOrder
              : freeText;
          }
        });
      }
    }, 300);

    // --- 4. メインHTMLの組み立て ---
    let buttonsHtml = `
        ${Components.createButton({ text: submitButtonText, action: submitAction, colorClass: DesignConfig.colors.primary, widthClass: DesignConfig.buttons.full })}
      `;
    // 編集時のみキャンセルボタンを追加
    if (isEdit) {
      buttonsHtml += Components.createButton({
        text: 'この予約をキャンセルする',
        action: 'cancel',
        colorClass: DesignConfig.colors.danger,
        widthClass: DesignConfig.buttons.full,
        reservationId: sourceData.reservationId, // キャンセルに必要な情報を付与
        classroom: sourceData.classroom,
        date: sourceData.date,
        sheetName: sourceData.sheetName,
      });
    }
    // 戻るボタン：編集時はホームへ、新規作成時は予約一覧へ
    buttonsHtml += Components.createButton({
      text: '戻る',
      action: isEdit ? 'goBackToDashboard' : 'goBackToBooking',
      colorClass: DesignConfig.colors.secondary,
      widthClass: DesignConfig.buttons.full,
    });

    const venueDisplay = venue ? ` ${venue}` : '';

    const _renderOpeningHoursHtml = () => {
      const times = getClassroomTimesFromSchedule(sourceData);

      if (!times || !times.firstStart || !times.firstEnd) {
        return '<span class="text-ui-error-text">開講時間未設定</span>';
      }

      if (times.secondStart && times.secondEnd) {
        // 2部制の場合
        return `${times.firstStart} ~ ${times.firstEnd} , ${times.secondStart} ~ ${times.secondEnd}`;
      } else {
        // 1部制の場合
        return `${times.firstStart} ~ ${times.firstEnd}`;
      }
    };

    // --- Main View Assembly ---
    return `
        <h1 class="text-xl font-bold ${DesignConfig.colors.text} mb-4">${title}</h1>
        <div class="space-y-4 text-left p-4 ${DesignConfig.cards.background} rounded-lg">
          <p><span class="font-bold w-20 inline-block">お名前:</span> ${currentUser.displayName}さん</p>
          <p><span class="font-bold w-20 inline-block">教室:</span> ${classroom}${venueDisplay}</p>
          <p><span class="font-bold w-20 inline-block">日付:</span> ${formatDate(date)}</p>
          <p><span class="font-bold w-20 inline-block">状況:</span> ${_renderStatusHtml()}</p>
          <p><span class="font-bold w-20 inline-block">開講時間:</span> ${_renderOpeningHoursHtml()}</p>
          ${_renderTuitionDisplaySection()}
          ${_renderTimeOptionsSection()}
          ${_renderBookingOptionsSection()}
          ${_renderDetailsInputSection()}
        </div>
        <div class="mt-8 flex flex-col space-y-3">
          ${buttonsHtml}
        </div>`;
  };

  /**
   * 完了画面のUIを生成します。
   * @param {string} msg - 表示するメッセージ
   * @returns {string} HTML文字列
   */
  const getCompleteView = msg => {
    // 教室情報を取得（会計処理時は accountingReservation から、予約作成時は selectedSlot から）
    const classroom =
      stateManager.getState().accountingReservation?.classroom ||
      stateManager.getState().selectedSlot?.classroom;

    // 初回予約者かどうかを判定
    const wasFirstTimeBooking =
      stateManager.getState().wasFirstTimeBooking || false;
    const currentUser = stateManager.getState().currentUser;
    const studentHasEmail = currentUser && currentUser.email;
    const emailPreference = currentUser && currentUser.wantsEmail;

    // メール送信に関する案内メッセージ
    let emailNoticeHtml = '';
    if (wasFirstTimeBooking) {
      emailNoticeHtml = `
          <div class="bg-ui-info-bg border border-ui-info-border rounded-lg p-4 mt-4">
            <div class="flex items-start">
              <svg class="flex-shrink-0 h-5 w-5 text-ui-info-text mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"/>
                <path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"/>
              </svg>
              <div class="ml-3">
                <h3 class="text-sm font-medium text-ui-info-text">予約受付完了のメールをお送りしました！</h3>
                <p class="mt-1 text-sm text-ui-info-text">
                  会場の住所や駐車場情報なども記載しています。メールが届かない場合は、迷惑メールフォルダもご確認ください。<br>
                  予約の確認やキャンセルは、このページ（Webアプリ上）でおこなえます<br>
                  <br>
                  送信元アドレス: shiawasenehito3000@gmail.com
                </p>
              </div>
            </div>
          </div>
        `;
    } else if (studentHasEmail && emailPreference) {
      emailNoticeHtml = `
          <div class="bg-ui-surface rounded-lg p-3 mt-4">
            <p class="text-sm text-brand-subtle text-center">
            予約受付完了のメールをお送りしました！<br>
            （会場の住所や駐車場情報なども記載）<br>
            <br>
            送信元アドレス: shiawasenehito3000@gmail.com
          </p>
          </div>
        `;
    }

    let nextBookingHtml = '';

    // 該当教室の未来の予約枠が存在する場合
    if (classroom && stateManager.getState().slots) {
      // バックエンドで計算済みの空き情報を直接使用
      const relevantSlots = stateManager
        .getState()
        .slots.filter(slot => slot.classroom === classroom);
      const bookingSlotsHtml = renderBookingSlots(relevantSlots);

      if (bookingSlotsHtml) {
        nextBookingHtml = `
            <div class="mt-10 pt-6 border-t border-gray-200">
                <h3 class="text-xl font-bold text-brand-text text-center mb-4">次回の予約</h3>
                <div class="${DesignConfig.cards.container}">
                ${bookingSlotsHtml}
                </div>
            </div>`;
      }
    }

    return `
      <div class="text-center py-8">
          <svg class="w-16 h-16 mx-auto text-state-available-text" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          <h1 class="text-2xl font-bold ${DesignConfig.colors.text} mt-4 mb-2">ありがとうございました</h1>
          <p class="${DesignConfig.colors.textSubtle} mb-6">${msg}</p>

          ${emailNoticeHtml}

          ${nextBookingHtml}

          <div class="max-w-xs mx-auto mt-8">
               ${Components.createButton({
                 text: 'ホームへ戻る',
                 action: 'goToDashboard',
                 colorClass: DesignConfig.colors.secondary,
                 widthClass: DesignConfig.buttons.full,
               })}
          </div>
      </div>`;
  };

  /**
   * 会計画面のUIを生成します。
   * @returns {string} HTML文字列
   */
  const getAccountingView = () => {
    // 基本データの確認
    const state = stateManager.getState();

    // デバッグ情報を表示（開発環境のみ）
    if (!window.isProduction) {
      console.log('🔍 会計画面デバッグ情報:', {
        accountingMaster: !!state.accountingMaster,
        accountingReservation: !!state.accountingReservation,
        accountingReservationDetails: !!state.accountingReservationDetails,
        accountingScheduleInfo: !!state.accountingScheduleInfo,
        // より詳細な情報
        masterLength: state.accountingMaster ? state.accountingMaster.length : 0,
        reservationId: state.accountingReservation
          ? state.accountingReservation.reservationId
          : 'なし',
        reservationDetailsKeys: state.accountingReservationDetails
          ? Object.keys(state.accountingReservationDetails)
          : [],
        scheduleInfoType: state.accountingScheduleInfo
          ? state.accountingScheduleInfo.classroomType
          : 'なし',
      });
    }

    // 最低限必要なデータの確認
    if (!state.accountingMaster || !state.accountingReservation) {
      return '<div class="flex justify-center items-center h-full"><div class="spinner"></div><p class="ml-3 text-brand-text">会計データを読み込んでいます...</p></div>';
    }

    const reservation = state.accountingReservation;
    const master = state.accountingMaster;
    const reservationDetails = state.accountingReservationDetails || {};
    const scheduleInfo = state.accountingScheduleInfo || null;

    // データが不完全な場合のエラー処理
    if (!reservationDetails || Object.keys(reservationDetails).length === 0) {
      console.warn('⚠️ reservationDetailsが空です');
    }

    if (!scheduleInfo) {
      console.warn('⚠️ scheduleInfoがnullです');
    }
    // 【修正】統一検索関数を使用してよやく・きろく両方から検索
    const bookingOrRecord = findReservationById(reservation.reservationId, state);
    if (!bookingOrRecord) {
      return `
          <div class="text-center py-8">
            <p class="text-red-600">予約・記録情報が見つかりませんでした</p>
            <button onclick="handleAction('goBackToDashboard')"
                    class="mt-4 px-6 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
              戻る
            </button>
          </div>
        `;
    }

    // 会計済みの場合 - 完全分離（編集モードでない場合のみ）
    if (
      bookingOrRecord.status === STATUS.COMPLETED &&
      bookingOrRecord.accountingDetails &&
      !state.isEditingAccountingRecord
    ) {
      try {
        const details = JSON.parse(bookingOrRecord.accountingDetails);
        return `
            ${Components.accountingCompleted({ details, reservation })}
            <div class="mt-8 flex flex-col space-y-3">
              ${Components.createButton({
                text: '戻る',
                action: 'goBackToDashboard',
                colorClass: DesignConfig.colors.secondary,
                widthClass: DesignConfig.buttons.full,
              })}
            </div>`;
      } catch (e) {
        return '<div class="text-center text-state-danger-text">会計詳細の表示に失敗しました。</div>';
      }
    }

    // 新規会計フォーム - 条件分岐の簡素化
    const tuitionItemRule = getTuitionItemRule(
      master,
      reservation.classroom,
      C.items.MAIN_LECTURE,
    );
    const isTimeBased =
      tuitionItemRule && tuitionItemRule['単位'] === C.units.THIRTY_MIN;
    const formType = isTimeBased ? 'timeBased' : 'fixed';

    return `
        ${Components.navigationHeader({ title: '会計', backAction: 'goBackToDashboard' })}
        ${Components.accountingForm({
          type: formType,
          master,
          reservation,
          reservationDetails,
          scheduleInfo,
        })}
        <div class="mt-8 flex flex-col space-y-3">
          ${Components.createButton({
            text: '戻る',
            action: 'goBackToDashboard',
            colorClass: DesignConfig.colors.secondary,
            widthClass: DesignConfig.buttons.full,
          })}
        </div>`;
  };


  // =================================================================
  // 14_WebApp_Handlers.js (自動統合)
  // =================================================================

  // @ts-check
  /// <reference path="../types.d.ts" />

  /**
   * =================================================================
   * 【ファイル名】: 14_WebApp_Handlers.js
   * 【バージョン】: 1.6
   * 【役割】: WebAppのフロントエンドにおける、ユーザーの操作に応じた
   * アクションと、アプリケーション全体の制御フローを集約します。
   * 【構成】: 14ファイル構成のうちの14番目
   * 【v1.6での変更点】:
   * - FE-14: 会計入力のキャッシュ機能を追加。
   *   - localStorageへの保存、読み込み、削除処理を実装。
   *   - 画面遷移、保存、キャンセル時にキャッシュを適切に操作するよう修正。
   * =================================================================
   */

  // =================================================================
  // --- Time Data Helper Functions ---
  // -----------------------------------------------------------------
  // 時刻データの取得・処理を行うヘルパー関数群
  // =================================================================

  /**
   * 時刻データを適切に取得するヘルパー関数
   * @param {string} elementId - 時刻入力要素のID
   * @param {object} reservationData - 予約データ（フォールバック用）
   * @param {string} timeField - 時刻フィールド名（'startTime' or 'endTime'）
   * @returns {string} 時刻文字列（HH:mm形式）
   */
  function getTimeValue(elementId, reservationData, timeField) {
    // 1. HTML要素から取得を試行
    const elementValue = document.getElementById(elementId)?.value;
    if (elementValue && elementValue !== '') {
      return elementValue;
    }

    // 2. 予約データから取得を試行（編集時）
    if (reservationData) {
      const headerField =
        window.HEADERS?.RESERVATIONS?.[timeField.toUpperCase()] || timeField;
      const timeValue =
        reservationData[headerField] || reservationData[timeField];
      if (timeValue && timeValue !== '') {
        return timeValue;
      }
    }

    // 3. selectedSlotから取得を試行（新規作成時）
    const selectedSlot = stateManager.getState().selectedSlot;
    if (selectedSlot) {
      const headerField =
        window.HEADERS?.RESERVATIONS?.[timeField.toUpperCase()] || timeField;

      // セッション制教室の場合、スケジュール情報から取得
      if (selectedSlot.classroomType === C.classroomTypes.SESSION_BASED) {
        if (timeField === 'startTime') {
          return selectedSlot.firstStart || selectedSlot.secondStart || '';
        } else if (timeField === 'endTime') {
          return selectedSlot.firstEnd || selectedSlot.secondEnd || '';
        }
      }

      // 時間制教室の場合、selectedSlotから取得
      const slotValue = selectedSlot[headerField] || selectedSlot[timeField];
      if (slotValue && slotValue !== '') {
        return slotValue;
      }
    }

    return '';
  }

  // =================================================================
  // --- Accounting Cache Helper Functions (FE-14) ---
  // -----------------------------------------------------------------
  // 会計フォームのデータを操作するためのヘルパー関数群
  // =================================================================

  /**
   * 会計フォームから現在の入力内容をオブジェクトとして取得します。
   * @returns {object} フォームデータ
   */
  function getAccountingFormData() {
    const form = document.getElementById('accounting-form');
    if (!form) return {};

    const data = {};
    const elements = form.elements;

    for (let i = 0; i < elements.length; i++) {
      const item = elements[i];
      if (item.name) {
        if (item.type === 'checkbox') {
          data[item.name] = item.checked;
        } else if (item.type === 'radio') {
          if (item.checked) {
            data[item.name] = item.value;
          }
        } else {
          data[item.name] = item.value;
        }
      }
    }
    return data;
  }

  // =================================================================
  // --- Action Handlers ---
  // -----------------------------------------------------------------
  // ユーザーの操作（ボタンクリックなど）を起点として実行される
  // 全ての処理を定義するオブジェクトです。
  // 各キーが data-action 属性に対応します。
  // =================================================================
  const actionHandlers = {
    /** スマートナビゲーション: 前の画面に戻る */
    smartGoBack: () => {
      const backState = stateManager.goBack();
      stateManager.dispatch({
        type: 'SET_STATE',
        payload: backState,
      });
    },

    /** ログインまたは新規登録を開始します（キャッシュ活用版） */
    login: () => {
      const p = document.getElementById('phone').value;
      // 入力値をsetState経由で保存
      window.stateManager.dispatch({
        type: 'UPDATE_STATE',
        payload: { loginPhone: p },
      });
      if (!p) return showInfo('電話番号を入力してください。');

      // フロントエンドで電話番号を正規化（即時エラー表示）
      const normalizeResult = window.normalizePhoneNumberFrontend(p);

      if (!normalizeResult.isValid) {
        showInfo(normalizeResult.error || '電話番号の形式が正しくありません。');
        return;
      }

      showLoading('login');
      // 正規化に成功した場合は直接ログイン処理を実行（1回のAPI呼び出し）
      actionHandlers.processLoginWithValidatedPhone(normalizeResult.normalized);
    },

    /** 検証済み電話番号でのログイン処理 */
    processLoginWithValidatedPhone: normalizedPhone => {
      // 環境分岐: テスト環境の場合はモックデータを使用

      // 本番環境: 統合エンドポイントで初期データと空席情報を一括取得
      google.script.run
        .withSuccessHandler(response => {
          // ← この response には、サーバーサイドの getLoginData 関数の戻り値が格納されます。

          // デバッグ情報を画面に表示（本番環境では無効化）
          if (!window.isProduction) {
            debugLog('初期データ取得完了');
            debugLog('response.success: ' + response.success);
            debugLog('response.userFound: ' + response.userFound);
            debugLog(
              'response.availableSlots: ' +
                (response.availableSlots
                  ? response.availableSlots.length + '件'
                  : 'null/undefined'),
            );
            debugLog(
              'response.data: ' + (response.data ? 'あり' : 'null/undefined'),
            );
          }

          if (response.success && response.userFound) {
            // ユーザーが見つかった場合：クライアントサイド処理で状態構築
            const newAppState = processInitialData(
              response.data,
              normalizedPhone,
              response.availableSlots,
              response.data.userReservations,
            );
            debugLog(
              'processInitialData完了 - slots: ' +
                (newAppState.slots ? newAppState.slots.length + '件' : 'null'),
            );
            debugLog(
              'processInitialData完了 - classrooms: ' +
                JSON.stringify(newAppState.classrooms),
            );

            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                ...newAppState,
                // サーバーから取得した定数を使って、表示する履歴の初期件数を設定
                recordsToShow:
                  newAppState.constants?.ui?.HISTORY_INITIAL_RECORDS || 10,
                isDataFresh: true,
              },
            });
          } else {
            // ユーザーが見つからない場合または特別コマンド認識時の分岐処理
            if (response.commandRecognized) {
              // 特殊コマンドが認識された場合はuserSearch画面に遷移
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  view: 'userSearch',
                  searchedUsers: [],
                  selectedSearchedUser: null,
                  searchAttempted: false,
                },
              });
            } else {
              // 通常のユーザー未登録の場合は新規登録画面に遷移
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  view: 'register',
                  registrationPhone: normalizedPhone,
                },
              });
            }
          }
        })
        .withFailureHandler(err => {
          hideLoading();
          if (!window.isProduction) {
            debugLog('初期データ取得エラー: ' + err.message);
          }
          handleServerError(err);
        })
        .getLoginData(normalizedPhone);
    },

    /** 新しいログインフロー（メインのloginに統合済み） */

    /** 新規ユーザー登録：Step1からStep2へ */
    goToStep2: () => {
      const realName = document.getElementById('reg-realname').value;
      const nickname = document.getElementById('reg-nickname').value.trim();
      const phone = document.getElementById('reg-phone').value;

      if (!realName) return showInfo('お名前（本名）は必須です。');

      // フロントエンドで電話番号を正規化・バリデーション
      if (phone) {
        const normalizeResult = window.normalizePhoneNumberFrontend(phone);
        if (!normalizeResult.isValid) {
          showInfo(normalizeResult.error || '電話番号の形式が正しくありません。');
          return;
        }
      }

      // 入力値をsetState経由で保存
      const updatedRegistrationData = {
        ...stateManager.getState().registrationData,
        phone,
        realName,
        nickname: nickname || realName,
      };
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: {
          registrationData: updatedRegistrationData,
          registrationStep: 2,
          view: 'registrationStep2',
        },
      });
    },

    /** 新規ユーザー登録：Step2からStep1へ戻る */
    backToStep1: () => {
      const realName = document.getElementById('reg-realname')?.value;
      const nickname = document.getElementById('reg-nickname')?.value;
      const phone = document.getElementById('reg-phone')?.value;
      if (realName || nickname || phone) {
        const updatedRegistrationData = {
          ...stateManager.getState().registrationData,
          realName:
            realName || stateManager.getState().registrationData?.realName || '',
          nickname:
            nickname || stateManager.getState().registrationData?.nickname || '',
          phone: phone || stateManager.getState().registrationData?.phone || '',
        };
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: { registrationData: updatedRegistrationData },
        });
      }
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: { view: 'register', registrationStep: 1 },
      });
    },

    /** 新規ユーザー登録：Step2からStep3へ進む */
    goToStep3: () => {
      const email = document.getElementById('q-email').value;
      if (!email || !email.includes('@')) {
        return showInfo('有効なメールアドレスを入力してください。');
      }

      const step2Data = {
        email: email,
        wantsEmail: document.getElementById('q-wants-email').checked,
        ageGroup: document.getElementById('q-age-group').value,
        gender:
          document.querySelector('input[name="gender"]:checked')?.value || '',
        dominantHand:
          document.querySelector('input[name="dominantHand"]:checked')?.value ||
          '',
        address: document.getElementById('q-address').value,
      };

      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: {
          registrationData: {
            ...stateManager.getState().registrationData,
            ...step2Data,
          },
          registrationStep: 3,
          view: 'registrationStep3',
        },
      });
    },

    /** 新規ユーザー登録：Step3からStep2へ戻る */
    backToStep2: () =>
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: { view: 'registrationStep2', registrationStep: 2 },
      }),

    /** 新規ユーザー登録：Step3からStep4へ進む */
    proceedToStep4: () => {
      const step3Data = {
        experience:
          document.querySelector('input[name="experience"]:checked')?.value || '',
        pastWork: document.getElementById('q-past-work').value,
        futureGoal: document.getElementById('q-future-goal').value,
      };
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: {
          registrationData: {
            ...stateManager.getState().registrationData,
            ...step3Data,
          },
          registrationStep: 4,
          view: 'registrationStep4',
        },
      });
    },

    /** 新規ユーザー登録：Step4からStep3へ戻る */
    backToStep3: () =>
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: { view: 'registrationStep3', registrationStep: 3 },
      }),

    /** 新規ユーザー登録：最終データをサーバーに送信（バッチ処理版） */
    submitRegistration: () => {
      const step4Data = {
        futureParticipation:
          document.querySelector('input[name="futureParticipation"]:checked')
            ?.value || '',
        trigger: document.getElementById('q-trigger').value,
        firstMessage: document.getElementById('q-first-message').value,
      };

      const finalUserData = {
        ...stateManager.getState().registrationData,
        ...step4Data,
      };

      showLoading('login');
      google.script.run
        .withSuccessHandler(res => {
          if (res.success) {
            // 登録後、バッチ処理で初期データと空席情報を一括取得
            google.script.run
              .withSuccessHandler(batchResult => {
                if (batchResult.success) {
                  const newAppState = processInitialData(
                    batchResult.data.initial,
                    res.user.phone,
                    batchResult.data.slots,
                  );

                  window.stateManager.dispatch({
                    type: 'SET_STATE',
                    payload: {
                      ...newAppState,
                      currentUser: res.user,
                      view: 'dashboard',
                    },
                  });
                  hideLoading();
                } else {
                  hideLoading();
                  showInfo(
                    batchResult.message || 'データの取得に失敗しました',
                    'エラー',
                  );
                }
              })
              .withFailureHandler(handleServerError)
              .getBatchData(['initial', 'slots'], res.user.phone);
          } else {
            hideLoading();
            showInfo(res.message || '登録に失敗しました');
          }
        })
        .withFailureHandler(handleServerError)
        .registerNewUser(finalUserData);
    },

    /** きろくカードの編集ボタン（キャッシュ活用版） */
    editHistoryMemo: d => {
      const item = stateManager
        .getState()
        .history.find(h => h.reservationId === d.reservationId);
      if (!item) return;

      const originalMemo = item.workInProgress;

      showConfirm({
        title: '制作メモの編集',
        message: buildMemoEditModal(item),
        confirmText:
          window.stateManager.getState().constants?.messages?.SAVE || '保存する',
        cancelText:
          window.stateManager.getState().constants?.messages?.CANCEL ||
          'キャンセル',
        confirmColorClass: DesignConfig.colors.primary,
        onConfirm: () => {
          const newMemo = document.getElementById('memo-edit-textarea').value;

          // 楽観的UI: まずフロントの表示を更新（イミュータブル更新）
          const state = window.stateManager.getState();
          const newHistory = state.history.map(h => {
            if (h.reservationId === d.reservationId) {
              return { ...h, workInProgress: newMemo };
            }
            return h;
          });
          window.stateManager.dispatch({
            type: 'UPDATE_STATE',
            payload: { history: newHistory },
          });

          showLoading();

          // サーバーに保存（統合予約シート更新 + キャッシュ再構築 + 最新データ取得）
          google.script.run
            .withSuccessHandler(r => {
              hideLoading();
              if (r.success) {
                showInfo('制作メモを更新しました。', '保存完了');
                // 他の操作と同様に最新データで状態を更新
                if (r.data) {
                  window.stateManager.dispatch({
                    type: 'SET_STATE',
                    payload: {
                      ...r.data.initialData,
                      myBookings: r.data.myBookings || [],
                      history: r.data.initialData.myHistory || [],
                      historyTotal: (r.data.initialData.myHistory || []).length,
                      isDataFresh: true, // 最新データ受信済み
                    },
                  });
                  // 明示的に画面を再描画
                  if (typeof window.render === 'function') {
                    setTimeout(() => window.render(), 100);
                  }
                } else {
                  // データなしの場合は最新データを強制取得
                  updateAppStateFromCache(window.stateManager.getState().view);
                }
              } else {
                // サーバーエラーの場合は元に戻す（イミュータブル更新）
                const errorState = window.stateManager.getState();
                const revertedHistory = errorState.history.map(h => {
                  if (h.reservationId === d.reservationId) {
                    return { ...h, workInProgress: originalMemo };
                  }
                  return h;
                });
                window.stateManager.dispatch({
                  type: 'SET_STATE',
                  payload: { history: revertedHistory },
                });
                showInfo(r.message || 'メモの保存に失敗しました。', 'エラー');
              }
            })
            .withFailureHandler(err => {
              hideLoading();
              // 通信エラーの場合は元に戻す（イミュータブル更新）
              const failureState = window.stateManager.getState();
              const failureRevertedHistory = failureState.history.map(h => {
                if (h.reservationId === d.reservationId) {
                  return { ...h, workInProgress: originalMemo };
                }
                return h;
              });
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: { history: failureRevertedHistory },
              });
              handleServerError(err);
            })
            .updateReservationMemoAndGetLatestData(
              d.reservationId,
              stateManager.getState().currentUser.studentId,
              newMemo,
            );
        },
      });
    },

    /** プロフィール情報を保存します（キャッシュ活用版） */
    saveProfile: () => {
      const r = document.getElementById('edit-realname').value;
      let n = document.getElementById('edit-nickname').value.trim();
      if (!r) return showInfo('お名前（本名）は必須です。');
      if (!n) n = r;

      // NF-01: 電話番号入力欄があればその値も取得
      const phoneInput = document.getElementById('edit-phone');
      const phone = phoneInput
        ? phoneInput.value
        : stateManager.getState().currentUser.phone; // 電話番号入力欄がなければ既存の電話番号を使用

      // メール情報の取得
      const emailInput = document.getElementById('edit-email');
      const wantsEmailInput = document.getElementById('edit-wants-email');
      const email = emailInput
        ? emailInput.value
        : stateManager.getState().currentUser.email;
      const wantsEmail = wantsEmailInput
        ? wantsEmailInput.checked
        : stateManager.getState().currentUser.wantsEmail;

      const u = {
        ...stateManager.getState().currentUser,
        realName: r,
        displayName: n,
        phone: phone,
        email: email || '',
        wantsEmail: wantsEmail || false,
      };
      showLoading();
      google.script.run
        .withSuccessHandler(res => {
          hideLoading();
          if (res.success) {
            // プロフィール更新後、キャッシュも更新されているのでそのまま状態更新
            showInfo('プロフィールを更新しました', '更新完了');
            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: { currentUser: res.updatedUser, view: 'dashboard' },
            });
          } else {
            showInfo(res.message || '更新に失敗しました');
          }
        })
        .withFailureHandler(handleServerError)
        .updateUserProfile(u);
    },

    /**
     * NF-01: 電話番号未登録ユーザーの検索を実行します（キャッシュ活用版）。
     */
    searchUserByName: () => {
      const searchInput = document.getElementById('nickname-search-input');
      const searchTerm = searchInput ? searchInput.value.trim() : ''; // 検索語をsearchTermに変更

      if (!searchTerm) {
        return showInfo('お名前（本名）またはニックネームを入力してください。');
      }

      showLoading('login');

      // 検索語からスペースを除去して小文字化して比較に使う
      const normalizedSearchTerm = searchTerm.replace(/\s+/g, '').toLowerCase();

      google.script.run
        .withSuccessHandler(response => {
          hideLoading();
          if (response.success) {
            // 【統一レスポンス形式】データ構造の修正
            // searchName (スペース除去済み・小文字化された結合名) を使ってフィルタリング
            const filteredUsers = response.data.filter(
              user =>
                user.searchName && user.searchName.includes(normalizedSearchTerm),
            );

            // NF-01: 検索が試行されたことを示すフラグをセット
            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: { searchedUsers: filteredUsers, searchAttempted: true },
            });

            if (filteredUsers.length === 0) {
              // アカウントが見つからなかった場合のメッセージはビュー側で表示
            }
          } else {
            showInfo(response.message || 'ユーザー検索に失敗しました。');
          }
        })
        .withFailureHandler(handleServerError)
        .searchUsersWithoutPhone(searchTerm);
    },

    /**
     * NF-01: 検索結果から電話番号未登録ユーザーを選択します（バッチ処理版）。
     */
    selectSearchedUser: d => {
      // ボタンに埋め込まれたデータから、まず仮のユーザー情報を作成
      const tempUser = {
        studentId: d.studentId,
        realName: d.realName, // ボタンのdata属性から取得
        displayName: d.nickname, // ボタンのdata属性から取得
        phone: '', // 電話番号はまだないので空
      };

      showLoading('login');

      // バッチ処理で初期データ、空席情報、ユーザーデータを一括取得
      google.script.run
        .withSuccessHandler(response => {
          if (response.success) {
            // tempUserの情報でcurrentUserを上書きしつつ、キャッシュデータを活用
            const userFromCache =
              response.data.initial.allStudents[tempUser.studentId];
            const finalUser = userFromCache
              ? {
                  ...userFromCache,
                  displayName: tempUser.displayName,
                  phone: tempUser.phone,
                }
              : tempUser;

            // 個人予約データはバックエンドから取得済み
            const { myBookings, myHistory } = response.data.userReservations || {
              myBookings: [],
              myHistory: [],
            };
            const today = response.data.initial.today;

            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                currentUser: finalUser,
                slots: response.data.slots,
                myBookings: myBookings,
                accountingMaster: response.data.initial.accountingMaster,
                history: myHistory,
                historyTotal: myHistory.length,
                recordsToShow: 10, // UI.HISTORY_INITIAL_RECORDSで後で更新
                view: 'editProfile', // 電話番号登録を促すためプロフィール編集画面へ
                today: today,
                _allStudents: response.data.initial.allStudents,
                _cacheVersions: response.data.initial.cacheVersions,
              },
            });
          } else {
            hideLoading();
            showInfo(response.message || 'データの読み込みに失敗しました。');
          }
        })
        .withFailureHandler(handleServerError)
        .getBatchData(
          ['initial', 'slots', 'reservations'],
          null,
          tempUser.studentId,
        );
    },

    /**
     * NF-01: 自分のアカウントが見つからなかった場合に新規登録画面へ遷移します。
     */
    goToRegisterFromUserSearch: () => {
      // 新規登録画面へ遷移。電話番号は未入力のまま。
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: { view: 'register', registrationPhone: '' },
      });
    },

    /** 予約をキャンセルします */
    cancel: d => {
      const message = `
          <div class="text-left space-y-4">
            <p class="text-center"><b>${formatDate(d.date)}</b><br>${d.classroom}<br>この予約を取り消しますか？</p>
            <div class="pt-4 border-t">
              <label class="block text-sm font-bold mb-2">先生へのメッセージ（任意）</label>
              <textarea id="cancel-message" class="w-full p-2 border border-ui-border rounded" rows="3" placeholder=""></textarea>
            </div>
          </div>
        `;
      showConfirm({
        title: '予約の取り消し',
        message: message,
        confirmText: 'はい　取り消します',
        cancelText: 'いいえ',
        confirmColorClass: DesignConfig.colors.danger,
        onConfirm: () => {
          showLoading('cancel');
          const cancelMessage =
            document.getElementById('cancel-message')?.value || '';
          const p = {
            ...d,
            studentId: stateManager.getState().currentUser.studentId,
            cancelMessage: cancelMessage,
          };
          google.script.run
            .withSuccessHandler(r => {
              hideLoading();
              if (r.success) {
                if (r.data) {
                  window.stateManager.dispatch({
                    type: 'SET_STATE',
                    payload: {
                      ...r.data.initialData,
                      myBookings: r.data.myBookings || [],
                      history: r.data.initialData.myHistory || [],
                      historyTotal: (r.data.initialData.myHistory || []).length,
                      slots: r.data.slots || [],
                      view: 'dashboard',
                      isDataFresh: true, // 最新データ受信済み
                    },
                  });
                } else {
                  window.stateManager.dispatch({
                    type: 'SET_STATE',
                    payload: {
                      view: 'dashboard',
                      isDataFresh: false, // 再読み込み必要
                    },
                  });
                }
                showInfo(r.message || '予約を取り消しました。', 'キャンセル完了');
              } else {
                showInfo(r.message || 'キャンセル処理に失敗しました。');
              }
            })
            .withFailureHandler(err => {
              // エラー時は画面を更新せず、元の状態を維持
              handleServerError(err);
            })
            .cancelReservationAndGetLatestData(p);
        },
      });
    },

    /** 予約を確定します */
    confirmBooking: () => {
      // 初回の自動判定
      // isFirstTimeBooking を stateManager から取得
      const isFirstTimeBooking = stateManager.getState().isFirstTimeBooking;

      // 現在見ている予約枠の時間情報を取得
      const selectedSlot = stateManager.getState().selectedSlot;

      // 教室形式に応じて時間を設定（ヘルパー関数使用）
      const startTime = getTimeValue('res-start-time', null, 'startTime');
      const endTime = getTimeValue('res-end-time', null, 'endTime');

      // デバッグ用ログ
      if (selectedSlot?.classroomType === C.classroomTypes.SESSION_BASED) {
        console.log(`[セッション制] 時間設定: ${startTime} - ${endTime}`);
      } else {
        console.log(`[時間制] 時間設定: ${startTime} - ${endTime}`);
      }

      const bookingOptions = {
        chiselRental: document.getElementById('option-rental')?.checked || false,
        firstLecture:
          document.getElementById('option-first-lecture')?.checked ||
          isFirstTimeBooking, // 自動設定
        workInProgress: document.getElementById('wip-input')?.value || '',
        order: document.getElementById('order-input')?.value || '',
        messageToTeacher: document.getElementById('message-input')?.value || '',
        materialInfo: document.getElementById('material-input')?.value || '',
      };

      showLoading('booking');

      const p = {
        ...selectedSlot,
        // 時間情報を上書き（教室形式に応じて調整済み）
        startTime: startTime,
        endTime: endTime,
        // バックエンドとの互換性のため、ヘッダー形式も併記
        [window.HEADERS?.RESERVATIONS?.START_TIME || 'startTime']: startTime,
        [window.HEADERS?.RESERVATIONS?.END_TIME || 'endTime']: endTime,
        user: stateManager.getState().currentUser,
        studentId: stateManager.getState().currentUser.studentId,
        options: bookingOptions,
      };

      google.script.run
        .withSuccessHandler(r => {
          hideLoading();
          if (r.success) {
            if (r.data) {
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  ...r.data.initialData,
                  myBookings: r.data.myBookings || [],
                  history: r.data.initialData.myHistory || [],
                  historyTotal: (r.data.initialData.myHistory || []).length,
                  slots: r.data.slots || [],
                  view: 'complete',
                  completionMessage: r.message,
                  isDataFresh: true, // 最新データ受信済み
                },
              });
            } else {
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  view: 'complete',
                  completionMessage: r.message,
                  isDataFresh: false, // 再読み込み必要
                },
              });
            }
          } else {
            showInfo(r.message || '予約に失敗しました。');
          }
        })
        .withFailureHandler(handleServerError)
        .makeReservationAndGetLatestData(p);
    },

    /** 予約編集画面に遷移します（予約データはキャッシュから取得済み） */
    goToEditReservation: d => {
      showLoading('dataFetch');
      // 予約データは既にキャッシュから取得済みなので、直接編集画面に遷移
      const reservation = stateManager
        .getState()
        .myBookings.find(
          booking =>
            booking.reservationId === d.reservationId &&
            booking.classroom === d.classroom,
        );

      if (reservation) {
        const editingDetails = {
          reservationId: reservation.reservationId,
          classroom: reservation.classroom,
          date: reservation.date,
          venue: reservation.venue,
          chiselRental: reservation.chiselRental || false,
          firstLecture: reservation.firstLecture || false,
          [window.HEADERS?.RESERVATIONS?.START_TIME || 'startTime']:
            reservation[window.HEADERS?.RESERVATIONS?.START_TIME] ||
            reservation.startTime ||
            '',
          [window.HEADERS?.RESERVATIONS?.END_TIME || 'endTime']:
            reservation[window.HEADERS?.RESERVATIONS?.END_TIME] ||
            reservation.endTime ||
            '',
          workInProgress: reservation.workInProgress || '',
          order: reservation.order || '',
          messageToTeacher: reservation.message || '',
          materialInfo: reservation.materialInfo || '',
        };

        // scheduleInfo取得完了後にビューを表示
        getScheduleInfoFromCache(
          editingDetails.date,
          editingDetails.classroom,
        ).then(scheduleInfo => {
          // editingReservationDetailsにscheduleInfo情報をマージ
          const enrichedDetails = {
            ...editingDetails,
            firstStart: scheduleInfo?.firstStart,
            firstEnd: scheduleInfo?.firstEnd,
            secondStart: scheduleInfo?.secondStart,
            secondEnd: scheduleInfo?.secondEnd,
            classroomType: scheduleInfo?.classroomType,
          };

          // スケジュール情報取得完了後にビューを表示
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              view: 'editReservation',
              editingReservationDetails: enrichedDetails,
            },
          });

          hideLoading();
        });
      } else {
        showInfo('予約情報が見つかりませんでした。');
      }
    },

    /** 予約情報を更新します */
    updateReservation: () => {
      const d = stateManager.getState().editingReservationDetails;
      const startTime = getTimeValue('res-start-time', d, 'startTime');
      const endTime = getTimeValue('res-end-time', d, 'endTime');

      const p = {
        reservationId: d.reservationId,
        classroom: d.classroom,
        studentId: stateManager.getState().currentUser.studentId,
        chiselRental: document.getElementById('option-rental')?.checked || false,
        firstLecture:
          document.getElementById('option-first-lecture')?.checked || false,
        startTime: startTime,
        endTime: endTime,
        // バックエンドとの互換性のため、ヘッダー形式も併記
        [window.HEADERS?.RESERVATIONS?.START_TIME || 'startTime']: startTime,
        [window.HEADERS?.RESERVATIONS?.END_TIME || 'endTime']: endTime,
        workInProgress: document.getElementById('wip-input').value,
        order: document.getElementById('order-input').value,
        messageToTeacher: document.getElementById('message-input').value,
        materialInfo: document.getElementById('material-input')?.value || '',
      };
      showLoading('booking');
      google.script.run
        .withSuccessHandler(r => {
          hideLoading();
          if (r.success) {
            if (r.data) {
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  ...r.data.initialData,
                  myBookings: r.data.myBookings || [],
                  history: r.data.initialData.myHistory || [],
                  historyTotal: (r.data.initialData.myHistory || []).length,
                  slots: r.data.slots || [],
                  view: 'dashboard',
                  isDataFresh: true, // 最新データ受信済み
                },
              });
            } else {
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  view: 'dashboard',
                  isDataFresh: false, // 再読み込み必要
                },
              });
            }
            showInfo(r.message || '予約内容を更新しました。', '更新完了');
          } else {
            showInfo(r.message || '更新に失敗しました。');
          }
        })
        .withFailureHandler(handleServerError)
        .updateReservationDetailsAndGetLatestData(p);
    },

    /** 会計画面に遷移します（予約データはキャッシュから取得済み） */
    goToAccounting: d => {
      showLoading('accounting');
      const reservationId = d.reservationId;

      // 【修正】統一検索関数を使用してよやく・きろく両方から検索
      const reservationData = findReservationById(reservationId);

      if (reservationData) {
        // 予約が有効な場合のみキャッシュを読み込み
        const cachedData = loadAccountingCache(reservationId);
        const baseDetails = {
          firstLecture: reservationData.firstLecture || false,
          chiselRental: reservationData.chiselRental || false,
          [window.HEADERS?.RESERVATIONS?.START_TIME || 'startTime']:
            reservationData[window.HEADERS?.RESERVATIONS?.START_TIME] ||
            reservationData.startTime ||
            null,
          [window.HEADERS?.RESERVATIONS?.END_TIME || 'endTime']:
            reservationData[window.HEADERS?.RESERVATIONS?.END_TIME] ||
            reservationData.endTime ||
            null,
        };

        // 予約固有情報（個人の予約詳細）
        const reservationDetails = { ...baseDetails, ...cachedData };

        // 講座固有情報を取得完了後に画面を表示
        getScheduleInfoFromCache(
          reservationData.date,
          reservationData.classroom,
        ).then(scheduleInfo => {
          // スケジュール情報取得完了後にビューを表示
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              view: 'accounting',
              accountingReservation: d,
              accountingReservationDetails: reservationDetails,
              accountingScheduleInfo: scheduleInfo,
            },
          });

          // ビュー遷移後に初期計算を実行（DOM構築完了を確実に待つ）
          setTimeout(() => {
            // 会計フォームのDOM構築完了を確認してから計算実行
            const form = document.getElementById('accounting-form');
            if (form) {
              calculateAccountingDetails(); // UI更新も含む統一関数を使用
            } else {
              // DOMがまだ構築されていない場合はもう少し待つ
              setTimeout(() => {
                calculateAccountingDetails(); // UI更新も含む統一関数を使用
              }, 100);
            }
          }, 300);
          hideLoading();
        });
      } else {
        hideLoading();
        showInfo('予約・記録情報が見つかりませんでした。');
      }
    },

    /** 履歴から会計詳細をモーダルで表示します（データはキャッシュから取得済み） */
    showHistoryAccounting: d => {
      const details = JSON.parse(d.details);
      const tuitionItemsHtml = details.tuition.items
        .map(i => `<li>${i.name}: ${i.price.toLocaleString()}円</li>`)
        .join('');
      const salesItemsHtml = details.sales.items
        .map(i => `<li>${i.name}: ${i.price.toLocaleString()}円</li>`)
        .join('');
      const message = `
              <div class="p-4 bg-brand-light rounded-lg text-left space-y-4 text-base">
                  ${tuitionItemsHtml ? `<b>授業料</b><ul class="list-disc list-inside">${tuitionItemsHtml}</ul>` : ''}
                  ${salesItemsHtml ? `<b class="mt-1 inline-block">販売</b><ul class="list-disc list-inside">${salesItemsHtml}</ul>` : ''}
                  <div class="font-bold mt-1 pt-1 border-t">合計: ${details.grandTotal.toLocaleString()}円</div><div class="text-right text-sm pt-1">支払方法: ${details.paymentMethod}</div></div>`;
      showInfo(message, '会計記録');
    },

    /** きろくカードから会計済み内容を修正します */
    editAccountingRecord: d => {
      const reservationId = d.reservationId;

      // きろくから対象の予約データを取得
      const reservationData = findReservationById(reservationId);

      if (!reservationData) {
        showInfo('予約・記録情報が見つかりませんでした。');
        return;
      }

      // 既存の会計データを初期値として設定
      const existingAccountingDetails = reservationData.accountingDetails || {};

      // 予約固有情報（個人の予約詳細）
      const reservationDetails = {
        firstLecture: reservationData.firstLecture || false,
        chiselRental: reservationData.chiselRental || false,
        [window.HEADERS?.RESERVATIONS?.START_TIME || 'startTime']:
          reservationData[window.HEADERS?.RESERVATIONS?.START_TIME] ||
          reservationData.startTime ||
          null,
        [window.HEADERS?.RESERVATIONS?.END_TIME || 'endTime']:
          reservationData[window.HEADERS?.RESERVATIONS?.END_TIME] ||
          reservationData.endTime ||
          null,
        // 既存の会計データをすべて反映
        ...existingAccountingDetails,
      };

      showConfirm({
        title: '会計内容の修正',
        message:
          'この操作により、現在の会計記録は削除され、新しい内容で再登録されます。よろしいですか？',
        confirmText: '修正する',
        cancelText:
          window.stateManager.getState().constants?.messages?.CANCEL ||
          'キャンセル',
        onConfirm: () => {
          // 講座固有情報を取得完了後に画面を表示
          getScheduleInfoFromCache(
            reservationData.date,
            reservationData.classroom,
          ).then(scheduleInfo => {
            // スケジュール情報取得完了後にビューを表示
            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                view: 'accounting',
                accountingReservation: d,
                accountingReservationDetails: reservationDetails,
                accountingScheduleInfo: scheduleInfo,
                isEditingAccountingRecord: true,
              },
            });

            // ビュー遷移後に初期計算を実行（DOM構築完了を確実に待つ）
            setTimeout(() => {
              // 会計フォームのDOM構築完了を確認してから計算実行
              const form = document.getElementById('accounting-form');
              if (form) {
                calculateAccountingDetails(); // UI更新も含む統一関数を使用
              } else {
                // DOMがまだ構築されていない場合はもう少し待つ
                setTimeout(() => {
                  calculateAccountingDetails(); // UI更新も含む統一関数を使用
                }, 100);
              }
            }, 300);
          });
        },
      });
    },

    /** 会計画面で材料入力行を追加します */
    addMaterialRow: () => {
      const container = document.getElementById('materials-container');
      const newIndex = container.querySelectorAll(
        'div[data-material-row-index]',
      ).length;
      const newRow = document.createElement('div');
      newRow.className = 'mt-4 pt-4 border-t border-ui-border-light';
      newRow.dataset.materialRowIndex = newIndex;
      newRow.innerHTML = Components.materialRow({ index: newIndex });
      container.appendChild(newRow);
    },

    /** 会計画面でその他販売品入力行を追加します */
    addOtherSalesRow: () => {
      const container = document.getElementById('other-sales-container');
      const newIndex = container.querySelectorAll(
        'div[data-other-sales-row]',
      ).length;
      // Components.otherSalesRowが返すHTML文字列を、ラッパーを介さず直接コンテナの末尾に追加する
      container.insertAdjacentHTML(
        'beforeend',
        Components.otherSalesRow({ index: newIndex }),
      );
    },

    /** 会計画面で合計金額をクリップボードにコピーします */
    copyGrandTotal: button => {
      const totalText =
        document.getElementById('grand-total-amount')?.textContent || '';
      const numericTotal = totalText.replace(/[^0-9-]/g, '');
      actionHandlers.copyToClipboard(button, numericTotal);
    },

    /** 指定されたテキストをクリップボードにコピーします */
    copyToClipboard: (button, text) => {
      const textToCopy = text || button.dataset.copyText;
      const textArea = document.createElement('textarea');
      textArea.style.position = 'fixed';
      textArea.style.top = '-9999px';
      textArea.style.left = '-9999px';
      textArea.value = textToCopy.replace(/,/g, '');
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      try {
        const successful = document.execCommand('copy');
        if (successful) {
          const originalText = button.textContent;
          button.textContent = 'コピーしました!';
          setTimeout(() => {
            button.textContent = originalText;
          }, 2000);
        } else {
          showInfo('コピーに失敗しました。');
        }
      } catch (err) {
        showInfo('コピーに失敗しました。');
        // エラーログは開発環境でのみ出力
        if (typeof console !== 'undefined' && console.error) {
          console.error('Clipboard copy failed:', err);
        }
      }
      document.body.removeChild(textArea);
    },

    /** 参加記録を追加で読み込みます（統合ホーム用） */
    loadMoreHistory: () => {
      const newCount =
        (stateManager.getState().recordsToShow ||
          UI?.HISTORY_INITIAL_RECORDS ||
          10) + (UI?.HISTORY_LOAD_MORE_RECORDS || 10);
      window.stateManager.dispatch({
        type: 'SET_STATE',
        payload: { recordsToShow: newCount },
      });
    },

    /** 新規予約のための教室選択モーダルを表示します */
    showClassroomModal: () => {
      if (
        stateManager.getState().classrooms &&
        stateManager.getState().classrooms.length > 0
      ) {
        // 既存のモーダルがあれば削除（重複防止）
        const existingModal = document.getElementById(
          'classroom-selection-modal',
        );
        if (existingModal) {
          existingModal.remove();
        }

        // 新しいモーダルを生成・追加
        const modalHtml = getClassroomSelectionModal();
        document.body.insertAdjacentHTML('beforeend', modalHtml);

        // モーダルを表示
        Components.showModal('classroom-selection-modal');

        // デバッグ用: モーダル内のボタンを確認
        if (!window.isProduction) {
          setTimeout(() => {
            const modalButtons = document.querySelectorAll(
              '#classroom-selection-modal [data-action="selectClassroom"]',
            );
            console.log('🔘 モーダル内ボタン数:', modalButtons.length);
            modalButtons.forEach((btn, index) => {
              console.log(`🔘 ボタン${index + 1}:`, {
                action: btn.dataset.action,
                classroomName: btn.dataset.classroomName,
                classroom: btn.dataset.classroom,
                text: btn.textContent,
              });
            });
          }, 100);
        }
      } else {
        // 教室情報がない場合はデータを更新
        showInfo('教室情報の取得に失敗しました。ホームに戻ります。');
        actionHandlers.goBackToDashboard();
      }
    },

    /** 教室選択モーダルを閉じます */
    closeClassroomModal: () => {
      Components.closeModal('classroom-selection-modal');
    },

    /** プロフィール編集画面に遷移します */
    goToEditProfile: () => {
      // データが古く、かつ更新中でなければデータを更新
      if (
        !stateManager.getState().isDataFresh &&
        !stateManager.getState()._dataUpdateInProgress
      ) {
        updateAppStateFromCache('editProfile');
      } else {
        // 新しいdispatchパターンを使用
        if (window.stateManager) {
          window.stateManager.dispatch({
            type: 'CHANGE_VIEW',
            payload: { view: 'editProfile' },
          });
        } else {
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: { view: 'editProfile' },
          });
        }
      }
    },

    /** 教室を選択し、予約枠一覧画面に遷移します */
    selectClassroom: d => {
      if (!window.isProduction) {
        debugLog(`=== selectClassroom呼び出し: d=${JSON.stringify(d)} ===`);
      }

      // データ取得の複数の方法を試行
      let classroomName = null;

      if (d && d.classroomName) {
        classroomName = d.classroomName;
      } else if (d && d.classroom) {
        classroomName = d.classroom;
      } else if (d && d['classroom-name']) {
        classroomName = d['classroom-name'];
      }

      if (!window.isProduction) {
        debugLog(`=== 教室名: ${classroomName} ===`);
        debugLog(`=== データキー: ${Object.keys(d || {})} ===`);
      }

      if (classroomName) {
        if (!window.isProduction) {
          debugLog(`=== 教室名取得成功: ${classroomName} ===`);
        }
        // 教室選択モーダルを閉じる
        actionHandlers.closeClassroomModal();
        // 常にupdateSlotsAndGoToBookingを呼び出し（内部で鮮度チェックを実行）
        actionHandlers.updateSlotsAndGoToBooking(classroomName);
      } else {
        if (!window.isProduction) {
          debugLog(`=== 教室名取得失敗: d=${JSON.stringify(d)} ===`);
        }
        showInfo('予約枠の取得に失敗しました。時間をおいて再度お試しください。');
      }
    },

    /** スロット情報を更新してから予約枠画面に遷移します（設計書準拠） */
    updateSlotsAndGoToBooking: classroomName => {
      // 更新中の場合は処理をスキップ
      if (stateManager.getState()._dataUpdateInProgress) {
        return;
      }

      // 一度だけローディングを表示
      showLoading('dataFetch');

      google.script.run
        .withSuccessHandler(versionResponse => {
          if (versionResponse.success && versionResponse.data) {
            const currentSlotsVersion = stateManager.getState()._slotsVersion;
            const serverSlotsVersion = versionResponse.data.slotsComposite;

            // バージョンが同じ（データに変更なし）で、既にスロットデータがある場合は即座に遷移
            if (
              currentSlotsVersion === serverSlotsVersion &&
              stateManager.getState().slots &&
              stateManager.getState().slots.length > 0
            ) {
              hideLoading();
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  selectedClassroom: classroomName,
                  view: 'booking',
                  isDataFresh: true,
                },
              });
              return;
            }

            // バージョンが異なる場合、または初回の場合は最新データを取得（ローディングは継続）
            actionHandlers.fetchLatestSlotsData(
              classroomName,
              serverSlotsVersion,
            );
          } else {
            // バージョンチェック失敗時はフォールバック（全データ取得、ローディングは継続）
            actionHandlers.fetchLatestSlotsData(classroomName, null);
          }
        })
        .withFailureHandler(error => {
          // エラー時もフォールバック（全データ取得、ローディングは継続）
          actionHandlers.fetchLatestSlotsData(classroomName, null);
        })
        .getCacheVersions();
    },

    /** 最新の空き枠データを取得する（内部処理） */
    fetchLatestSlotsData: (classroomName, newSlotsVersion) => {
      // ローディングは既に親関数で表示済み

      google.script.run
        .withSuccessHandler(response => {
          hideLoading();

          // デバッグログ追加（本番環境では無効化）
          if (!window.isProduction) {
            debugLog('fetchLatestSlotsData レスポンス受信');
            debugLog('response.success: ' + response.success);
            debugLog('response.data: ' + (response.data ? 'あり' : 'なし'));
          }
          if (response.data) {
            debugLog(
              'response.data.slots: ' +
                (response.data.slots
                  ? `${response.data.slots.length}件`
                  : 'なし'),
            );
          }

          debugLog(
            `=== getBatchData レスポンス: ${JSON.stringify(response)} ===`,
          );
          debugLog(
            `=== レスポンス詳細: success=${response?.success}, hasData=${!!response?.data}, hasSlots=${!!response?.data?.slots} ===`,
          );

          if (response.success && response.data && response.data.slots) {
            debugLog(`空き枠データ更新: ${response.data.slots.length}件`);
            // 空き枠データとバージョン情報を更新
            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                slots: response.data.slots,
                selectedClassroom: classroomName,
                view: 'booking',
                isDataFresh: true,
                _slotsVersion: newSlotsVersion, // バージョン情報を保存
              },
            });
          } else {
            debugLog('空き枠データ取得失敗');
            debugLog(`=== 失敗の詳細: response=${JSON.stringify(response)} ===`);
            if (response.message) {
              debugLog('エラーメッセージ: ' + response.message);
            }
            showInfo(
              '予約枠の取得に失敗しました。時間をおいて再度お試しください。',
            );
          }
        })
        .withFailureHandler(error => {
          hideLoading();
          showInfo(
            '予約枠の取得に失敗しました。時間をおいて再度お試しください。',
          );
          Logger.log(`fetchLatestSlotsDataエラー: ${error}`);
        })
        .getBatchData(['slots'], stateManager.getState().currentUser.phone);
    },

    /** スロット情報を更新してから完了画面に遷移します（設計書準拠） */
    updateSlotsAndGoToComplete: message => {
      // 一度だけローディングを表示
      showLoading('dataFetch');

      google.script.run
        .withSuccessHandler(versionResponse => {
          if (versionResponse.success && versionResponse.data) {
            const currentSlotsVersion = stateManager.getState()._slotsVersion;
            const serverSlotsVersion = versionResponse.data.slotsComposite;

            // バージョンが同じ（データに変更なし）で、既にスロットデータがある場合は即座に遷移
            if (
              currentSlotsVersion === serverSlotsVersion &&
              stateManager.getState().slots &&
              stateManager.getState().slots.length > 0
            ) {
              hideLoading();
              window.stateManager.dispatch({
                type: 'SET_STATE',
                payload: {
                  view: 'complete',
                  completionMessage: message,
                  accountingReservation:
                    stateManager.getState().accountingReservation,
                  isDataFresh: true,
                },
              });
              return;
            }

            // バージョンが異なる場合、または初回の場合は最新データを取得してから遷移（ローディングは継続）
            actionHandlers.fetchLatestSlotsDataForComplete(
              message,
              serverSlotsVersion,
            );
          } else {
            // バージョンチェック失敗時はフォールバック（全データ取得、ローディングは継続）
            actionHandlers.fetchLatestSlotsDataForComplete(message, null);
          }
        })
        .withFailureHandler(error => {
          // エラー時もフォールバック（全データ取得、ローディングは継続）
          actionHandlers.fetchLatestSlotsDataForComplete(message, null);
        })
        .getCacheVersions();
    },

    /** 最新の空き枠データを取得してから完了画面に遷移する（内部処理） */
    fetchLatestSlotsDataForComplete: (message, newSlotsVersion) => {
      // ローディングは既に親関数で表示済み

      google.script.run
        .withSuccessHandler(response => {
          hideLoading();

          if (response.success && response.data && response.data.slots) {
            // 空き枠データとバージョン情報を更新してから完了画面に遷移
            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                slots: response.data.slots,
                view: 'complete',
                completionMessage: message,
                accountingReservation:
                  stateManager.getState().accountingReservation,
                isDataFresh: true,
                _slotsVersion: newSlotsVersion, // バージョン情報を保存
              },
            });
          } else {
            // スロット取得に失敗してもメッセージは表示
            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                view: 'complete',
                completionMessage: message,
                accountingReservation:
                  stateManager.getState().accountingReservation,
                isDataFresh: false,
              },
            });
          }
        })
        .withFailureHandler(error => {
          hideLoading();
          Logger.log(`fetchLatestSlotsDataForCompleteエラー: ${error}`);
          // エラーでもメッセージは表示
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              view: 'complete',
              completionMessage: message,
              accountingReservation:
                stateManager.getState().accountingReservation,
              isDataFresh: false,
            },
          });
        })
        .getBatchData(['slots'], stateManager.getState().currentUser.phone);
    },

    /** 予約枠を選択し、予約確認画面に遷移します */
    bookSlot: d => {
      const foundSlot = stateManager
        .getState()
        .slots.find(s => s.classroom === d.classroom && s.date === d.date);
      if (foundSlot) {
        // 空席数に基づいてisFull状態を確実に設定
        const isFullSlot =
          foundSlot.isFull ||
          foundSlot.availableSlots === 0 ||
          (typeof foundSlot.morningSlots !== 'undefined' &&
            foundSlot.morningSlots === 0 &&
            foundSlot.afternoonSlots === 0);
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: {
            selectedSlot: {
              ...foundSlot,
              isFull: isFullSlot,
            },
            view: 'newReservation',
          },
        });
      } else {
        showInfo('エラーが発生しました。選択した予約枠が見つかりません。');
      }
    },

    /** ログイン画面に戻ります（電話番号入力値を保存） */
    goBackToLogin: () => {
      const phoneInput = document.getElementById('phone');
      const loginPhone = phoneInput
        ? phoneInput.value
        : stateManager.getState().loginPhone;
      window.stateManager.dispatch({
        type: 'NAVIGATE',
        payload: { to: 'login', context: { loginPhone: loginPhone } },
      });
    },

    /** ホーム（メイン画面）に遷移（別名） */
    goBackToDashboard: () => actionHandlers.goToDashboard(),

    /** ホーム（メイン画面）に遷移 */
    goToDashboard: () => {
      if (
        !stateManager.getState().isDataFresh &&
        !stateManager.getState()._dataUpdateInProgress
      ) {
        updateAppStateFromCache('dashboard');
      } else {
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: { view: 'dashboard' },
        });
      }
    },

    /** 予約枠一覧画面に戻ります */
    goBackToBooking: () => {
      const targetClassroom =
        stateManager.getState().selectedSlot?.classroom ||
        stateManager.getState().accountingReservation?.classroom ||
        stateManager.getState().editingReservationDetails?.classroom;

      // スロット情報の鮮度をチェックして必要に応じて更新
      if (
        !stateManager.getState().isDataFresh &&
        !stateManager.getState()._dataUpdateInProgress
      ) {
        actionHandlers.updateSlotsAndGoToBooking(targetClassroom);
      } else {
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: {
            view: 'booking',
            selectedClassroom: targetClassroom,
          },
        });
      }
    },

    /** モーダルの確認ボタンを押したときの処理です */
    modalConfirm: () => {
      ModalManager.executeCallback();
      hideModal();
    },

    /** モーダルのキャンセルボタンを押したときの処理です */
    modalCancel: () => hideModal(),
  };

  /**
   * 会計の確認モーダルを表示
   */
  actionHandlers.showAccountingConfirmation = () => {
    const accountingDetails = calculateAccountingDetails();
    if (!accountingDetails || accountingDetails.grandTotal <= 0) {
      showInfo('合計金額が0円です。項目を選択してください。');
      return;
    }

    const message = `
          <div class="p-4 bg-brand-light rounded-lg text-left space-y-4 text-base" id="modal-accounting-form">
              <div>
                  <span class="font-bold">合計金額:</span> ${accountingDetails.grandTotal.toLocaleString()}円
                  <button data-action="copyGrandTotal" class="ml-2 text-sm bg-action-secondary-bg active:bg-action-secondary-hover text-action-secondary-text font-bold px-2 py-1 rounded">コピー</button>
              </div>
              <div>
                  <span class="font-bold">支払い方法:</span>
                  <div class="mt-2 space-y-3">
                      ${getPaymentOptionsHtml()}
                  </div>
              </div>
              <div class="mt-4">
                  <button id="confirm-payment-button" data-action="confirmAndPay" class="w-full bg-action-primary-bg text-action-primary-text font-bold py-2 rounded disabled:bg-brand-muted" disabled>この内容で支払いました</button>
              </div>
              <p class="text-red-700 font-bold mt-2 text-center">必ずボタンを押してね</p>
          </div>
      `;
    showModal({
      title: 'お会計',
      message: message,
      showCancel: true,
      cancelText:
        window.stateManager.getState().constants?.messages?.CANCEL ||
        'キャンセル',
      onConfirm: null,
    });
  };

  /**
   * 「この内容で支払いました」ボタン押下時の処理
   */
  actionHandlers.confirmAndPay = () => {
    const reservationId =
      stateManager.getState().accountingReservation.reservationId;
    // モーダル内の支払い方法を取得
    const modalForm = document.getElementById('modal-accounting-form');
    let paymentMethod = PAYMENT.CASH;
    if (modalForm) {
      const selected = modalForm.querySelector(
        'input[name="payment-method"]:checked',
      );
      if (selected) paymentMethod = selected.value;
    }

    // --- バックエンドに送信する「ユーザー入力」オブジェクトを構築 ---
    const form = document.getElementById('accounting-form');
    const userInput = {
      paymentMethod: paymentMethod,
      tuitionItems: [],
      salesItems: [],
      timeBased: null,
    };

    // 授業料項目（チェックボックス）
    form
      .querySelectorAll(
        `input[type="checkbox"][data-item-type="${C.itemTypes.TUITION}"]:checked`,
      )
      .forEach(cb => {
        userInput.tuitionItems.push(cb.dataset.itemName);
      });

    // 時間制授業料
    if (document.getElementById('start-time')) {
      const accountingReservation = stateManager.getState().accountingReservation;
      const startTime = getTimeValue(
        'start-time',
        accountingReservation,
        'startTime',
      );
      const endTime = getTimeValue('end-time', accountingReservation, 'endTime');

      userInput.timeBased = {
        startTime: startTime,
        endTime: endTime,
        // バックエンドとの互換性のため、ヘッダー形式も併記
        [window.HEADERS?.RESERVATIONS?.START_TIME || 'startTime']: startTime,
        [window.HEADERS?.RESERVATIONS?.END_TIME || 'endTime']: endTime,
        breakMinutes: parseInt(
          document.getElementById('break-time')?.value || 0,
          10,
        ),
        discountApplied:
          document.getElementById('discount-checkbox')?.checked || false,
      };
    }

    // 物販・材料費項目
    const materialContainer = document.getElementById('materials-container');
    if (materialContainer) {
      materialContainer
        .querySelectorAll('div[data-material-row-index]')
        .forEach((row, index) => {
          const name = document.getElementById(`material-type-${index}`)?.value;
          const priceText =
            document.getElementById(`material-price-${index}`)?.textContent ||
            '0';
          const price = parseInt(priceText.replace(/[^0-9]/g, ''), 10);
          if (name && price > 0)
            userInput.salesItems.push({ name: name, price: price });
        });
    }

    // 物販項目（チェックボックス）
    form
      .querySelectorAll(
        `input[type="checkbox"][data-item-type="${C.itemTypes.SALES}"]:checked`,
      )
      .forEach(cb => {
        userInput.salesItems.push({ name: cb.dataset.itemName });
      });

    form.querySelectorAll('div[data-other-sales-row]').forEach((row, index) => {
      const name = document
        .getElementById(`other-sales-name-${index}`)
        ?.value.trim();
      const price = document.getElementById(`other-sales-price-${index}`)?.value;
      if (name && price)
        userInput.salesItems.push({ name: name, price: Number(price) });
    });
    // --- ここまで ---

    const payload = {
      reservationId: stateManager.getState().accountingReservation.reservationId,
      classroom: stateManager.getState().accountingReservation.classroom,
      studentId: stateManager.getState().currentUser.studentId,
      userInput: userInput,
    };

    showLoading('accounting');
    google.script.run
      .withSuccessHandler(r => {
        if (r.success) {
          clearAccountingCache(reservationId); // <-- キャッシュ削除
          hideModal(); // モーダルを閉じる
          hideLoading();

          // 会計完了後は最新データを取得してホームに戻る
          if (r.data) {
            // バックエンドから最新データが返された場合
            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                ...r.data.initialData,
                myBookings: r.data.myBookings || [],
                history: r.data.initialData.myHistory || [],
                historyTotal: (r.data.initialData.myHistory || []).length,
                slots: r.data.slots || [],
                view: 'dashboard',
                isDataFresh: true, // 最新データ受信済み
              },
            });
          } else {
            // 最新データが返されなかった場合は再読み込み要求
            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: {
                view: 'dashboard',
                isDataFresh: false, // データ再読み込み必要
              },
            });
          }
          showInfo('会計情報を記録しました。', '完了');
        } else {
          hideLoading();
          showInfo(r.message || '会計情報の記録に失敗しました。');
        }
      })
      .withFailureHandler(handleServerError)
      .saveAccountingDetails(payload);
  };

  // =================================================================
  // --- Phone Number Formatting Helper Functions ---
  // -----------------------------------------------------------------
  // 電話番号入力のリアルタイム整形処理
  // =================================================================

  /**
   * 電話番号入力フィールドのリアルタイム整形処理
   * @param {HTMLInputElement} inputElement - 電話番号入力フィールド
   */
  function handlePhoneInputFormatting(inputElement) {
    if (!inputElement) return;

    const originalValue = inputElement.value;
    const cursorPosition = inputElement.selectionStart;

    // 全角数字を半角に変換
    let formattedValue = originalValue.replace(/[０-９]/g, s =>
      String.fromCharCode(s.charCodeAt(0) - 65248),
    );

    // 数字以外を削除（ハイフンは一時的に残す）
    const digitsOnly = formattedValue.replace(/[^\d]/g, '');

    // フォーマット適用
    let formatted = '';
    if (digitsOnly.length > 0) {
      if (digitsOnly.length <= 3) {
        formatted = digitsOnly;
      } else if (digitsOnly.length <= 7) {
        formatted = `${digitsOnly.slice(0, 3)}-${digitsOnly.slice(3)}`;
      } else if (digitsOnly.length <= 11) {
        if (digitsOnly.length === 10) {
          // 10桁の場合: 03-1234-5678
          formatted = `${digitsOnly.slice(0, 2)}-${digitsOnly.slice(2, 6)}-${digitsOnly.slice(6)}`;
        } else {
          // 11桁の場合: 090-1234-5678
          formatted = `${digitsOnly.slice(0, 3)}-${digitsOnly.slice(3, 7)}-${digitsOnly.slice(7)}`;
        }
      } else {
        // 11桁を超える場合は11桁までに制限
        const truncated = digitsOnly.slice(0, 11);
        formatted = `${truncated.slice(0, 3)}-${truncated.slice(3, 7)}-${truncated.slice(7)}`;
      }
    }

    // 値が変更された場合のみ更新
    if (formatted !== originalValue) {
      inputElement.value = formatted;

      // カーソル位置を調整（ハイフンの追加を考慮）
      const newCursorPosition = Math.min(
        cursorPosition + (formatted.length - originalValue.length),
        formatted.length,
      );
      inputElement.setSelectionRange(newCursorPosition, newCursorPosition);
    }
  }

  // =================================================================
  // --- Main Application Logic ---
  // -----------------------------------------------------------------
  // アプリケーションの起動、サーバーとの通信、状態管理、画面描画など、
  // 全体を制御するコアとなる関数群です。
  // =================================================================

  /**
   * 注意: setState関数はStateManagerシステムに統合されました
   * 新しいコードでは stateManager.dispatch() を使用してください
   *
   * 下位互換性のためのsetState関数は12_WebApp_StateManager.htmlで定義され、
   * 自動的にStateManagerのdispatch()にマッピングされます
   */

  /**
   * バッチ処理でキャッシュから最新データを取得してappStateを更新
   * ユーザーの予約・履歴・スロット情報を一括取得し、指定されたビューに遷移
   * @param {string} targetView - データ取得後に遷移したいビュー名
   */
  function updateAppStateFromCache(targetView) {
    if (
      !stateManager.getState().currentUser ||
      !stateManager.getState().currentUser.phone
    ) {
      if (targetView) {
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: { view: targetView },
        });
      }
      return;
    }

    // 更新中フラグを設定
    window.stateManager.dispatch({
      type: 'SET_STATE',
      payload: { _dataUpdateInProgress: true },
    });

    showLoading('最新データを取得中...');
    google.script.run
      .withSuccessHandler(response => {
        hideLoading();
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: { _dataUpdateInProgress: false },
        }); // フラグをクリア

        if (response.success && response.userFound) {
          // バッチ処理結果からappStateを更新
          const newAppState = processInitialData(
            response.data.initial,
            stateManager.getState().currentUser.phone,
            response.data.slots,
          );
          // 現在のビューと重要な状態は保持、ただしtargetViewが指定されていればそちらを優先
          const preservedState = {
            view: targetView || stateManager.getState().view,
            selectedClassroom: stateManager.getState().selectedClassroom,
            selectedSlot: stateManager.getState().selectedSlot,
            editingReservationDetails:
              stateManager.getState().editingReservationDetails,
            accountingReservation: stateManager.getState().accountingReservation,
            isDataFresh: true, // 新鮮なデータが読み込まれたことを記録
          };
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: { ...newAppState, ...preservedState },
          }); // setStateに統合し、状態更新と再描画を一元化
        } else {
          // 失敗時もsetStateを介して状態を更新し、再描画をトリガーする
          window.stateManager.dispatch({
            type: 'SET_STATE',
            payload: {
              _dataUpdateInProgress: false,
              view: targetView || stateManager.getState().view,
            },
          });
          showInfo(response.message || 'データの取得に失敗しました。');
        }
      })
      .withFailureHandler(err => {
        hideLoading();
        window.stateManager.dispatch({
          type: 'SET_STATE',
          payload: {
            _dataUpdateInProgress: false,
            view: targetView || stateManager.getState().view,
          },
        }); // フラグをクリア
        handleServerError(err);
        // setStateがrenderを呼び出すので、ここでのrender()は不要
      })
      .getBatchData(
        ['initial', 'slots'],
        stateManager.getState().currentUser.phone,
      );
  }

  /**
   * 現在のアプリケーションの状態に基づいて、適切なビューを描画する
   * データ更新の必要性を判定し、必要に応じて最新データ取得後に再描画
   * stateManager.getState().viewの値に応じて対応するビュー関数を呼び出してUIを更新
   */
  function render() {
    // appStateの安全な参照確認
    const appState = window.stateManager?.getState();
    if (!appState) {
      console.warn('render(): stateManagerが未初期化のため処理をスキップします');
      return;
    }

    console.log('🎨 render実行:', appState.view);

    // 無限ループを避けるため、データ更新処理は削除
    // 単純にビューを描画するだけ

    let v = '';
    switch (appState.view) {
      case 'login':
        v = getLoginView();
        break;
      case 'register':
        v = getRegisterView(appState.registrationPhone);
        break;
      case 'registrationStep2':
        v = getRegistrationStep2View();
        break;
      case 'registrationStep3':
        v = getRegistrationStep3View();
        break;
      case 'registrationStep4':
        v = getRegistrationStep4View();
        break;
      case 'dashboard':
        v = getDashboardView();
        break;
      case 'editProfile':
        v = getEditProfileView();
        break;
      case 'booking':
        v = getBookingView(appState.selectedClassroom);
        break;
      case 'newReservation':
        v = getReservationFormView('new');
        break;
      case 'editReservation':
        v = getReservationFormView('edit');
        break;
      case 'accounting':
        v = getAccountingView();
        break;
      case 'complete':
        v = getCompleteView(appState.completionMessage);
        break;
      case 'userSearch':
        v = getUserSearchView();
        break;
    }
    document.getElementById('view-container').innerHTML =
      `<div class="fade-in">${v}</div>`;

    // 戻るボタンを動的に更新
    const backButtonContainer = document.getElementById('back-button-container');
    if (backButtonContainer) {
      backButtonContainer.innerHTML = Components.createSmartBackButton(
        appState.view,
        appState,
      );
    }

    // 会計画面の場合、イベントリスナーを設定
    if (appState.view === 'accounting') {
      // DOM更新後にイベントリスナーを設定するため、次のフレームで実行
      requestAnimationFrame(() => {
        setupAccountingEventListeners();
        // 初期計算も実行
        updateAccountingCalculation();
      });
    }

    window.scrollTo(0, 0);
  }

  /**
   * 会計画面での入力変更を処理します。
   * 合計金額の再計算と、入力内容のキャッシュ保存を行います。
   */
  function handleAccountingFormChange() {
    // リアルタイムで合計金額を再計算
    calculateAccountingDetails();

    // フォーム内容が変更されたら、キャッシュに保存する
    const reservationId =
      stateManager.getState().accountingReservation?.reservationId;
    if (reservationId) {
      const accountingData = getAccountingFormData();
      saveAccountingCache(reservationId, accountingData);
    }
  }

  /**
   * アプリケーションの起動点です。
   * ページ読み込み完了時に実行され、イベントリスナーを設定します。
   */
  window.onload = function () {
    const app = document.getElementById('app');

    // イベントハンドラー関数を定義
    const handleClick = e => {
      // 【修正】buttonまたはdata-action属性を持つ要素を対象にする
      const targetElement = e.target.closest('button, [data-action]');
      if (targetElement?.dataset.action) {
        const { action, ...data } = targetElement.dataset;

        // デバッグ情報を追加
        if (!window.isProduction) {
          console.log('🔘 クリックイベント:', {
            action,
            data,
            element: targetElement,
            tagName: targetElement.tagName,
            modalContext: e.target.closest('[data-modal-content]')
              ? 'モーダル内'
              : '通常',
            timestamp: new Date().getTime(),
            eventPhase: e.eventPhase,
          });
        }

        // モーダル内の場合は、イベント伝播を継続する
        if (
          e.target.closest('[data-modal-content]') &&
          targetElement.dataset.action
        ) {
          // イベント伝播を停止しない（モーダル内のボタンを有効にする）
        }

        if (action === 'copyToClipboard' || action === 'copyGrandTotal') {
          actionHandlers[action](targetElement);
        } else if (actionHandlers[action]) {
          actionHandlers[action](data);
        } else {
          // ハンドラーが見つからない場合のデバッグ
          if (!window.isProduction) {
            console.warn('⚠️ アクションハンドラーが見つかりません:', action);
          }
        }
      }
    };

    // アプリ要素とdocument両方でクリックイベントを捕捉（モーダル対応）
    // 重複を避けるため、documentレベルのみでイベントを処理
    document.addEventListener('click', handleClick);

    // アプリ全体の入力・変更イベントを捕捉
    app.addEventListener('change', e => {
      // 会計モーダルでの支払い方法選択
      if (
        e.target.matches('#modal-accounting-form input[name="payment-method"]')
      ) {
        document
          .getElementById('confirm-payment-button')
          ?.removeAttribute('disabled');
      }

      // 会計画面での変更（主に select や checkbox）
      const accountingForm = e.target.closest('#accounting-form');
      if (stateManager.getState().view === 'accounting' && accountingForm) {
        handleAccountingFormChange();

        // デバッグログ
        if (!window.isProduction) {
          console.log('🔄 会計フォーム変更イベント:', {
            element: e.target.name || e.target.id,
            value: e.target.value,
            checked: e.target.checked,
          });
        }
      }

      // 新規登録Step3での経験有無による表示切り替え
      if (e.target.name === 'experience') {
        const pastWorkContainer = document.getElementById('past-work-container');
        if (pastWorkContainer) {
          pastWorkContainer.classList.toggle(
            'hidden',
            e.target.value === 'はじめて！',
          );
        }
      }
    });

    // アプリ全体の入力イベントを捕捉（主に text や textarea）
    app.addEventListener('input', e => {
      // 会計画面での変更
      const accountingForm = e.target.closest('#accounting-form');
      if (stateManager.getState().view === 'accounting' && accountingForm) {
        handleAccountingFormChange();
      }

      // 電話番号入力のリアルタイム整形
      if (e.target.id === 'phone' || e.target.id === 'edit-phone') {
        handlePhoneInputFormatting(e.target);
      }
    });

    // 初期画面を描画
    render();
  };

</script>
    
    <!-- 状態管理システム -->
    
    <!-- 中核機能・ユーティリティ -->
    
    <!-- UIコンポーネント -->
    
    <!-- 画面生成関数 -->
    
    <!-- イベント処理・アクション -->

    <script>
      // 環境判定：本番環境かテスト環境かを確認
      const isProduction =
        window.location.href.includes('/exec?') ||
        (window.location.href.includes('/macros/s/') &&
          !window.location.href.includes('/dev'));

      // デバッグ制御（フロントエンド専用）
      const DEBUG_ENABLED = false; // 本番環境では false

      // デバッグ情報をコンソールに出力する関数（本番環境では無効化）
      function debugLog(message) {
        if (isProduction || !DEBUG_ENABLED) return; // 本番環境では何も表示しない
        console.log(
          '🔍 [DEBUG]',
          new Date().toLocaleTimeString() + ':',
          message,
        );
      }

      // 最初のテスト - これが表示されなければHTMLファイル自体が読み込まれていない
      debugLog('HTMLファイル読み込み確認テスト完了');
      debugLog('ページURL: ' + window.location.href);

      // GAS環境かどうかを判定
      const isGAS =
        typeof google !== 'undefined' && typeof google.script !== 'undefined';
      debugLog('GAS環境判定: ' + isGAS);

      function initializeApp() {
        debugLog('initializeApp実行開始');
        debugLog('isGAS: ' + isGAS);

        // 必要な変数や関数が定義されるまで待機
        const checkReady = setInterval(() => {
          const status = {
            DesignConfig: typeof DesignConfig !== 'undefined',
            stateManager: typeof stateManager !== 'undefined',
            stateManagerDispatch: typeof stateManager?.dispatch === 'function',
            hideLoading: typeof hideLoading === 'function',
          };

          debugLog('初期化条件チェック: ' + JSON.stringify(status));

          // DesignConfig, stateManager, hideLoadingが利用可能か確認
          if (
            typeof DesignConfig !== 'undefined' &&
            typeof stateManager !== 'undefined' &&
            typeof stateManager?.dispatch === 'function' &&
            typeof hideLoading === 'function'
          ) {
            clearInterval(checkReady);
            debugLog('初期化条件を満たしました！');
            debugLog(
              'stateManager.getState().slots: ' +
                (stateManager.getState().slots
                  ? stateManager.getState().slots.length + '件'
                  : 'null'),
            );
            debugLog(
              'stateManager.getState().classrooms: ' +
                JSON.stringify(stateManager.getState().classrooms),
            );

            window.stateManager.dispatch({
              type: 'SET_STATE',
              payload: { view: 'login' },
            });
            hideLoading();
          }
        }, 300);
      }

      if (isGAS) {
        // GAS本番環境のみ初期化
        window.addEventListener('DOMContentLoaded', () => {
          initializeApp();
        });
      }
    </script>
  </body>
</html>
